
G_001.elf:     file format elf32-tricore

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .CPU3.ustack  00000800  40014e00  40014e00  000005b4  2**0
                  ALLOC
  1 .CPU3.istack  00000400  40015700  40015700  000005b4  2**0
                  ALLOC
  2 .CPU3.csa     00002000  40015c00  40015c00  000005b4  2**0
                  ALLOC
  3 .CPU2.ustack  00000800  50014e00  50014e00  000005b4  2**0
                  ALLOC
  4 .CPU2.istack  00000400  50015700  50015700  000005b4  2**0
                  ALLOC
  5 .CPU2.csa     00002000  50015c00  50015c00  000005b4  2**0
                  ALLOC
  6 .CPU1.ustack  00000800  60038e00  60038e00  000005b4  2**0
                  ALLOC
  7 .CPU1.istack  00000400  60039700  60039700  000005b4  2**0
                  ALLOC
  8 .CPU1.csa     00002000  60039c00  60039c00  000005b4  2**0
                  ALLOC
  9 .CPU0.ustack  00000800  70038e00  70038e00  000005b4  2**0
                  ALLOC
 10 .CPU0.istack  00000400  70039700  70039700  000005b4  2**0
                  ALLOC
 11 .CPU0.csa     00002000  70039c00  70039c00  000005b4  2**0
                  ALLOC
 12 .start_tc0    0000000c  a0000000  a0000000  00006386  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .traptab_tc0  00000100  80000100  80000100  000005c0  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 14 .traptab_tc1  00000100  80300000  80300000  00005aa0  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 15 .traptab_tc2  00000100  80600000  80600000  00005da0  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 16 .traptab_tc3  00000100  80900000  80900000  000060a0  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 17 .start_tc1    0000000c  a0300100  a0300100  00006392  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .start_tc2    0000000c  a0600100  a0600100  0000639e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .start_tc3    0000000c  a0900100  a0900100  000063aa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .inttab_tc0_000 00000000  802fe000  802fe000  00007358  2**0
                  CONTENTS
 21 .inttab_tc0_001 0000000e  802fe020  802fe020  00005a24  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .inttab_tc0_002 0000001c  802fe040  802fe040  00005a32  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .inttab_tc0_003 0000000e  802fe060  802fe060  00005a4e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .inttab_tc0_004 0000000e  802fe080  802fe080  00005a5c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .inttab_tc0_005 0000000e  802fe0a0  802fe0a0  00005a6a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .inttab_tc0_006 0000000e  802fe0c0  802fe0c0  00005a78  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .inttab_tc0_007 0000000e  802fe0e0  802fe0e0  00005a86  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .inttab_tc0_008 00000000  802fe100  802fe100  00007358  2**0
                  CONTENTS
 29 .inttab_tc0_009 00000000  802fe120  802fe120  00007358  2**0
                  CONTENTS
 30 .inttab_tc0_00A 00000000  802fe140  802fe140  00007358  2**0
                  CONTENTS
 31 .inttab_tc0_00B 00000000  802fe160  802fe160  00007358  2**0
                  CONTENTS
 32 .inttab_tc0_00C 00000000  802fe180  802fe180  00007358  2**0
                  CONTENTS
 33 .inttab_tc0_00D 00000000  802fe1a0  802fe1a0  00007358  2**0
                  CONTENTS
 34 .inttab_tc0_00E 00000000  802fe1c0  802fe1c0  00007358  2**0
                  CONTENTS
 35 .inttab_tc0_00F 00000000  802fe1e0  802fe1e0  00007358  2**0
                  CONTENTS
 36 .inttab_tc0_010 00000000  802fe200  802fe200  00007358  2**0
                  CONTENTS
 37 .inttab_tc0_011 00000000  802fe220  802fe220  00007358  2**0
                  CONTENTS
 38 .inttab_tc0_012 00000000  802fe240  802fe240  00007358  2**0
                  CONTENTS
 39 .inttab_tc0_013 00000000  802fe260  802fe260  00007358  2**0
                  CONTENTS
 40 .inttab_tc0_014 00000000  802fe280  802fe280  00007358  2**0
                  CONTENTS
 41 .inttab_tc0_015 00000000  802fe2a0  802fe2a0  00007358  2**0
                  CONTENTS
 42 .inttab_tc0_016 00000000  802fe2c0  802fe2c0  00007358  2**0
                  CONTENTS
 43 .inttab_tc0_017 00000000  802fe2e0  802fe2e0  00007358  2**0
                  CONTENTS
 44 .inttab_tc0_018 00000000  802fe300  802fe300  00007358  2**0
                  CONTENTS
 45 .inttab_tc0_019 00000000  802fe320  802fe320  00007358  2**0
                  CONTENTS
 46 .inttab_tc0_01A 00000000  802fe340  802fe340  00007358  2**0
                  CONTENTS
 47 .inttab_tc0_01B 00000000  802fe360  802fe360  00007358  2**0
                  CONTENTS
 48 .inttab_tc0_01C 00000000  802fe380  802fe380  00007358  2**0
                  CONTENTS
 49 .inttab_tc0_01D 00000000  802fe3a0  802fe3a0  00007358  2**0
                  CONTENTS
 50 .inttab_tc0_01E 00000000  802fe3c0  802fe3c0  00007358  2**0
                  CONTENTS
 51 .inttab_tc0_01F 00000000  802fe3e0  802fe3e0  00007358  2**0
                  CONTENTS
 52 .inttab_tc0_020 00000000  802fe400  802fe400  00007358  2**0
                  CONTENTS
 53 .inttab_tc0_021 00000000  802fe420  802fe420  00007358  2**0
                  CONTENTS
 54 .inttab_tc0_022 00000000  802fe440  802fe440  00007358  2**0
                  CONTENTS
 55 .inttab_tc0_023 00000000  802fe460  802fe460  00007358  2**0
                  CONTENTS
 56 .inttab_tc0_024 00000000  802fe480  802fe480  00007358  2**0
                  CONTENTS
 57 .inttab_tc0_025 00000000  802fe4a0  802fe4a0  00007358  2**0
                  CONTENTS
 58 .inttab_tc0_026 00000000  802fe4c0  802fe4c0  00007358  2**0
                  CONTENTS
 59 .inttab_tc0_027 00000000  802fe4e0  802fe4e0  00007358  2**0
                  CONTENTS
 60 .inttab_tc0_028 00000000  802fe500  802fe500  00007358  2**0
                  CONTENTS
 61 .inttab_tc0_029 00000000  802fe520  802fe520  00007358  2**0
                  CONTENTS
 62 .inttab_tc0_02A 00000000  802fe540  802fe540  00007358  2**0
                  CONTENTS
 63 .inttab_tc0_02B 00000000  802fe560  802fe560  00007358  2**0
                  CONTENTS
 64 .inttab_tc0_02C 00000000  802fe580  802fe580  00007358  2**0
                  CONTENTS
 65 .inttab_tc0_02D 00000000  802fe5a0  802fe5a0  00007358  2**0
                  CONTENTS
 66 .inttab_tc0_02E 00000000  802fe5c0  802fe5c0  00007358  2**0
                  CONTENTS
 67 .inttab_tc0_02F 00000000  802fe5e0  802fe5e0  00007358  2**0
                  CONTENTS
 68 .inttab_tc0_030 00000000  802fe600  802fe600  00007358  2**0
                  CONTENTS
 69 .inttab_tc0_031 00000000  802fe620  802fe620  00007358  2**0
                  CONTENTS
 70 .inttab_tc0_032 00000000  802fe640  802fe640  00007358  2**0
                  CONTENTS
 71 .inttab_tc0_033 00000000  802fe660  802fe660  00007358  2**0
                  CONTENTS
 72 .inttab_tc0_034 00000000  802fe680  802fe680  00007358  2**0
                  CONTENTS
 73 .inttab_tc0_035 00000000  802fe6a0  802fe6a0  00007358  2**0
                  CONTENTS
 74 .inttab_tc0_036 00000000  802fe6c0  802fe6c0  00007358  2**0
                  CONTENTS
 75 .inttab_tc0_037 00000000  802fe6e0  802fe6e0  00007358  2**0
                  CONTENTS
 76 .inttab_tc0_038 00000000  802fe700  802fe700  00007358  2**0
                  CONTENTS
 77 .inttab_tc0_039 00000000  802fe720  802fe720  00007358  2**0
                  CONTENTS
 78 .inttab_tc0_03A 00000000  802fe740  802fe740  00007358  2**0
                  CONTENTS
 79 .inttab_tc0_03B 00000000  802fe760  802fe760  00007358  2**0
                  CONTENTS
 80 .inttab_tc0_03C 00000000  802fe780  802fe780  00007358  2**0
                  CONTENTS
 81 .inttab_tc0_03D 00000000  802fe7a0  802fe7a0  00007358  2**0
                  CONTENTS
 82 .inttab_tc0_03E 00000000  802fe7c0  802fe7c0  00007358  2**0
                  CONTENTS
 83 .inttab_tc0_03F 00000000  802fe7e0  802fe7e0  00007358  2**0
                  CONTENTS
 84 .inttab_tc0_040 00000000  802fe800  802fe800  00007358  2**0
                  CONTENTS
 85 .inttab_tc0_041 00000000  802fe820  802fe820  00007358  2**0
                  CONTENTS
 86 .inttab_tc0_042 00000000  802fe840  802fe840  00007358  2**0
                  CONTENTS
 87 .inttab_tc0_043 00000000  802fe860  802fe860  00007358  2**0
                  CONTENTS
 88 .inttab_tc0_044 00000000  802fe880  802fe880  00007358  2**0
                  CONTENTS
 89 .inttab_tc0_045 00000000  802fe8a0  802fe8a0  00007358  2**0
                  CONTENTS
 90 .inttab_tc0_046 00000000  802fe8c0  802fe8c0  00007358  2**0
                  CONTENTS
 91 .inttab_tc0_047 00000000  802fe8e0  802fe8e0  00007358  2**0
                  CONTENTS
 92 .inttab_tc0_048 00000000  802fe900  802fe900  00007358  2**0
                  CONTENTS
 93 .inttab_tc0_049 00000000  802fe920  802fe920  00007358  2**0
                  CONTENTS
 94 .inttab_tc0_04A 00000000  802fe940  802fe940  00007358  2**0
                  CONTENTS
 95 .inttab_tc0_04B 00000000  802fe960  802fe960  00007358  2**0
                  CONTENTS
 96 .inttab_tc0_04C 00000000  802fe980  802fe980  00007358  2**0
                  CONTENTS
 97 .inttab_tc0_04D 00000000  802fe9a0  802fe9a0  00007358  2**0
                  CONTENTS
 98 .inttab_tc0_04E 00000000  802fe9c0  802fe9c0  00007358  2**0
                  CONTENTS
 99 .inttab_tc0_04F 00000000  802fe9e0  802fe9e0  00007358  2**0
                  CONTENTS
100 .inttab_tc0_050 00000000  802fea00  802fea00  00007358  2**0
                  CONTENTS
101 .inttab_tc0_051 00000000  802fea20  802fea20  00007358  2**0
                  CONTENTS
102 .inttab_tc0_052 00000000  802fea40  802fea40  00007358  2**0
                  CONTENTS
103 .inttab_tc0_053 00000000  802fea60  802fea60  00007358  2**0
                  CONTENTS
104 .inttab_tc0_054 00000000  802fea80  802fea80  00007358  2**0
                  CONTENTS
105 .inttab_tc0_055 00000000  802feaa0  802feaa0  00007358  2**0
                  CONTENTS
106 .inttab_tc0_056 00000000  802feac0  802feac0  00007358  2**0
                  CONTENTS
107 .inttab_tc0_057 00000000  802feae0  802feae0  00007358  2**0
                  CONTENTS
108 .inttab_tc0_058 00000000  802feb00  802feb00  00007358  2**0
                  CONTENTS
109 .inttab_tc0_059 00000000  802feb20  802feb20  00007358  2**0
                  CONTENTS
110 .inttab_tc0_05A 00000000  802feb40  802feb40  00007358  2**0
                  CONTENTS
111 .inttab_tc0_05B 00000000  802feb60  802feb60  00007358  2**0
                  CONTENTS
112 .inttab_tc0_05C 00000000  802feb80  802feb80  00007358  2**0
                  CONTENTS
113 .inttab_tc0_05D 00000000  802feba0  802feba0  00007358  2**0
                  CONTENTS
114 .inttab_tc0_05E 00000000  802febc0  802febc0  00007358  2**0
                  CONTENTS
115 .inttab_tc0_05F 00000000  802febe0  802febe0  00007358  2**0
                  CONTENTS
116 .inttab_tc0_060 00000000  802fec00  802fec00  00007358  2**0
                  CONTENTS
117 .inttab_tc0_061 00000000  802fec20  802fec20  00007358  2**0
                  CONTENTS
118 .inttab_tc0_062 00000000  802fec40  802fec40  00007358  2**0
                  CONTENTS
119 .inttab_tc0_063 00000000  802fec60  802fec60  00007358  2**0
                  CONTENTS
120 .inttab_tc0_064 00000000  802fec80  802fec80  00007358  2**0
                  CONTENTS
121 .inttab_tc0_065 00000000  802feca0  802feca0  00007358  2**0
                  CONTENTS
122 .inttab_tc0_066 00000000  802fecc0  802fecc0  00007358  2**0
                  CONTENTS
123 .inttab_tc0_067 00000000  802fece0  802fece0  00007358  2**0
                  CONTENTS
124 .inttab_tc0_068 00000000  802fed00  802fed00  00007358  2**0
                  CONTENTS
125 .inttab_tc0_069 00000000  802fed20  802fed20  00007358  2**0
                  CONTENTS
126 .inttab_tc0_06A 00000000  802fed40  802fed40  00007358  2**0
                  CONTENTS
127 .inttab_tc0_06B 00000000  802fed60  802fed60  00007358  2**0
                  CONTENTS
128 .inttab_tc0_06C 00000000  802fed80  802fed80  00007358  2**0
                  CONTENTS
129 .inttab_tc0_06D 00000000  802feda0  802feda0  00007358  2**0
                  CONTENTS
130 .inttab_tc0_06E 00000000  802fedc0  802fedc0  00007358  2**0
                  CONTENTS
131 .inttab_tc0_06F 00000000  802fede0  802fede0  00007358  2**0
                  CONTENTS
132 .inttab_tc0_070 00000000  802fee00  802fee00  00007358  2**0
                  CONTENTS
133 .inttab_tc0_071 00000000  802fee20  802fee20  00007358  2**0
                  CONTENTS
134 .inttab_tc0_072 00000000  802fee40  802fee40  00007358  2**0
                  CONTENTS
135 .inttab_tc0_073 00000000  802fee60  802fee60  00007358  2**0
                  CONTENTS
136 .inttab_tc0_074 00000000  802fee80  802fee80  00007358  2**0
                  CONTENTS
137 .inttab_tc0_075 00000000  802feea0  802feea0  00007358  2**0
                  CONTENTS
138 .inttab_tc0_076 00000000  802feec0  802feec0  00007358  2**0
                  CONTENTS
139 .inttab_tc0_077 00000000  802feee0  802feee0  00007358  2**0
                  CONTENTS
140 .inttab_tc0_078 00000000  802fef00  802fef00  00007358  2**0
                  CONTENTS
141 .inttab_tc0_079 00000000  802fef20  802fef20  00007358  2**0
                  CONTENTS
142 .inttab_tc0_07A 00000000  802fef40  802fef40  00007358  2**0
                  CONTENTS
143 .inttab_tc0_07B 00000000  802fef60  802fef60  00007358  2**0
                  CONTENTS
144 .inttab_tc0_07C 00000000  802fef80  802fef80  00007358  2**0
                  CONTENTS
145 .inttab_tc0_07D 00000000  802fefa0  802fefa0  00007358  2**0
                  CONTENTS
146 .inttab_tc0_07E 00000000  802fefc0  802fefc0  00007358  2**0
                  CONTENTS
147 .inttab_tc0_07F 00000000  802fefe0  802fefe0  00007358  2**0
                  CONTENTS
148 .inttab_tc0_080 00000000  802ff000  802ff000  00007358  2**0
                  CONTENTS
149 .inttab_tc0_081 00000000  802ff020  802ff020  00007358  2**0
                  CONTENTS
150 .inttab_tc0_082 00000000  802ff040  802ff040  00007358  2**0
                  CONTENTS
151 .inttab_tc0_083 00000000  802ff060  802ff060  00007358  2**0
                  CONTENTS
152 .inttab_tc0_084 00000000  802ff080  802ff080  00007358  2**0
                  CONTENTS
153 .inttab_tc0_085 00000000  802ff0a0  802ff0a0  00007358  2**0
                  CONTENTS
154 .inttab_tc0_086 00000000  802ff0c0  802ff0c0  00007358  2**0
                  CONTENTS
155 .inttab_tc0_087 00000000  802ff0e0  802ff0e0  00007358  2**0
                  CONTENTS
156 .inttab_tc0_088 00000000  802ff100  802ff100  00007358  2**0
                  CONTENTS
157 .inttab_tc0_089 00000000  802ff120  802ff120  00007358  2**0
                  CONTENTS
158 .inttab_tc0_08A 00000000  802ff140  802ff140  00007358  2**0
                  CONTENTS
159 .inttab_tc0_08B 00000000  802ff160  802ff160  00007358  2**0
                  CONTENTS
160 .inttab_tc0_08C 00000000  802ff180  802ff180  00007358  2**0
                  CONTENTS
161 .inttab_tc0_08D 00000000  802ff1a0  802ff1a0  00007358  2**0
                  CONTENTS
162 .inttab_tc0_08E 00000000  802ff1c0  802ff1c0  00007358  2**0
                  CONTENTS
163 .inttab_tc0_08F 00000000  802ff1e0  802ff1e0  00007358  2**0
                  CONTENTS
164 .inttab_tc0_090 00000000  802ff200  802ff200  00007358  2**0
                  CONTENTS
165 .inttab_tc0_091 00000000  802ff220  802ff220  00007358  2**0
                  CONTENTS
166 .inttab_tc0_092 00000000  802ff240  802ff240  00007358  2**0
                  CONTENTS
167 .inttab_tc0_093 00000000  802ff260  802ff260  00007358  2**0
                  CONTENTS
168 .inttab_tc0_094 00000000  802ff280  802ff280  00007358  2**0
                  CONTENTS
169 .inttab_tc0_095 00000000  802ff2a0  802ff2a0  00007358  2**0
                  CONTENTS
170 .inttab_tc0_096 00000000  802ff2c0  802ff2c0  00007358  2**0
                  CONTENTS
171 .inttab_tc0_097 00000000  802ff2e0  802ff2e0  00007358  2**0
                  CONTENTS
172 .inttab_tc0_098 00000000  802ff300  802ff300  00007358  2**0
                  CONTENTS
173 .inttab_tc0_099 00000000  802ff320  802ff320  00007358  2**0
                  CONTENTS
174 .inttab_tc0_09A 00000000  802ff340  802ff340  00007358  2**0
                  CONTENTS
175 .inttab_tc0_09B 00000000  802ff360  802ff360  00007358  2**0
                  CONTENTS
176 .inttab_tc0_09C 00000000  802ff380  802ff380  00007358  2**0
                  CONTENTS
177 .inttab_tc0_09D 00000000  802ff3a0  802ff3a0  00007358  2**0
                  CONTENTS
178 .inttab_tc0_09E 00000000  802ff3c0  802ff3c0  00007358  2**0
                  CONTENTS
179 .inttab_tc0_09F 00000000  802ff3e0  802ff3e0  00007358  2**0
                  CONTENTS
180 .inttab_tc0_0A0 00000000  802ff400  802ff400  00007358  2**0
                  CONTENTS
181 .inttab_tc0_0A1 00000000  802ff420  802ff420  00007358  2**0
                  CONTENTS
182 .inttab_tc0_0A2 00000000  802ff440  802ff440  00007358  2**0
                  CONTENTS
183 .inttab_tc0_0A3 00000000  802ff460  802ff460  00007358  2**0
                  CONTENTS
184 .inttab_tc0_0A4 00000000  802ff480  802ff480  00007358  2**0
                  CONTENTS
185 .inttab_tc0_0A5 00000000  802ff4a0  802ff4a0  00007358  2**0
                  CONTENTS
186 .inttab_tc0_0A6 00000000  802ff4c0  802ff4c0  00007358  2**0
                  CONTENTS
187 .inttab_tc0_0A7 00000000  802ff4e0  802ff4e0  00007358  2**0
                  CONTENTS
188 .inttab_tc0_0A8 00000000  802ff500  802ff500  00007358  2**0
                  CONTENTS
189 .inttab_tc0_0A9 00000000  802ff520  802ff520  00007358  2**0
                  CONTENTS
190 .inttab_tc0_0AA 00000000  802ff540  802ff540  00007358  2**0
                  CONTENTS
191 .inttab_tc0_0AB 00000000  802ff560  802ff560  00007358  2**0
                  CONTENTS
192 .inttab_tc0_0AC 00000000  802ff580  802ff580  00007358  2**0
                  CONTENTS
193 .inttab_tc0_0AD 00000000  802ff5a0  802ff5a0  00007358  2**0
                  CONTENTS
194 .inttab_tc0_0AE 00000000  802ff5c0  802ff5c0  00007358  2**0
                  CONTENTS
195 .inttab_tc0_0AF 00000000  802ff5e0  802ff5e0  00007358  2**0
                  CONTENTS
196 .inttab_tc0_0B0 00000000  802ff600  802ff600  00007358  2**0
                  CONTENTS
197 .inttab_tc0_0B1 00000000  802ff620  802ff620  00007358  2**0
                  CONTENTS
198 .inttab_tc0_0B2 00000000  802ff640  802ff640  00007358  2**0
                  CONTENTS
199 .inttab_tc0_0B3 00000000  802ff660  802ff660  00007358  2**0
                  CONTENTS
200 .inttab_tc0_0B4 00000000  802ff680  802ff680  00007358  2**0
                  CONTENTS
201 .inttab_tc0_0B5 00000000  802ff6a0  802ff6a0  00007358  2**0
                  CONTENTS
202 .inttab_tc0_0B6 00000000  802ff6c0  802ff6c0  00007358  2**0
                  CONTENTS
203 .inttab_tc0_0B7 00000000  802ff6e0  802ff6e0  00007358  2**0
                  CONTENTS
204 .inttab_tc0_0B8 00000000  802ff700  802ff700  00007358  2**0
                  CONTENTS
205 .inttab_tc0_0B9 00000000  802ff720  802ff720  00007358  2**0
                  CONTENTS
206 .inttab_tc0_0BA 00000000  802ff740  802ff740  00007358  2**0
                  CONTENTS
207 .inttab_tc0_0BB 00000000  802ff760  802ff760  00007358  2**0
                  CONTENTS
208 .inttab_tc0_0BC 00000000  802ff780  802ff780  00007358  2**0
                  CONTENTS
209 .inttab_tc0_0BD 00000000  802ff7a0  802ff7a0  00007358  2**0
                  CONTENTS
210 .inttab_tc0_0BE 00000000  802ff7c0  802ff7c0  00007358  2**0
                  CONTENTS
211 .inttab_tc0_0BF 00000000  802ff7e0  802ff7e0  00007358  2**0
                  CONTENTS
212 .inttab_tc0_0C0 00000000  802ff800  802ff800  00007358  2**0
                  CONTENTS
213 .inttab_tc0_0C1 00000000  802ff820  802ff820  00007358  2**0
                  CONTENTS
214 .inttab_tc0_0C2 00000000  802ff840  802ff840  00007358  2**0
                  CONTENTS
215 .inttab_tc0_0C3 00000000  802ff860  802ff860  00007358  2**0
                  CONTENTS
216 .inttab_tc0_0C4 00000000  802ff880  802ff880  00007358  2**0
                  CONTENTS
217 .inttab_tc0_0C5 00000000  802ff8a0  802ff8a0  00007358  2**0
                  CONTENTS
218 .inttab_tc0_0C6 00000000  802ff8c0  802ff8c0  00007358  2**0
                  CONTENTS
219 .inttab_tc0_0C7 00000000  802ff8e0  802ff8e0  00007358  2**0
                  CONTENTS
220 .inttab_tc0_0C8 00000000  802ff900  802ff900  00007358  2**0
                  CONTENTS
221 .inttab_tc0_0C9 00000000  802ff920  802ff920  00007358  2**0
                  CONTENTS
222 .inttab_tc0_0CA 00000000  802ff940  802ff940  00007358  2**0
                  CONTENTS
223 .inttab_tc0_0CB 00000000  802ff960  802ff960  00007358  2**0
                  CONTENTS
224 .inttab_tc0_0CC 00000000  802ff980  802ff980  00007358  2**0
                  CONTENTS
225 .inttab_tc0_0CD 00000000  802ff9a0  802ff9a0  00007358  2**0
                  CONTENTS
226 .inttab_tc0_0CE 00000000  802ff9c0  802ff9c0  00007358  2**0
                  CONTENTS
227 .inttab_tc0_0CF 00000000  802ff9e0  802ff9e0  00007358  2**0
                  CONTENTS
228 .inttab_tc0_0D0 00000000  802ffa00  802ffa00  00007358  2**0
                  CONTENTS
229 .inttab_tc0_0D1 00000000  802ffa20  802ffa20  00007358  2**0
                  CONTENTS
230 .inttab_tc0_0D2 00000000  802ffa40  802ffa40  00007358  2**0
                  CONTENTS
231 .inttab_tc0_0D3 00000000  802ffa60  802ffa60  00007358  2**0
                  CONTENTS
232 .inttab_tc0_0D4 00000000  802ffa80  802ffa80  00007358  2**0
                  CONTENTS
233 .inttab_tc0_0D5 00000000  802ffaa0  802ffaa0  00007358  2**0
                  CONTENTS
234 .inttab_tc0_0D6 00000000  802ffac0  802ffac0  00007358  2**0
                  CONTENTS
235 .inttab_tc0_0D7 00000000  802ffae0  802ffae0  00007358  2**0
                  CONTENTS
236 .inttab_tc0_0D8 00000000  802ffb00  802ffb00  00007358  2**0
                  CONTENTS
237 .inttab_tc0_0D9 00000000  802ffb20  802ffb20  00007358  2**0
                  CONTENTS
238 .inttab_tc0_0DA 00000000  802ffb40  802ffb40  00007358  2**0
                  CONTENTS
239 .inttab_tc0_0DB 00000000  802ffb60  802ffb60  00007358  2**0
                  CONTENTS
240 .inttab_tc0_0DC 00000000  802ffb80  802ffb80  00007358  2**0
                  CONTENTS
241 .inttab_tc0_0DD 00000000  802ffba0  802ffba0  00007358  2**0
                  CONTENTS
242 .inttab_tc0_0DE 00000000  802ffbc0  802ffbc0  00007358  2**0
                  CONTENTS
243 .inttab_tc0_0DF 00000000  802ffbe0  802ffbe0  00007358  2**0
                  CONTENTS
244 .inttab_tc0_0E0 00000000  802ffc00  802ffc00  00007358  2**0
                  CONTENTS
245 .inttab_tc0_0E1 00000000  802ffc20  802ffc20  00007358  2**0
                  CONTENTS
246 .inttab_tc0_0E2 00000000  802ffc40  802ffc40  00007358  2**0
                  CONTENTS
247 .inttab_tc0_0E3 00000000  802ffc60  802ffc60  00007358  2**0
                  CONTENTS
248 .inttab_tc0_0E4 00000000  802ffc80  802ffc80  00007358  2**0
                  CONTENTS
249 .inttab_tc0_0E5 00000000  802ffca0  802ffca0  00007358  2**0
                  CONTENTS
250 .inttab_tc0_0E6 00000000  802ffcc0  802ffcc0  00007358  2**0
                  CONTENTS
251 .inttab_tc0_0E7 00000000  802ffce0  802ffce0  00007358  2**0
                  CONTENTS
252 .inttab_tc0_0E8 00000000  802ffd00  802ffd00  00007358  2**0
                  CONTENTS
253 .inttab_tc0_0E9 00000000  802ffd20  802ffd20  00007358  2**0
                  CONTENTS
254 .inttab_tc0_0EA 00000000  802ffd40  802ffd40  00007358  2**0
                  CONTENTS
255 .inttab_tc0_0EB 00000000  802ffd60  802ffd60  00007358  2**0
                  CONTENTS
256 .inttab_tc0_0EC 00000000  802ffd80  802ffd80  00007358  2**0
                  CONTENTS
257 .inttab_tc0_0ED 00000000  802ffda0  802ffda0  00007358  2**0
                  CONTENTS
258 .inttab_tc0_0EE 00000000  802ffdc0  802ffdc0  00007358  2**0
                  CONTENTS
259 .inttab_tc0_0EF 00000000  802ffde0  802ffde0  00007358  2**0
                  CONTENTS
260 .inttab_tc0_0F0 00000000  802ffe00  802ffe00  00007358  2**0
                  CONTENTS
261 .inttab_tc0_0F1 00000000  802ffe20  802ffe20  00007358  2**0
                  CONTENTS
262 .inttab_tc0_0F2 00000000  802ffe40  802ffe40  00007358  2**0
                  CONTENTS
263 .inttab_tc0_0F3 00000000  802ffe60  802ffe60  00007358  2**0
                  CONTENTS
264 .inttab_tc0_0F4 00000000  802ffe80  802ffe80  00007358  2**0
                  CONTENTS
265 .inttab_tc0_0F5 00000000  802ffea0  802ffea0  00007358  2**0
                  CONTENTS
266 .inttab_tc0_0F6 00000000  802ffec0  802ffec0  00007358  2**0
                  CONTENTS
267 .inttab_tc0_0F7 00000000  802ffee0  802ffee0  00007358  2**0
                  CONTENTS
268 .inttab_tc0_0F8 00000000  802fff00  802fff00  00007358  2**0
                  CONTENTS
269 .inttab_tc0_0F9 00000000  802fff20  802fff20  00007358  2**0
                  CONTENTS
270 .inttab_tc0_0FA 00000000  802fff40  802fff40  00007358  2**0
                  CONTENTS
271 .inttab_tc0_0FB 00000000  802fff60  802fff60  00007358  2**0
                  CONTENTS
272 .inttab_tc0_0FC 00000000  802fff80  802fff80  00007358  2**0
                  CONTENTS
273 .inttab_tc0_0FD 00000000  802fffa0  802fffa0  00007358  2**0
                  CONTENTS
274 .inttab_tc0_0FE 00000000  802fffc0  802fffc0  00007358  2**0
                  CONTENTS
275 .inttab_tc0_0FF 00000000  802fffe0  802fffe0  00007358  2**0
                  CONTENTS
276 .inttab_tc1_000 00000000  805fe000  805fe000  00007358  2**0
                  CONTENTS
277 .inttab_tc1_001 00000000  805fe020  805fe020  00007358  2**0
                  CONTENTS
278 .inttab_tc1_002 00000000  805fe040  805fe040  00007358  2**0
                  CONTENTS
279 .inttab_tc1_003 00000000  805fe060  805fe060  00007358  2**0
                  CONTENTS
280 .inttab_tc1_004 00000000  805fe080  805fe080  00007358  2**0
                  CONTENTS
281 .inttab_tc1_005 00000000  805fe0a0  805fe0a0  00007358  2**0
                  CONTENTS
282 .inttab_tc1_006 00000000  805fe0c0  805fe0c0  00007358  2**0
                  CONTENTS
283 .inttab_tc1_007 00000000  805fe0e0  805fe0e0  00007358  2**0
                  CONTENTS
284 .inttab_tc1_008 00000000  805fe100  805fe100  00007358  2**0
                  CONTENTS
285 .inttab_tc1_009 00000000  805fe120  805fe120  00007358  2**0
                  CONTENTS
286 .inttab_tc1_00A 00000000  805fe140  805fe140  00007358  2**0
                  CONTENTS
287 .inttab_tc1_00B 00000000  805fe160  805fe160  00007358  2**0
                  CONTENTS
288 .inttab_tc1_00C 00000000  805fe180  805fe180  00007358  2**0
                  CONTENTS
289 .inttab_tc1_00D 00000000  805fe1a0  805fe1a0  00007358  2**0
                  CONTENTS
290 .inttab_tc1_00E 00000000  805fe1c0  805fe1c0  00007358  2**0
                  CONTENTS
291 .inttab_tc1_00F 00000000  805fe1e0  805fe1e0  00007358  2**0
                  CONTENTS
292 .inttab_tc1_010 00000000  805fe200  805fe200  00007358  2**0
                  CONTENTS
293 .inttab_tc1_011 00000000  805fe220  805fe220  00007358  2**0
                  CONTENTS
294 .inttab_tc1_012 00000000  805fe240  805fe240  00007358  2**0
                  CONTENTS
295 .inttab_tc1_013 00000000  805fe260  805fe260  00007358  2**0
                  CONTENTS
296 .inttab_tc1_014 00000000  805fe280  805fe280  00007358  2**0
                  CONTENTS
297 .inttab_tc1_015 00000000  805fe2a0  805fe2a0  00007358  2**0
                  CONTENTS
298 .inttab_tc1_016 00000000  805fe2c0  805fe2c0  00007358  2**0
                  CONTENTS
299 .inttab_tc1_017 00000000  805fe2e0  805fe2e0  00007358  2**0
                  CONTENTS
300 .inttab_tc1_018 00000000  805fe300  805fe300  00007358  2**0
                  CONTENTS
301 .inttab_tc1_019 00000000  805fe320  805fe320  00007358  2**0
                  CONTENTS
302 .inttab_tc1_01A 00000000  805fe340  805fe340  00007358  2**0
                  CONTENTS
303 .inttab_tc1_01B 00000000  805fe360  805fe360  00007358  2**0
                  CONTENTS
304 .inttab_tc1_01C 00000000  805fe380  805fe380  00007358  2**0
                  CONTENTS
305 .inttab_tc1_01D 00000000  805fe3a0  805fe3a0  00007358  2**0
                  CONTENTS
306 .inttab_tc1_01E 00000000  805fe3c0  805fe3c0  00007358  2**0
                  CONTENTS
307 .inttab_tc1_01F 00000000  805fe3e0  805fe3e0  00007358  2**0
                  CONTENTS
308 .inttab_tc1_020 00000000  805fe400  805fe400  00007358  2**0
                  CONTENTS
309 .inttab_tc1_021 00000000  805fe420  805fe420  00007358  2**0
                  CONTENTS
310 .inttab_tc1_022 00000000  805fe440  805fe440  00007358  2**0
                  CONTENTS
311 .inttab_tc1_023 00000000  805fe460  805fe460  00007358  2**0
                  CONTENTS
312 .inttab_tc1_024 00000000  805fe480  805fe480  00007358  2**0
                  CONTENTS
313 .inttab_tc1_025 00000000  805fe4a0  805fe4a0  00007358  2**0
                  CONTENTS
314 .inttab_tc1_026 00000000  805fe4c0  805fe4c0  00007358  2**0
                  CONTENTS
315 .inttab_tc1_027 00000000  805fe4e0  805fe4e0  00007358  2**0
                  CONTENTS
316 .inttab_tc1_028 00000000  805fe500  805fe500  00007358  2**0
                  CONTENTS
317 .inttab_tc1_029 00000000  805fe520  805fe520  00007358  2**0
                  CONTENTS
318 .inttab_tc1_02A 00000000  805fe540  805fe540  00007358  2**0
                  CONTENTS
319 .inttab_tc1_02B 00000000  805fe560  805fe560  00007358  2**0
                  CONTENTS
320 .inttab_tc1_02C 00000000  805fe580  805fe580  00007358  2**0
                  CONTENTS
321 .inttab_tc1_02D 00000000  805fe5a0  805fe5a0  00007358  2**0
                  CONTENTS
322 .inttab_tc1_02E 00000000  805fe5c0  805fe5c0  00007358  2**0
                  CONTENTS
323 .inttab_tc1_02F 00000000  805fe5e0  805fe5e0  00007358  2**0
                  CONTENTS
324 .inttab_tc1_030 00000000  805fe600  805fe600  00007358  2**0
                  CONTENTS
325 .inttab_tc1_031 00000000  805fe620  805fe620  00007358  2**0
                  CONTENTS
326 .inttab_tc1_032 00000000  805fe640  805fe640  00007358  2**0
                  CONTENTS
327 .inttab_tc1_033 00000000  805fe660  805fe660  00007358  2**0
                  CONTENTS
328 .inttab_tc1_034 00000000  805fe680  805fe680  00007358  2**0
                  CONTENTS
329 .inttab_tc1_035 00000000  805fe6a0  805fe6a0  00007358  2**0
                  CONTENTS
330 .inttab_tc1_036 00000000  805fe6c0  805fe6c0  00007358  2**0
                  CONTENTS
331 .inttab_tc1_037 00000000  805fe6e0  805fe6e0  00007358  2**0
                  CONTENTS
332 .inttab_tc1_038 00000000  805fe700  805fe700  00007358  2**0
                  CONTENTS
333 .inttab_tc1_039 00000000  805fe720  805fe720  00007358  2**0
                  CONTENTS
334 .inttab_tc1_03A 00000000  805fe740  805fe740  00007358  2**0
                  CONTENTS
335 .inttab_tc1_03B 00000000  805fe760  805fe760  00007358  2**0
                  CONTENTS
336 .inttab_tc1_03C 00000000  805fe780  805fe780  00007358  2**0
                  CONTENTS
337 .inttab_tc1_03D 00000000  805fe7a0  805fe7a0  00007358  2**0
                  CONTENTS
338 .inttab_tc1_03E 00000000  805fe7c0  805fe7c0  00007358  2**0
                  CONTENTS
339 .inttab_tc1_03F 00000000  805fe7e0  805fe7e0  00007358  2**0
                  CONTENTS
340 .inttab_tc1_040 00000000  805fe800  805fe800  00007358  2**0
                  CONTENTS
341 .inttab_tc1_041 00000000  805fe820  805fe820  00007358  2**0
                  CONTENTS
342 .inttab_tc1_042 00000000  805fe840  805fe840  00007358  2**0
                  CONTENTS
343 .inttab_tc1_043 00000000  805fe860  805fe860  00007358  2**0
                  CONTENTS
344 .inttab_tc1_044 00000000  805fe880  805fe880  00007358  2**0
                  CONTENTS
345 .inttab_tc1_045 00000000  805fe8a0  805fe8a0  00007358  2**0
                  CONTENTS
346 .inttab_tc1_046 00000000  805fe8c0  805fe8c0  00007358  2**0
                  CONTENTS
347 .inttab_tc1_047 00000000  805fe8e0  805fe8e0  00007358  2**0
                  CONTENTS
348 .inttab_tc1_048 00000000  805fe900  805fe900  00007358  2**0
                  CONTENTS
349 .inttab_tc1_049 00000000  805fe920  805fe920  00007358  2**0
                  CONTENTS
350 .inttab_tc1_04A 00000000  805fe940  805fe940  00007358  2**0
                  CONTENTS
351 .inttab_tc1_04B 00000000  805fe960  805fe960  00007358  2**0
                  CONTENTS
352 .inttab_tc1_04C 00000000  805fe980  805fe980  00007358  2**0
                  CONTENTS
353 .inttab_tc1_04D 00000000  805fe9a0  805fe9a0  00007358  2**0
                  CONTENTS
354 .inttab_tc1_04E 00000000  805fe9c0  805fe9c0  00007358  2**0
                  CONTENTS
355 .inttab_tc1_04F 00000000  805fe9e0  805fe9e0  00007358  2**0
                  CONTENTS
356 .inttab_tc1_050 00000000  805fea00  805fea00  00007358  2**0
                  CONTENTS
357 .inttab_tc1_051 00000000  805fea20  805fea20  00007358  2**0
                  CONTENTS
358 .inttab_tc1_052 00000000  805fea40  805fea40  00007358  2**0
                  CONTENTS
359 .inttab_tc1_053 00000000  805fea60  805fea60  00007358  2**0
                  CONTENTS
360 .inttab_tc1_054 00000000  805fea80  805fea80  00007358  2**0
                  CONTENTS
361 .inttab_tc1_055 00000000  805feaa0  805feaa0  00007358  2**0
                  CONTENTS
362 .inttab_tc1_056 00000000  805feac0  805feac0  00007358  2**0
                  CONTENTS
363 .inttab_tc1_057 00000000  805feae0  805feae0  00007358  2**0
                  CONTENTS
364 .inttab_tc1_058 00000000  805feb00  805feb00  00007358  2**0
                  CONTENTS
365 .inttab_tc1_059 00000000  805feb20  805feb20  00007358  2**0
                  CONTENTS
366 .inttab_tc1_05A 00000000  805feb40  805feb40  00007358  2**0
                  CONTENTS
367 .inttab_tc1_05B 00000000  805feb60  805feb60  00007358  2**0
                  CONTENTS
368 .inttab_tc1_05C 00000000  805feb80  805feb80  00007358  2**0
                  CONTENTS
369 .inttab_tc1_05D 00000000  805feba0  805feba0  00007358  2**0
                  CONTENTS
370 .inttab_tc1_05E 00000000  805febc0  805febc0  00007358  2**0
                  CONTENTS
371 .inttab_tc1_05F 00000000  805febe0  805febe0  00007358  2**0
                  CONTENTS
372 .inttab_tc1_060 00000000  805fec00  805fec00  00007358  2**0
                  CONTENTS
373 .inttab_tc1_061 00000000  805fec20  805fec20  00007358  2**0
                  CONTENTS
374 .inttab_tc1_062 00000000  805fec40  805fec40  00007358  2**0
                  CONTENTS
375 .inttab_tc1_063 00000000  805fec60  805fec60  00007358  2**0
                  CONTENTS
376 .inttab_tc1_064 00000000  805fec80  805fec80  00007358  2**0
                  CONTENTS
377 .inttab_tc1_065 00000000  805feca0  805feca0  00007358  2**0
                  CONTENTS
378 .inttab_tc1_066 00000000  805fecc0  805fecc0  00007358  2**0
                  CONTENTS
379 .inttab_tc1_067 00000000  805fece0  805fece0  00007358  2**0
                  CONTENTS
380 .inttab_tc1_068 00000000  805fed00  805fed00  00007358  2**0
                  CONTENTS
381 .inttab_tc1_069 00000000  805fed20  805fed20  00007358  2**0
                  CONTENTS
382 .inttab_tc1_06A 00000000  805fed40  805fed40  00007358  2**0
                  CONTENTS
383 .inttab_tc1_06B 00000000  805fed60  805fed60  00007358  2**0
                  CONTENTS
384 .inttab_tc1_06C 00000000  805fed80  805fed80  00007358  2**0
                  CONTENTS
385 .inttab_tc1_06D 00000000  805feda0  805feda0  00007358  2**0
                  CONTENTS
386 .inttab_tc1_06E 00000000  805fedc0  805fedc0  00007358  2**0
                  CONTENTS
387 .inttab_tc1_06F 00000000  805fede0  805fede0  00007358  2**0
                  CONTENTS
388 .inttab_tc1_070 00000000  805fee00  805fee00  00007358  2**0
                  CONTENTS
389 .inttab_tc1_071 00000000  805fee20  805fee20  00007358  2**0
                  CONTENTS
390 .inttab_tc1_072 00000000  805fee40  805fee40  00007358  2**0
                  CONTENTS
391 .inttab_tc1_073 00000000  805fee60  805fee60  00007358  2**0
                  CONTENTS
392 .inttab_tc1_074 00000000  805fee80  805fee80  00007358  2**0
                  CONTENTS
393 .inttab_tc1_075 00000000  805feea0  805feea0  00007358  2**0
                  CONTENTS
394 .inttab_tc1_076 00000000  805feec0  805feec0  00007358  2**0
                  CONTENTS
395 .inttab_tc1_077 00000000  805feee0  805feee0  00007358  2**0
                  CONTENTS
396 .inttab_tc1_078 00000000  805fef00  805fef00  00007358  2**0
                  CONTENTS
397 .inttab_tc1_079 00000000  805fef20  805fef20  00007358  2**0
                  CONTENTS
398 .inttab_tc1_07A 00000000  805fef40  805fef40  00007358  2**0
                  CONTENTS
399 .inttab_tc1_07B 00000000  805fef60  805fef60  00007358  2**0
                  CONTENTS
400 .inttab_tc1_07C 00000000  805fef80  805fef80  00007358  2**0
                  CONTENTS
401 .inttab_tc1_07D 00000000  805fefa0  805fefa0  00007358  2**0
                  CONTENTS
402 .inttab_tc1_07E 00000000  805fefc0  805fefc0  00007358  2**0
                  CONTENTS
403 .inttab_tc1_07F 00000000  805fefe0  805fefe0  00007358  2**0
                  CONTENTS
404 .inttab_tc1_080 00000000  805ff000  805ff000  00007358  2**0
                  CONTENTS
405 .inttab_tc1_081 00000000  805ff020  805ff020  00007358  2**0
                  CONTENTS
406 .inttab_tc1_082 00000000  805ff040  805ff040  00007358  2**0
                  CONTENTS
407 .inttab_tc1_083 00000000  805ff060  805ff060  00007358  2**0
                  CONTENTS
408 .inttab_tc1_084 00000000  805ff080  805ff080  00007358  2**0
                  CONTENTS
409 .inttab_tc1_085 00000000  805ff0a0  805ff0a0  00007358  2**0
                  CONTENTS
410 .inttab_tc1_086 00000000  805ff0c0  805ff0c0  00007358  2**0
                  CONTENTS
411 .inttab_tc1_087 00000000  805ff0e0  805ff0e0  00007358  2**0
                  CONTENTS
412 .inttab_tc1_088 00000000  805ff100  805ff100  00007358  2**0
                  CONTENTS
413 .inttab_tc1_089 00000000  805ff120  805ff120  00007358  2**0
                  CONTENTS
414 .inttab_tc1_08A 00000000  805ff140  805ff140  00007358  2**0
                  CONTENTS
415 .inttab_tc1_08B 00000000  805ff160  805ff160  00007358  2**0
                  CONTENTS
416 .inttab_tc1_08C 00000000  805ff180  805ff180  00007358  2**0
                  CONTENTS
417 .inttab_tc1_08D 00000000  805ff1a0  805ff1a0  00007358  2**0
                  CONTENTS
418 .inttab_tc1_08E 00000000  805ff1c0  805ff1c0  00007358  2**0
                  CONTENTS
419 .inttab_tc1_08F 00000000  805ff1e0  805ff1e0  00007358  2**0
                  CONTENTS
420 .inttab_tc1_090 00000000  805ff200  805ff200  00007358  2**0
                  CONTENTS
421 .inttab_tc1_091 00000000  805ff220  805ff220  00007358  2**0
                  CONTENTS
422 .inttab_tc1_092 00000000  805ff240  805ff240  00007358  2**0
                  CONTENTS
423 .inttab_tc1_093 00000000  805ff260  805ff260  00007358  2**0
                  CONTENTS
424 .inttab_tc1_094 00000000  805ff280  805ff280  00007358  2**0
                  CONTENTS
425 .inttab_tc1_095 00000000  805ff2a0  805ff2a0  00007358  2**0
                  CONTENTS
426 .inttab_tc1_096 00000000  805ff2c0  805ff2c0  00007358  2**0
                  CONTENTS
427 .inttab_tc1_097 00000000  805ff2e0  805ff2e0  00007358  2**0
                  CONTENTS
428 .inttab_tc1_098 00000000  805ff300  805ff300  00007358  2**0
                  CONTENTS
429 .inttab_tc1_099 00000000  805ff320  805ff320  00007358  2**0
                  CONTENTS
430 .inttab_tc1_09A 00000000  805ff340  805ff340  00007358  2**0
                  CONTENTS
431 .inttab_tc1_09B 00000000  805ff360  805ff360  00007358  2**0
                  CONTENTS
432 .inttab_tc1_09C 00000000  805ff380  805ff380  00007358  2**0
                  CONTENTS
433 .inttab_tc1_09D 00000000  805ff3a0  805ff3a0  00007358  2**0
                  CONTENTS
434 .inttab_tc1_09E 00000000  805ff3c0  805ff3c0  00007358  2**0
                  CONTENTS
435 .inttab_tc1_09F 00000000  805ff3e0  805ff3e0  00007358  2**0
                  CONTENTS
436 .inttab_tc1_0A0 00000000  805ff400  805ff400  00007358  2**0
                  CONTENTS
437 .inttab_tc1_0A1 00000000  805ff420  805ff420  00007358  2**0
                  CONTENTS
438 .inttab_tc1_0A2 00000000  805ff440  805ff440  00007358  2**0
                  CONTENTS
439 .inttab_tc1_0A3 00000000  805ff460  805ff460  00007358  2**0
                  CONTENTS
440 .inttab_tc1_0A4 00000000  805ff480  805ff480  00007358  2**0
                  CONTENTS
441 .inttab_tc1_0A5 00000000  805ff4a0  805ff4a0  00007358  2**0
                  CONTENTS
442 .inttab_tc1_0A6 00000000  805ff4c0  805ff4c0  00007358  2**0
                  CONTENTS
443 .inttab_tc1_0A7 00000000  805ff4e0  805ff4e0  00007358  2**0
                  CONTENTS
444 .inttab_tc1_0A8 00000000  805ff500  805ff500  00007358  2**0
                  CONTENTS
445 .inttab_tc1_0A9 00000000  805ff520  805ff520  00007358  2**0
                  CONTENTS
446 .inttab_tc1_0AA 00000000  805ff540  805ff540  00007358  2**0
                  CONTENTS
447 .inttab_tc1_0AB 00000000  805ff560  805ff560  00007358  2**0
                  CONTENTS
448 .inttab_tc1_0AC 00000000  805ff580  805ff580  00007358  2**0
                  CONTENTS
449 .inttab_tc1_0AD 00000000  805ff5a0  805ff5a0  00007358  2**0
                  CONTENTS
450 .inttab_tc1_0AE 00000000  805ff5c0  805ff5c0  00007358  2**0
                  CONTENTS
451 .inttab_tc1_0AF 00000000  805ff5e0  805ff5e0  00007358  2**0
                  CONTENTS
452 .inttab_tc1_0B0 00000000  805ff600  805ff600  00007358  2**0
                  CONTENTS
453 .inttab_tc1_0B1 00000000  805ff620  805ff620  00007358  2**0
                  CONTENTS
454 .inttab_tc1_0B2 00000000  805ff640  805ff640  00007358  2**0
                  CONTENTS
455 .inttab_tc1_0B3 00000000  805ff660  805ff660  00007358  2**0
                  CONTENTS
456 .inttab_tc1_0B4 00000000  805ff680  805ff680  00007358  2**0
                  CONTENTS
457 .inttab_tc1_0B5 00000000  805ff6a0  805ff6a0  00007358  2**0
                  CONTENTS
458 .inttab_tc1_0B6 00000000  805ff6c0  805ff6c0  00007358  2**0
                  CONTENTS
459 .inttab_tc1_0B7 00000000  805ff6e0  805ff6e0  00007358  2**0
                  CONTENTS
460 .inttab_tc1_0B8 00000000  805ff700  805ff700  00007358  2**0
                  CONTENTS
461 .inttab_tc1_0B9 00000000  805ff720  805ff720  00007358  2**0
                  CONTENTS
462 .inttab_tc1_0BA 00000000  805ff740  805ff740  00007358  2**0
                  CONTENTS
463 .inttab_tc1_0BB 00000000  805ff760  805ff760  00007358  2**0
                  CONTENTS
464 .inttab_tc1_0BC 00000000  805ff780  805ff780  00007358  2**0
                  CONTENTS
465 .inttab_tc1_0BD 00000000  805ff7a0  805ff7a0  00007358  2**0
                  CONTENTS
466 .inttab_tc1_0BE 00000000  805ff7c0  805ff7c0  00007358  2**0
                  CONTENTS
467 .inttab_tc1_0BF 00000000  805ff7e0  805ff7e0  00007358  2**0
                  CONTENTS
468 .inttab_tc1_0C0 00000000  805ff800  805ff800  00007358  2**0
                  CONTENTS
469 .inttab_tc1_0C1 00000000  805ff820  805ff820  00007358  2**0
                  CONTENTS
470 .inttab_tc1_0C2 00000000  805ff840  805ff840  00007358  2**0
                  CONTENTS
471 .inttab_tc1_0C3 00000000  805ff860  805ff860  00007358  2**0
                  CONTENTS
472 .inttab_tc1_0C4 00000000  805ff880  805ff880  00007358  2**0
                  CONTENTS
473 .inttab_tc1_0C5 00000000  805ff8a0  805ff8a0  00007358  2**0
                  CONTENTS
474 .inttab_tc1_0C6 00000000  805ff8c0  805ff8c0  00007358  2**0
                  CONTENTS
475 .inttab_tc1_0C7 00000000  805ff8e0  805ff8e0  00007358  2**0
                  CONTENTS
476 .inttab_tc1_0C8 00000000  805ff900  805ff900  00007358  2**0
                  CONTENTS
477 .inttab_tc1_0C9 00000000  805ff920  805ff920  00007358  2**0
                  CONTENTS
478 .inttab_tc1_0CA 00000000  805ff940  805ff940  00007358  2**0
                  CONTENTS
479 .inttab_tc1_0CB 00000000  805ff960  805ff960  00007358  2**0
                  CONTENTS
480 .inttab_tc1_0CC 00000000  805ff980  805ff980  00007358  2**0
                  CONTENTS
481 .inttab_tc1_0CD 00000000  805ff9a0  805ff9a0  00007358  2**0
                  CONTENTS
482 .inttab_tc1_0CE 00000000  805ff9c0  805ff9c0  00007358  2**0
                  CONTENTS
483 .inttab_tc1_0CF 00000000  805ff9e0  805ff9e0  00007358  2**0
                  CONTENTS
484 .inttab_tc1_0D0 00000000  805ffa00  805ffa00  00007358  2**0
                  CONTENTS
485 .inttab_tc1_0D1 00000000  805ffa20  805ffa20  00007358  2**0
                  CONTENTS
486 .inttab_tc1_0D2 00000000  805ffa40  805ffa40  00007358  2**0
                  CONTENTS
487 .inttab_tc1_0D3 00000000  805ffa60  805ffa60  00007358  2**0
                  CONTENTS
488 .inttab_tc1_0D4 00000000  805ffa80  805ffa80  00007358  2**0
                  CONTENTS
489 .inttab_tc1_0D5 00000000  805ffaa0  805ffaa0  00007358  2**0
                  CONTENTS
490 .inttab_tc1_0D6 00000000  805ffac0  805ffac0  00007358  2**0
                  CONTENTS
491 .inttab_tc1_0D7 00000000  805ffae0  805ffae0  00007358  2**0
                  CONTENTS
492 .inttab_tc1_0D8 00000000  805ffb00  805ffb00  00007358  2**0
                  CONTENTS
493 .inttab_tc1_0D9 00000000  805ffb20  805ffb20  00007358  2**0
                  CONTENTS
494 .inttab_tc1_0DA 00000000  805ffb40  805ffb40  00007358  2**0
                  CONTENTS
495 .inttab_tc1_0DB 00000000  805ffb60  805ffb60  00007358  2**0
                  CONTENTS
496 .inttab_tc1_0DC 00000000  805ffb80  805ffb80  00007358  2**0
                  CONTENTS
497 .inttab_tc1_0DD 00000000  805ffba0  805ffba0  00007358  2**0
                  CONTENTS
498 .inttab_tc1_0DE 00000000  805ffbc0  805ffbc0  00007358  2**0
                  CONTENTS
499 .inttab_tc1_0DF 00000000  805ffbe0  805ffbe0  00007358  2**0
                  CONTENTS
500 .inttab_tc1_0E0 00000000  805ffc00  805ffc00  00007358  2**0
                  CONTENTS
501 .inttab_tc1_0E1 00000000  805ffc20  805ffc20  00007358  2**0
                  CONTENTS
502 .inttab_tc1_0E2 00000000  805ffc40  805ffc40  00007358  2**0
                  CONTENTS
503 .inttab_tc1_0E3 00000000  805ffc60  805ffc60  00007358  2**0
                  CONTENTS
504 .inttab_tc1_0E4 00000000  805ffc80  805ffc80  00007358  2**0
                  CONTENTS
505 .inttab_tc1_0E5 00000000  805ffca0  805ffca0  00007358  2**0
                  CONTENTS
506 .inttab_tc1_0E6 00000000  805ffcc0  805ffcc0  00007358  2**0
                  CONTENTS
507 .inttab_tc1_0E7 00000000  805ffce0  805ffce0  00007358  2**0
                  CONTENTS
508 .inttab_tc1_0E8 00000000  805ffd00  805ffd00  00007358  2**0
                  CONTENTS
509 .inttab_tc1_0E9 00000000  805ffd20  805ffd20  00007358  2**0
                  CONTENTS
510 .inttab_tc1_0EA 00000000  805ffd40  805ffd40  00007358  2**0
                  CONTENTS
511 .inttab_tc1_0EB 00000000  805ffd60  805ffd60  00007358  2**0
                  CONTENTS
512 .inttab_tc1_0EC 00000000  805ffd80  805ffd80  00007358  2**0
                  CONTENTS
513 .inttab_tc1_0ED 00000000  805ffda0  805ffda0  00007358  2**0
                  CONTENTS
514 .inttab_tc1_0EE 00000000  805ffdc0  805ffdc0  00007358  2**0
                  CONTENTS
515 .inttab_tc1_0EF 00000000  805ffde0  805ffde0  00007358  2**0
                  CONTENTS
516 .inttab_tc1_0F0 00000000  805ffe00  805ffe00  00007358  2**0
                  CONTENTS
517 .inttab_tc1_0F1 00000000  805ffe20  805ffe20  00007358  2**0
                  CONTENTS
518 .inttab_tc1_0F2 00000000  805ffe40  805ffe40  00007358  2**0
                  CONTENTS
519 .inttab_tc1_0F3 00000000  805ffe60  805ffe60  00007358  2**0
                  CONTENTS
520 .inttab_tc1_0F4 00000000  805ffe80  805ffe80  00007358  2**0
                  CONTENTS
521 .inttab_tc1_0F5 00000000  805ffea0  805ffea0  00007358  2**0
                  CONTENTS
522 .inttab_tc1_0F6 00000000  805ffec0  805ffec0  00007358  2**0
                  CONTENTS
523 .inttab_tc1_0F7 00000000  805ffee0  805ffee0  00007358  2**0
                  CONTENTS
524 .inttab_tc1_0F8 00000000  805fff00  805fff00  00007358  2**0
                  CONTENTS
525 .inttab_tc1_0F9 00000000  805fff20  805fff20  00007358  2**0
                  CONTENTS
526 .inttab_tc1_0FA 00000000  805fff40  805fff40  00007358  2**0
                  CONTENTS
527 .inttab_tc1_0FB 00000000  805fff60  805fff60  00007358  2**0
                  CONTENTS
528 .inttab_tc1_0FC 00000000  805fff80  805fff80  00007358  2**0
                  CONTENTS
529 .inttab_tc1_0FD 00000000  805fffa0  805fffa0  00007358  2**0
                  CONTENTS
530 .inttab_tc1_0FE 00000000  805fffc0  805fffc0  00007358  2**0
                  CONTENTS
531 .inttab_tc1_0FF 00000000  805fffe0  805fffe0  00007358  2**0
                  CONTENTS
532 .inttab_tc2_000 00000000  808fe000  808fe000  00007358  2**0
                  CONTENTS
533 .inttab_tc2_001 00000000  808fe020  808fe020  00007358  2**0
                  CONTENTS
534 .inttab_tc2_002 00000000  808fe040  808fe040  00007358  2**0
                  CONTENTS
535 .inttab_tc2_003 00000000  808fe060  808fe060  00007358  2**0
                  CONTENTS
536 .inttab_tc2_004 00000000  808fe080  808fe080  00007358  2**0
                  CONTENTS
537 .inttab_tc2_005 00000000  808fe0a0  808fe0a0  00007358  2**0
                  CONTENTS
538 .inttab_tc2_006 00000000  808fe0c0  808fe0c0  00007358  2**0
                  CONTENTS
539 .inttab_tc2_007 00000000  808fe0e0  808fe0e0  00007358  2**0
                  CONTENTS
540 .inttab_tc2_008 00000000  808fe100  808fe100  00007358  2**0
                  CONTENTS
541 .inttab_tc2_009 00000000  808fe120  808fe120  00007358  2**0
                  CONTENTS
542 .inttab_tc2_00A 00000000  808fe140  808fe140  00007358  2**0
                  CONTENTS
543 .inttab_tc2_00B 00000000  808fe160  808fe160  00007358  2**0
                  CONTENTS
544 .inttab_tc2_00C 00000000  808fe180  808fe180  00007358  2**0
                  CONTENTS
545 .inttab_tc2_00D 00000000  808fe1a0  808fe1a0  00007358  2**0
                  CONTENTS
546 .inttab_tc2_00E 00000000  808fe1c0  808fe1c0  00007358  2**0
                  CONTENTS
547 .inttab_tc2_00F 00000000  808fe1e0  808fe1e0  00007358  2**0
                  CONTENTS
548 .inttab_tc2_010 00000000  808fe200  808fe200  00007358  2**0
                  CONTENTS
549 .inttab_tc2_011 00000000  808fe220  808fe220  00007358  2**0
                  CONTENTS
550 .inttab_tc2_012 00000000  808fe240  808fe240  00007358  2**0
                  CONTENTS
551 .inttab_tc2_013 00000000  808fe260  808fe260  00007358  2**0
                  CONTENTS
552 .inttab_tc2_014 00000000  808fe280  808fe280  00007358  2**0
                  CONTENTS
553 .inttab_tc2_015 00000000  808fe2a0  808fe2a0  00007358  2**0
                  CONTENTS
554 .inttab_tc2_016 00000000  808fe2c0  808fe2c0  00007358  2**0
                  CONTENTS
555 .inttab_tc2_017 00000000  808fe2e0  808fe2e0  00007358  2**0
                  CONTENTS
556 .inttab_tc2_018 00000000  808fe300  808fe300  00007358  2**0
                  CONTENTS
557 .inttab_tc2_019 00000000  808fe320  808fe320  00007358  2**0
                  CONTENTS
558 .inttab_tc2_01A 00000000  808fe340  808fe340  00007358  2**0
                  CONTENTS
559 .inttab_tc2_01B 00000000  808fe360  808fe360  00007358  2**0
                  CONTENTS
560 .inttab_tc2_01C 00000000  808fe380  808fe380  00007358  2**0
                  CONTENTS
561 .inttab_tc2_01D 00000000  808fe3a0  808fe3a0  00007358  2**0
                  CONTENTS
562 .inttab_tc2_01E 00000000  808fe3c0  808fe3c0  00007358  2**0
                  CONTENTS
563 .inttab_tc2_01F 00000000  808fe3e0  808fe3e0  00007358  2**0
                  CONTENTS
564 .inttab_tc2_020 00000000  808fe400  808fe400  00007358  2**0
                  CONTENTS
565 .inttab_tc2_021 00000000  808fe420  808fe420  00007358  2**0
                  CONTENTS
566 .inttab_tc2_022 00000000  808fe440  808fe440  00007358  2**0
                  CONTENTS
567 .inttab_tc2_023 00000000  808fe460  808fe460  00007358  2**0
                  CONTENTS
568 .inttab_tc2_024 00000000  808fe480  808fe480  00007358  2**0
                  CONTENTS
569 .inttab_tc2_025 00000000  808fe4a0  808fe4a0  00007358  2**0
                  CONTENTS
570 .inttab_tc2_026 00000000  808fe4c0  808fe4c0  00007358  2**0
                  CONTENTS
571 .inttab_tc2_027 00000000  808fe4e0  808fe4e0  00007358  2**0
                  CONTENTS
572 .inttab_tc2_028 00000000  808fe500  808fe500  00007358  2**0
                  CONTENTS
573 .inttab_tc2_029 00000000  808fe520  808fe520  00007358  2**0
                  CONTENTS
574 .inttab_tc2_02A 00000000  808fe540  808fe540  00007358  2**0
                  CONTENTS
575 .inttab_tc2_02B 00000000  808fe560  808fe560  00007358  2**0
                  CONTENTS
576 .inttab_tc2_02C 00000000  808fe580  808fe580  00007358  2**0
                  CONTENTS
577 .inttab_tc2_02D 00000000  808fe5a0  808fe5a0  00007358  2**0
                  CONTENTS
578 .inttab_tc2_02E 00000000  808fe5c0  808fe5c0  00007358  2**0
                  CONTENTS
579 .inttab_tc2_02F 00000000  808fe5e0  808fe5e0  00007358  2**0
                  CONTENTS
580 .inttab_tc2_030 00000000  808fe600  808fe600  00007358  2**0
                  CONTENTS
581 .inttab_tc2_031 00000000  808fe620  808fe620  00007358  2**0
                  CONTENTS
582 .inttab_tc2_032 00000000  808fe640  808fe640  00007358  2**0
                  CONTENTS
583 .inttab_tc2_033 00000000  808fe660  808fe660  00007358  2**0
                  CONTENTS
584 .inttab_tc2_034 00000000  808fe680  808fe680  00007358  2**0
                  CONTENTS
585 .inttab_tc2_035 00000000  808fe6a0  808fe6a0  00007358  2**0
                  CONTENTS
586 .inttab_tc2_036 00000000  808fe6c0  808fe6c0  00007358  2**0
                  CONTENTS
587 .inttab_tc2_037 00000000  808fe6e0  808fe6e0  00007358  2**0
                  CONTENTS
588 .inttab_tc2_038 00000000  808fe700  808fe700  00007358  2**0
                  CONTENTS
589 .inttab_tc2_039 00000000  808fe720  808fe720  00007358  2**0
                  CONTENTS
590 .inttab_tc2_03A 00000000  808fe740  808fe740  00007358  2**0
                  CONTENTS
591 .inttab_tc2_03B 00000000  808fe760  808fe760  00007358  2**0
                  CONTENTS
592 .inttab_tc2_03C 00000000  808fe780  808fe780  00007358  2**0
                  CONTENTS
593 .inttab_tc2_03D 00000000  808fe7a0  808fe7a0  00007358  2**0
                  CONTENTS
594 .inttab_tc2_03E 00000000  808fe7c0  808fe7c0  00007358  2**0
                  CONTENTS
595 .inttab_tc2_03F 00000000  808fe7e0  808fe7e0  00007358  2**0
                  CONTENTS
596 .inttab_tc2_040 00000000  808fe800  808fe800  00007358  2**0
                  CONTENTS
597 .inttab_tc2_041 00000000  808fe820  808fe820  00007358  2**0
                  CONTENTS
598 .inttab_tc2_042 00000000  808fe840  808fe840  00007358  2**0
                  CONTENTS
599 .inttab_tc2_043 00000000  808fe860  808fe860  00007358  2**0
                  CONTENTS
600 .inttab_tc2_044 00000000  808fe880  808fe880  00007358  2**0
                  CONTENTS
601 .inttab_tc2_045 00000000  808fe8a0  808fe8a0  00007358  2**0
                  CONTENTS
602 .inttab_tc2_046 00000000  808fe8c0  808fe8c0  00007358  2**0
                  CONTENTS
603 .inttab_tc2_047 00000000  808fe8e0  808fe8e0  00007358  2**0
                  CONTENTS
604 .inttab_tc2_048 00000000  808fe900  808fe900  00007358  2**0
                  CONTENTS
605 .inttab_tc2_049 00000000  808fe920  808fe920  00007358  2**0
                  CONTENTS
606 .inttab_tc2_04A 00000000  808fe940  808fe940  00007358  2**0
                  CONTENTS
607 .inttab_tc2_04B 00000000  808fe960  808fe960  00007358  2**0
                  CONTENTS
608 .inttab_tc2_04C 00000000  808fe980  808fe980  00007358  2**0
                  CONTENTS
609 .inttab_tc2_04D 00000000  808fe9a0  808fe9a0  00007358  2**0
                  CONTENTS
610 .inttab_tc2_04E 00000000  808fe9c0  808fe9c0  00007358  2**0
                  CONTENTS
611 .inttab_tc2_04F 00000000  808fe9e0  808fe9e0  00007358  2**0
                  CONTENTS
612 .inttab_tc2_050 00000000  808fea00  808fea00  00007358  2**0
                  CONTENTS
613 .inttab_tc2_051 00000000  808fea20  808fea20  00007358  2**0
                  CONTENTS
614 .inttab_tc2_052 00000000  808fea40  808fea40  00007358  2**0
                  CONTENTS
615 .inttab_tc2_053 00000000  808fea60  808fea60  00007358  2**0
                  CONTENTS
616 .inttab_tc2_054 00000000  808fea80  808fea80  00007358  2**0
                  CONTENTS
617 .inttab_tc2_055 00000000  808feaa0  808feaa0  00007358  2**0
                  CONTENTS
618 .inttab_tc2_056 00000000  808feac0  808feac0  00007358  2**0
                  CONTENTS
619 .inttab_tc2_057 00000000  808feae0  808feae0  00007358  2**0
                  CONTENTS
620 .inttab_tc2_058 00000000  808feb00  808feb00  00007358  2**0
                  CONTENTS
621 .inttab_tc2_059 00000000  808feb20  808feb20  00007358  2**0
                  CONTENTS
622 .inttab_tc2_05A 00000000  808feb40  808feb40  00007358  2**0
                  CONTENTS
623 .inttab_tc2_05B 00000000  808feb60  808feb60  00007358  2**0
                  CONTENTS
624 .inttab_tc2_05C 00000000  808feb80  808feb80  00007358  2**0
                  CONTENTS
625 .inttab_tc2_05D 00000000  808feba0  808feba0  00007358  2**0
                  CONTENTS
626 .inttab_tc2_05E 00000000  808febc0  808febc0  00007358  2**0
                  CONTENTS
627 .inttab_tc2_05F 00000000  808febe0  808febe0  00007358  2**0
                  CONTENTS
628 .inttab_tc2_060 00000000  808fec00  808fec00  00007358  2**0
                  CONTENTS
629 .inttab_tc2_061 00000000  808fec20  808fec20  00007358  2**0
                  CONTENTS
630 .inttab_tc2_062 00000000  808fec40  808fec40  00007358  2**0
                  CONTENTS
631 .inttab_tc2_063 00000000  808fec60  808fec60  00007358  2**0
                  CONTENTS
632 .inttab_tc2_064 00000000  808fec80  808fec80  00007358  2**0
                  CONTENTS
633 .inttab_tc2_065 00000000  808feca0  808feca0  00007358  2**0
                  CONTENTS
634 .inttab_tc2_066 00000000  808fecc0  808fecc0  00007358  2**0
                  CONTENTS
635 .inttab_tc2_067 00000000  808fece0  808fece0  00007358  2**0
                  CONTENTS
636 .inttab_tc2_068 00000000  808fed00  808fed00  00007358  2**0
                  CONTENTS
637 .inttab_tc2_069 00000000  808fed20  808fed20  00007358  2**0
                  CONTENTS
638 .inttab_tc2_06A 00000000  808fed40  808fed40  00007358  2**0
                  CONTENTS
639 .inttab_tc2_06B 00000000  808fed60  808fed60  00007358  2**0
                  CONTENTS
640 .inttab_tc2_06C 00000000  808fed80  808fed80  00007358  2**0
                  CONTENTS
641 .inttab_tc2_06D 00000000  808feda0  808feda0  00007358  2**0
                  CONTENTS
642 .inttab_tc2_06E 00000000  808fedc0  808fedc0  00007358  2**0
                  CONTENTS
643 .inttab_tc2_06F 00000000  808fede0  808fede0  00007358  2**0
                  CONTENTS
644 .inttab_tc2_070 00000000  808fee00  808fee00  00007358  2**0
                  CONTENTS
645 .inttab_tc2_071 00000000  808fee20  808fee20  00007358  2**0
                  CONTENTS
646 .inttab_tc2_072 00000000  808fee40  808fee40  00007358  2**0
                  CONTENTS
647 .inttab_tc2_073 00000000  808fee60  808fee60  00007358  2**0
                  CONTENTS
648 .inttab_tc2_074 00000000  808fee80  808fee80  00007358  2**0
                  CONTENTS
649 .inttab_tc2_075 00000000  808feea0  808feea0  00007358  2**0
                  CONTENTS
650 .inttab_tc2_076 00000000  808feec0  808feec0  00007358  2**0
                  CONTENTS
651 .inttab_tc2_077 00000000  808feee0  808feee0  00007358  2**0
                  CONTENTS
652 .inttab_tc2_078 00000000  808fef00  808fef00  00007358  2**0
                  CONTENTS
653 .inttab_tc2_079 00000000  808fef20  808fef20  00007358  2**0
                  CONTENTS
654 .inttab_tc2_07A 00000000  808fef40  808fef40  00007358  2**0
                  CONTENTS
655 .inttab_tc2_07B 00000000  808fef60  808fef60  00007358  2**0
                  CONTENTS
656 .inttab_tc2_07C 00000000  808fef80  808fef80  00007358  2**0
                  CONTENTS
657 .inttab_tc2_07D 00000000  808fefa0  808fefa0  00007358  2**0
                  CONTENTS
658 .inttab_tc2_07E 00000000  808fefc0  808fefc0  00007358  2**0
                  CONTENTS
659 .inttab_tc2_07F 00000000  808fefe0  808fefe0  00007358  2**0
                  CONTENTS
660 .inttab_tc2_080 00000000  808ff000  808ff000  00007358  2**0
                  CONTENTS
661 .inttab_tc2_081 00000000  808ff020  808ff020  00007358  2**0
                  CONTENTS
662 .inttab_tc2_082 00000000  808ff040  808ff040  00007358  2**0
                  CONTENTS
663 .inttab_tc2_083 00000000  808ff060  808ff060  00007358  2**0
                  CONTENTS
664 .inttab_tc2_084 00000000  808ff080  808ff080  00007358  2**0
                  CONTENTS
665 .inttab_tc2_085 00000000  808ff0a0  808ff0a0  00007358  2**0
                  CONTENTS
666 .inttab_tc2_086 00000000  808ff0c0  808ff0c0  00007358  2**0
                  CONTENTS
667 .inttab_tc2_087 00000000  808ff0e0  808ff0e0  00007358  2**0
                  CONTENTS
668 .inttab_tc2_088 00000000  808ff100  808ff100  00007358  2**0
                  CONTENTS
669 .inttab_tc2_089 00000000  808ff120  808ff120  00007358  2**0
                  CONTENTS
670 .inttab_tc2_08A 00000000  808ff140  808ff140  00007358  2**0
                  CONTENTS
671 .inttab_tc2_08B 00000000  808ff160  808ff160  00007358  2**0
                  CONTENTS
672 .inttab_tc2_08C 00000000  808ff180  808ff180  00007358  2**0
                  CONTENTS
673 .inttab_tc2_08D 00000000  808ff1a0  808ff1a0  00007358  2**0
                  CONTENTS
674 .inttab_tc2_08E 00000000  808ff1c0  808ff1c0  00007358  2**0
                  CONTENTS
675 .inttab_tc2_08F 00000000  808ff1e0  808ff1e0  00007358  2**0
                  CONTENTS
676 .inttab_tc2_090 00000000  808ff200  808ff200  00007358  2**0
                  CONTENTS
677 .inttab_tc2_091 00000000  808ff220  808ff220  00007358  2**0
                  CONTENTS
678 .inttab_tc2_092 00000000  808ff240  808ff240  00007358  2**0
                  CONTENTS
679 .inttab_tc2_093 00000000  808ff260  808ff260  00007358  2**0
                  CONTENTS
680 .inttab_tc2_094 00000000  808ff280  808ff280  00007358  2**0
                  CONTENTS
681 .inttab_tc2_095 00000000  808ff2a0  808ff2a0  00007358  2**0
                  CONTENTS
682 .inttab_tc2_096 00000000  808ff2c0  808ff2c0  00007358  2**0
                  CONTENTS
683 .inttab_tc2_097 00000000  808ff2e0  808ff2e0  00007358  2**0
                  CONTENTS
684 .inttab_tc2_098 00000000  808ff300  808ff300  00007358  2**0
                  CONTENTS
685 .inttab_tc2_099 00000000  808ff320  808ff320  00007358  2**0
                  CONTENTS
686 .inttab_tc2_09A 00000000  808ff340  808ff340  00007358  2**0
                  CONTENTS
687 .inttab_tc2_09B 00000000  808ff360  808ff360  00007358  2**0
                  CONTENTS
688 .inttab_tc2_09C 00000000  808ff380  808ff380  00007358  2**0
                  CONTENTS
689 .inttab_tc2_09D 00000000  808ff3a0  808ff3a0  00007358  2**0
                  CONTENTS
690 .inttab_tc2_09E 00000000  808ff3c0  808ff3c0  00007358  2**0
                  CONTENTS
691 .inttab_tc2_09F 00000000  808ff3e0  808ff3e0  00007358  2**0
                  CONTENTS
692 .inttab_tc2_0A0 00000000  808ff400  808ff400  00007358  2**0
                  CONTENTS
693 .inttab_tc2_0A1 00000000  808ff420  808ff420  00007358  2**0
                  CONTENTS
694 .inttab_tc2_0A2 00000000  808ff440  808ff440  00007358  2**0
                  CONTENTS
695 .inttab_tc2_0A3 00000000  808ff460  808ff460  00007358  2**0
                  CONTENTS
696 .inttab_tc2_0A4 00000000  808ff480  808ff480  00007358  2**0
                  CONTENTS
697 .inttab_tc2_0A5 00000000  808ff4a0  808ff4a0  00007358  2**0
                  CONTENTS
698 .inttab_tc2_0A6 00000000  808ff4c0  808ff4c0  00007358  2**0
                  CONTENTS
699 .inttab_tc2_0A7 00000000  808ff4e0  808ff4e0  00007358  2**0
                  CONTENTS
700 .inttab_tc2_0A8 00000000  808ff500  808ff500  00007358  2**0
                  CONTENTS
701 .inttab_tc2_0A9 00000000  808ff520  808ff520  00007358  2**0
                  CONTENTS
702 .inttab_tc2_0AA 00000000  808ff540  808ff540  00007358  2**0
                  CONTENTS
703 .inttab_tc2_0AB 00000000  808ff560  808ff560  00007358  2**0
                  CONTENTS
704 .inttab_tc2_0AC 00000000  808ff580  808ff580  00007358  2**0
                  CONTENTS
705 .inttab_tc2_0AD 00000000  808ff5a0  808ff5a0  00007358  2**0
                  CONTENTS
706 .inttab_tc2_0AE 00000000  808ff5c0  808ff5c0  00007358  2**0
                  CONTENTS
707 .inttab_tc2_0AF 00000000  808ff5e0  808ff5e0  00007358  2**0
                  CONTENTS
708 .inttab_tc2_0B0 00000000  808ff600  808ff600  00007358  2**0
                  CONTENTS
709 .inttab_tc2_0B1 00000000  808ff620  808ff620  00007358  2**0
                  CONTENTS
710 .inttab_tc2_0B2 00000000  808ff640  808ff640  00007358  2**0
                  CONTENTS
711 .inttab_tc2_0B3 00000000  808ff660  808ff660  00007358  2**0
                  CONTENTS
712 .inttab_tc2_0B4 00000000  808ff680  808ff680  00007358  2**0
                  CONTENTS
713 .inttab_tc2_0B5 00000000  808ff6a0  808ff6a0  00007358  2**0
                  CONTENTS
714 .inttab_tc2_0B6 00000000  808ff6c0  808ff6c0  00007358  2**0
                  CONTENTS
715 .inttab_tc2_0B7 00000000  808ff6e0  808ff6e0  00007358  2**0
                  CONTENTS
716 .inttab_tc2_0B8 00000000  808ff700  808ff700  00007358  2**0
                  CONTENTS
717 .inttab_tc2_0B9 00000000  808ff720  808ff720  00007358  2**0
                  CONTENTS
718 .inttab_tc2_0BA 00000000  808ff740  808ff740  00007358  2**0
                  CONTENTS
719 .inttab_tc2_0BB 00000000  808ff760  808ff760  00007358  2**0
                  CONTENTS
720 .inttab_tc2_0BC 00000000  808ff780  808ff780  00007358  2**0
                  CONTENTS
721 .inttab_tc2_0BD 00000000  808ff7a0  808ff7a0  00007358  2**0
                  CONTENTS
722 .inttab_tc2_0BE 00000000  808ff7c0  808ff7c0  00007358  2**0
                  CONTENTS
723 .inttab_tc2_0BF 00000000  808ff7e0  808ff7e0  00007358  2**0
                  CONTENTS
724 .inttab_tc2_0C0 00000000  808ff800  808ff800  00007358  2**0
                  CONTENTS
725 .inttab_tc2_0C1 00000000  808ff820  808ff820  00007358  2**0
                  CONTENTS
726 .inttab_tc2_0C2 00000000  808ff840  808ff840  00007358  2**0
                  CONTENTS
727 .inttab_tc2_0C3 00000000  808ff860  808ff860  00007358  2**0
                  CONTENTS
728 .inttab_tc2_0C4 00000000  808ff880  808ff880  00007358  2**0
                  CONTENTS
729 .inttab_tc2_0C5 00000000  808ff8a0  808ff8a0  00007358  2**0
                  CONTENTS
730 .inttab_tc2_0C6 00000000  808ff8c0  808ff8c0  00007358  2**0
                  CONTENTS
731 .inttab_tc2_0C7 00000000  808ff8e0  808ff8e0  00007358  2**0
                  CONTENTS
732 .inttab_tc2_0C8 00000000  808ff900  808ff900  00007358  2**0
                  CONTENTS
733 .inttab_tc2_0C9 00000000  808ff920  808ff920  00007358  2**0
                  CONTENTS
734 .inttab_tc2_0CA 00000000  808ff940  808ff940  00007358  2**0
                  CONTENTS
735 .inttab_tc2_0CB 00000000  808ff960  808ff960  00007358  2**0
                  CONTENTS
736 .inttab_tc2_0CC 00000000  808ff980  808ff980  00007358  2**0
                  CONTENTS
737 .inttab_tc2_0CD 00000000  808ff9a0  808ff9a0  00007358  2**0
                  CONTENTS
738 .inttab_tc2_0CE 00000000  808ff9c0  808ff9c0  00007358  2**0
                  CONTENTS
739 .inttab_tc2_0CF 00000000  808ff9e0  808ff9e0  00007358  2**0
                  CONTENTS
740 .inttab_tc2_0D0 00000000  808ffa00  808ffa00  00007358  2**0
                  CONTENTS
741 .inttab_tc2_0D1 00000000  808ffa20  808ffa20  00007358  2**0
                  CONTENTS
742 .inttab_tc2_0D2 00000000  808ffa40  808ffa40  00007358  2**0
                  CONTENTS
743 .inttab_tc2_0D3 00000000  808ffa60  808ffa60  00007358  2**0
                  CONTENTS
744 .inttab_tc2_0D4 00000000  808ffa80  808ffa80  00007358  2**0
                  CONTENTS
745 .inttab_tc2_0D5 00000000  808ffaa0  808ffaa0  00007358  2**0
                  CONTENTS
746 .inttab_tc2_0D6 00000000  808ffac0  808ffac0  00007358  2**0
                  CONTENTS
747 .inttab_tc2_0D7 00000000  808ffae0  808ffae0  00007358  2**0
                  CONTENTS
748 .inttab_tc2_0D8 00000000  808ffb00  808ffb00  00007358  2**0
                  CONTENTS
749 .inttab_tc2_0D9 00000000  808ffb20  808ffb20  00007358  2**0
                  CONTENTS
750 .inttab_tc2_0DA 00000000  808ffb40  808ffb40  00007358  2**0
                  CONTENTS
751 .inttab_tc2_0DB 00000000  808ffb60  808ffb60  00007358  2**0
                  CONTENTS
752 .inttab_tc2_0DC 00000000  808ffb80  808ffb80  00007358  2**0
                  CONTENTS
753 .inttab_tc2_0DD 00000000  808ffba0  808ffba0  00007358  2**0
                  CONTENTS
754 .inttab_tc2_0DE 00000000  808ffbc0  808ffbc0  00007358  2**0
                  CONTENTS
755 .inttab_tc2_0DF 00000000  808ffbe0  808ffbe0  00007358  2**0
                  CONTENTS
756 .inttab_tc2_0E0 00000000  808ffc00  808ffc00  00007358  2**0
                  CONTENTS
757 .inttab_tc2_0E1 00000000  808ffc20  808ffc20  00007358  2**0
                  CONTENTS
758 .inttab_tc2_0E2 00000000  808ffc40  808ffc40  00007358  2**0
                  CONTENTS
759 .inttab_tc2_0E3 00000000  808ffc60  808ffc60  00007358  2**0
                  CONTENTS
760 .inttab_tc2_0E4 00000000  808ffc80  808ffc80  00007358  2**0
                  CONTENTS
761 .inttab_tc2_0E5 00000000  808ffca0  808ffca0  00007358  2**0
                  CONTENTS
762 .inttab_tc2_0E6 00000000  808ffcc0  808ffcc0  00007358  2**0
                  CONTENTS
763 .inttab_tc2_0E7 00000000  808ffce0  808ffce0  00007358  2**0
                  CONTENTS
764 .inttab_tc2_0E8 00000000  808ffd00  808ffd00  00007358  2**0
                  CONTENTS
765 .inttab_tc2_0E9 00000000  808ffd20  808ffd20  00007358  2**0
                  CONTENTS
766 .inttab_tc2_0EA 00000000  808ffd40  808ffd40  00007358  2**0
                  CONTENTS
767 .inttab_tc2_0EB 00000000  808ffd60  808ffd60  00007358  2**0
                  CONTENTS
768 .inttab_tc2_0EC 00000000  808ffd80  808ffd80  00007358  2**0
                  CONTENTS
769 .inttab_tc2_0ED 00000000  808ffda0  808ffda0  00007358  2**0
                  CONTENTS
770 .inttab_tc2_0EE 00000000  808ffdc0  808ffdc0  00007358  2**0
                  CONTENTS
771 .inttab_tc2_0EF 00000000  808ffde0  808ffde0  00007358  2**0
                  CONTENTS
772 .inttab_tc2_0F0 00000000  808ffe00  808ffe00  00007358  2**0
                  CONTENTS
773 .inttab_tc2_0F1 00000000  808ffe20  808ffe20  00007358  2**0
                  CONTENTS
774 .inttab_tc2_0F2 00000000  808ffe40  808ffe40  00007358  2**0
                  CONTENTS
775 .inttab_tc2_0F3 00000000  808ffe60  808ffe60  00007358  2**0
                  CONTENTS
776 .inttab_tc2_0F4 00000000  808ffe80  808ffe80  00007358  2**0
                  CONTENTS
777 .inttab_tc2_0F5 00000000  808ffea0  808ffea0  00007358  2**0
                  CONTENTS
778 .inttab_tc2_0F6 00000000  808ffec0  808ffec0  00007358  2**0
                  CONTENTS
779 .inttab_tc2_0F7 00000000  808ffee0  808ffee0  00007358  2**0
                  CONTENTS
780 .inttab_tc2_0F8 00000000  808fff00  808fff00  00007358  2**0
                  CONTENTS
781 .inttab_tc2_0F9 00000000  808fff20  808fff20  00007358  2**0
                  CONTENTS
782 .inttab_tc2_0FA 00000000  808fff40  808fff40  00007358  2**0
                  CONTENTS
783 .inttab_tc2_0FB 00000000  808fff60  808fff60  00007358  2**0
                  CONTENTS
784 .inttab_tc2_0FC 00000000  808fff80  808fff80  00007358  2**0
                  CONTENTS
785 .inttab_tc2_0FD 00000000  808fffa0  808fffa0  00007358  2**0
                  CONTENTS
786 .inttab_tc2_0FE 00000000  808fffc0  808fffc0  00007358  2**0
                  CONTENTS
787 .inttab_tc2_0FF 00000000  808fffe0  808fffe0  00007358  2**0
                  CONTENTS
788 .inttab_tc3_000 00000000  809fe000  809fe000  00007358  2**0
                  CONTENTS
789 .inttab_tc3_001 00000000  809fe020  809fe020  00007358  2**0
                  CONTENTS
790 .inttab_tc3_002 00000000  809fe040  809fe040  00007358  2**0
                  CONTENTS
791 .inttab_tc3_003 00000000  809fe060  809fe060  00007358  2**0
                  CONTENTS
792 .inttab_tc3_004 00000000  809fe080  809fe080  00007358  2**0
                  CONTENTS
793 .inttab_tc3_005 00000000  809fe0a0  809fe0a0  00007358  2**0
                  CONTENTS
794 .inttab_tc3_006 00000000  809fe0c0  809fe0c0  00007358  2**0
                  CONTENTS
795 .inttab_tc3_007 00000000  809fe0e0  809fe0e0  00007358  2**0
                  CONTENTS
796 .inttab_tc3_008 00000000  809fe100  809fe100  00007358  2**0
                  CONTENTS
797 .inttab_tc3_009 00000000  809fe120  809fe120  00007358  2**0
                  CONTENTS
798 .inttab_tc3_00A 00000000  809fe140  809fe140  00007358  2**0
                  CONTENTS
799 .inttab_tc3_00B 00000000  809fe160  809fe160  00007358  2**0
                  CONTENTS
800 .inttab_tc3_00C 00000000  809fe180  809fe180  00007358  2**0
                  CONTENTS
801 .inttab_tc3_00D 00000000  809fe1a0  809fe1a0  00007358  2**0
                  CONTENTS
802 .inttab_tc3_00E 00000000  809fe1c0  809fe1c0  00007358  2**0
                  CONTENTS
803 .inttab_tc3_00F 00000000  809fe1e0  809fe1e0  00007358  2**0
                  CONTENTS
804 .inttab_tc3_010 00000000  809fe200  809fe200  00007358  2**0
                  CONTENTS
805 .inttab_tc3_011 00000000  809fe220  809fe220  00007358  2**0
                  CONTENTS
806 .inttab_tc3_012 00000000  809fe240  809fe240  00007358  2**0
                  CONTENTS
807 .inttab_tc3_013 00000000  809fe260  809fe260  00007358  2**0
                  CONTENTS
808 .inttab_tc3_014 00000000  809fe280  809fe280  00007358  2**0
                  CONTENTS
809 .inttab_tc3_015 00000000  809fe2a0  809fe2a0  00007358  2**0
                  CONTENTS
810 .inttab_tc3_016 00000000  809fe2c0  809fe2c0  00007358  2**0
                  CONTENTS
811 .inttab_tc3_017 00000000  809fe2e0  809fe2e0  00007358  2**0
                  CONTENTS
812 .inttab_tc3_018 00000000  809fe300  809fe300  00007358  2**0
                  CONTENTS
813 .inttab_tc3_019 00000000  809fe320  809fe320  00007358  2**0
                  CONTENTS
814 .inttab_tc3_01A 00000000  809fe340  809fe340  00007358  2**0
                  CONTENTS
815 .inttab_tc3_01B 00000000  809fe360  809fe360  00007358  2**0
                  CONTENTS
816 .inttab_tc3_01C 00000000  809fe380  809fe380  00007358  2**0
                  CONTENTS
817 .inttab_tc3_01D 00000000  809fe3a0  809fe3a0  00007358  2**0
                  CONTENTS
818 .inttab_tc3_01E 00000000  809fe3c0  809fe3c0  00007358  2**0
                  CONTENTS
819 .inttab_tc3_01F 00000000  809fe3e0  809fe3e0  00007358  2**0
                  CONTENTS
820 .inttab_tc3_020 00000000  809fe400  809fe400  00007358  2**0
                  CONTENTS
821 .inttab_tc3_021 00000000  809fe420  809fe420  00007358  2**0
                  CONTENTS
822 .inttab_tc3_022 00000000  809fe440  809fe440  00007358  2**0
                  CONTENTS
823 .inttab_tc3_023 00000000  809fe460  809fe460  00007358  2**0
                  CONTENTS
824 .inttab_tc3_024 00000000  809fe480  809fe480  00007358  2**0
                  CONTENTS
825 .inttab_tc3_025 00000000  809fe4a0  809fe4a0  00007358  2**0
                  CONTENTS
826 .inttab_tc3_026 00000000  809fe4c0  809fe4c0  00007358  2**0
                  CONTENTS
827 .inttab_tc3_027 00000000  809fe4e0  809fe4e0  00007358  2**0
                  CONTENTS
828 .inttab_tc3_028 00000000  809fe500  809fe500  00007358  2**0
                  CONTENTS
829 .inttab_tc3_029 00000000  809fe520  809fe520  00007358  2**0
                  CONTENTS
830 .inttab_tc3_02A 00000000  809fe540  809fe540  00007358  2**0
                  CONTENTS
831 .inttab_tc3_02B 00000000  809fe560  809fe560  00007358  2**0
                  CONTENTS
832 .inttab_tc3_02C 00000000  809fe580  809fe580  00007358  2**0
                  CONTENTS
833 .inttab_tc3_02D 00000000  809fe5a0  809fe5a0  00007358  2**0
                  CONTENTS
834 .inttab_tc3_02E 00000000  809fe5c0  809fe5c0  00007358  2**0
                  CONTENTS
835 .inttab_tc3_02F 00000000  809fe5e0  809fe5e0  00007358  2**0
                  CONTENTS
836 .inttab_tc3_030 00000000  809fe600  809fe600  00007358  2**0
                  CONTENTS
837 .inttab_tc3_031 00000000  809fe620  809fe620  00007358  2**0
                  CONTENTS
838 .inttab_tc3_032 00000000  809fe640  809fe640  00007358  2**0
                  CONTENTS
839 .inttab_tc3_033 00000000  809fe660  809fe660  00007358  2**0
                  CONTENTS
840 .inttab_tc3_034 00000000  809fe680  809fe680  00007358  2**0
                  CONTENTS
841 .inttab_tc3_035 00000000  809fe6a0  809fe6a0  00007358  2**0
                  CONTENTS
842 .inttab_tc3_036 00000000  809fe6c0  809fe6c0  00007358  2**0
                  CONTENTS
843 .inttab_tc3_037 00000000  809fe6e0  809fe6e0  00007358  2**0
                  CONTENTS
844 .inttab_tc3_038 00000000  809fe700  809fe700  00007358  2**0
                  CONTENTS
845 .inttab_tc3_039 00000000  809fe720  809fe720  00007358  2**0
                  CONTENTS
846 .inttab_tc3_03A 00000000  809fe740  809fe740  00007358  2**0
                  CONTENTS
847 .inttab_tc3_03B 00000000  809fe760  809fe760  00007358  2**0
                  CONTENTS
848 .inttab_tc3_03C 00000000  809fe780  809fe780  00007358  2**0
                  CONTENTS
849 .inttab_tc3_03D 00000000  809fe7a0  809fe7a0  00007358  2**0
                  CONTENTS
850 .inttab_tc3_03E 00000000  809fe7c0  809fe7c0  00007358  2**0
                  CONTENTS
851 .inttab_tc3_03F 00000000  809fe7e0  809fe7e0  00007358  2**0
                  CONTENTS
852 .inttab_tc3_040 00000000  809fe800  809fe800  00007358  2**0
                  CONTENTS
853 .inttab_tc3_041 00000000  809fe820  809fe820  00007358  2**0
                  CONTENTS
854 .inttab_tc3_042 00000000  809fe840  809fe840  00007358  2**0
                  CONTENTS
855 .inttab_tc3_043 00000000  809fe860  809fe860  00007358  2**0
                  CONTENTS
856 .inttab_tc3_044 00000000  809fe880  809fe880  00007358  2**0
                  CONTENTS
857 .inttab_tc3_045 00000000  809fe8a0  809fe8a0  00007358  2**0
                  CONTENTS
858 .inttab_tc3_046 00000000  809fe8c0  809fe8c0  00007358  2**0
                  CONTENTS
859 .inttab_tc3_047 00000000  809fe8e0  809fe8e0  00007358  2**0
                  CONTENTS
860 .inttab_tc3_048 00000000  809fe900  809fe900  00007358  2**0
                  CONTENTS
861 .inttab_tc3_049 00000000  809fe920  809fe920  00007358  2**0
                  CONTENTS
862 .inttab_tc3_04A 00000000  809fe940  809fe940  00007358  2**0
                  CONTENTS
863 .inttab_tc3_04B 00000000  809fe960  809fe960  00007358  2**0
                  CONTENTS
864 .inttab_tc3_04C 00000000  809fe980  809fe980  00007358  2**0
                  CONTENTS
865 .inttab_tc3_04D 00000000  809fe9a0  809fe9a0  00007358  2**0
                  CONTENTS
866 .inttab_tc3_04E 00000000  809fe9c0  809fe9c0  00007358  2**0
                  CONTENTS
867 .inttab_tc3_04F 00000000  809fe9e0  809fe9e0  00007358  2**0
                  CONTENTS
868 .inttab_tc3_050 00000000  809fea00  809fea00  00007358  2**0
                  CONTENTS
869 .inttab_tc3_051 00000000  809fea20  809fea20  00007358  2**0
                  CONTENTS
870 .inttab_tc3_052 00000000  809fea40  809fea40  00007358  2**0
                  CONTENTS
871 .inttab_tc3_053 00000000  809fea60  809fea60  00007358  2**0
                  CONTENTS
872 .inttab_tc3_054 00000000  809fea80  809fea80  00007358  2**0
                  CONTENTS
873 .inttab_tc3_055 00000000  809feaa0  809feaa0  00007358  2**0
                  CONTENTS
874 .inttab_tc3_056 00000000  809feac0  809feac0  00007358  2**0
                  CONTENTS
875 .inttab_tc3_057 00000000  809feae0  809feae0  00007358  2**0
                  CONTENTS
876 .inttab_tc3_058 00000000  809feb00  809feb00  00007358  2**0
                  CONTENTS
877 .inttab_tc3_059 00000000  809feb20  809feb20  00007358  2**0
                  CONTENTS
878 .inttab_tc3_05A 00000000  809feb40  809feb40  00007358  2**0
                  CONTENTS
879 .inttab_tc3_05B 00000000  809feb60  809feb60  00007358  2**0
                  CONTENTS
880 .inttab_tc3_05C 00000000  809feb80  809feb80  00007358  2**0
                  CONTENTS
881 .inttab_tc3_05D 00000000  809feba0  809feba0  00007358  2**0
                  CONTENTS
882 .inttab_tc3_05E 00000000  809febc0  809febc0  00007358  2**0
                  CONTENTS
883 .inttab_tc3_05F 00000000  809febe0  809febe0  00007358  2**0
                  CONTENTS
884 .inttab_tc3_060 00000000  809fec00  809fec00  00007358  2**0
                  CONTENTS
885 .inttab_tc3_061 00000000  809fec20  809fec20  00007358  2**0
                  CONTENTS
886 .inttab_tc3_062 00000000  809fec40  809fec40  00007358  2**0
                  CONTENTS
887 .inttab_tc3_063 00000000  809fec60  809fec60  00007358  2**0
                  CONTENTS
888 .inttab_tc3_064 00000000  809fec80  809fec80  00007358  2**0
                  CONTENTS
889 .inttab_tc3_065 00000000  809feca0  809feca0  00007358  2**0
                  CONTENTS
890 .inttab_tc3_066 00000000  809fecc0  809fecc0  00007358  2**0
                  CONTENTS
891 .inttab_tc3_067 00000000  809fece0  809fece0  00007358  2**0
                  CONTENTS
892 .inttab_tc3_068 00000000  809fed00  809fed00  00007358  2**0
                  CONTENTS
893 .inttab_tc3_069 00000000  809fed20  809fed20  00007358  2**0
                  CONTENTS
894 .inttab_tc3_06A 00000000  809fed40  809fed40  00007358  2**0
                  CONTENTS
895 .inttab_tc3_06B 00000000  809fed60  809fed60  00007358  2**0
                  CONTENTS
896 .inttab_tc3_06C 00000000  809fed80  809fed80  00007358  2**0
                  CONTENTS
897 .inttab_tc3_06D 00000000  809feda0  809feda0  00007358  2**0
                  CONTENTS
898 .inttab_tc3_06E 00000000  809fedc0  809fedc0  00007358  2**0
                  CONTENTS
899 .inttab_tc3_06F 00000000  809fede0  809fede0  00007358  2**0
                  CONTENTS
900 .inttab_tc3_070 00000000  809fee00  809fee00  00007358  2**0
                  CONTENTS
901 .inttab_tc3_071 00000000  809fee20  809fee20  00007358  2**0
                  CONTENTS
902 .inttab_tc3_072 00000000  809fee40  809fee40  00007358  2**0
                  CONTENTS
903 .inttab_tc3_073 00000000  809fee60  809fee60  00007358  2**0
                  CONTENTS
904 .inttab_tc3_074 00000000  809fee80  809fee80  00007358  2**0
                  CONTENTS
905 .inttab_tc3_075 00000000  809feea0  809feea0  00007358  2**0
                  CONTENTS
906 .inttab_tc3_076 00000000  809feec0  809feec0  00007358  2**0
                  CONTENTS
907 .inttab_tc3_077 00000000  809feee0  809feee0  00007358  2**0
                  CONTENTS
908 .inttab_tc3_078 00000000  809fef00  809fef00  00007358  2**0
                  CONTENTS
909 .inttab_tc3_079 00000000  809fef20  809fef20  00007358  2**0
                  CONTENTS
910 .inttab_tc3_07A 00000000  809fef40  809fef40  00007358  2**0
                  CONTENTS
911 .inttab_tc3_07B 00000000  809fef60  809fef60  00007358  2**0
                  CONTENTS
912 .inttab_tc3_07C 00000000  809fef80  809fef80  00007358  2**0
                  CONTENTS
913 .inttab_tc3_07D 00000000  809fefa0  809fefa0  00007358  2**0
                  CONTENTS
914 .inttab_tc3_07E 00000000  809fefc0  809fefc0  00007358  2**0
                  CONTENTS
915 .inttab_tc3_07F 00000000  809fefe0  809fefe0  00007358  2**0
                  CONTENTS
916 .inttab_tc3_080 00000000  809ff000  809ff000  00007358  2**0
                  CONTENTS
917 .inttab_tc3_081 00000000  809ff020  809ff020  00007358  2**0
                  CONTENTS
918 .inttab_tc3_082 00000000  809ff040  809ff040  00007358  2**0
                  CONTENTS
919 .inttab_tc3_083 00000000  809ff060  809ff060  00007358  2**0
                  CONTENTS
920 .inttab_tc3_084 00000000  809ff080  809ff080  00007358  2**0
                  CONTENTS
921 .inttab_tc3_085 00000000  809ff0a0  809ff0a0  00007358  2**0
                  CONTENTS
922 .inttab_tc3_086 00000000  809ff0c0  809ff0c0  00007358  2**0
                  CONTENTS
923 .inttab_tc3_087 00000000  809ff0e0  809ff0e0  00007358  2**0
                  CONTENTS
924 .inttab_tc3_088 00000000  809ff100  809ff100  00007358  2**0
                  CONTENTS
925 .inttab_tc3_089 00000000  809ff120  809ff120  00007358  2**0
                  CONTENTS
926 .inttab_tc3_08A 00000000  809ff140  809ff140  00007358  2**0
                  CONTENTS
927 .inttab_tc3_08B 00000000  809ff160  809ff160  00007358  2**0
                  CONTENTS
928 .inttab_tc3_08C 00000000  809ff180  809ff180  00007358  2**0
                  CONTENTS
929 .inttab_tc3_08D 00000000  809ff1a0  809ff1a0  00007358  2**0
                  CONTENTS
930 .inttab_tc3_08E 00000000  809ff1c0  809ff1c0  00007358  2**0
                  CONTENTS
931 .inttab_tc3_08F 00000000  809ff1e0  809ff1e0  00007358  2**0
                  CONTENTS
932 .inttab_tc3_090 00000000  809ff200  809ff200  00007358  2**0
                  CONTENTS
933 .inttab_tc3_091 00000000  809ff220  809ff220  00007358  2**0
                  CONTENTS
934 .inttab_tc3_092 00000000  809ff240  809ff240  00007358  2**0
                  CONTENTS
935 .inttab_tc3_093 00000000  809ff260  809ff260  00007358  2**0
                  CONTENTS
936 .inttab_tc3_094 00000000  809ff280  809ff280  00007358  2**0
                  CONTENTS
937 .inttab_tc3_095 00000000  809ff2a0  809ff2a0  00007358  2**0
                  CONTENTS
938 .inttab_tc3_096 00000000  809ff2c0  809ff2c0  00007358  2**0
                  CONTENTS
939 .inttab_tc3_097 00000000  809ff2e0  809ff2e0  00007358  2**0
                  CONTENTS
940 .inttab_tc3_098 00000000  809ff300  809ff300  00007358  2**0
                  CONTENTS
941 .inttab_tc3_099 00000000  809ff320  809ff320  00007358  2**0
                  CONTENTS
942 .inttab_tc3_09A 00000000  809ff340  809ff340  00007358  2**0
                  CONTENTS
943 .inttab_tc3_09B 00000000  809ff360  809ff360  00007358  2**0
                  CONTENTS
944 .inttab_tc3_09C 00000000  809ff380  809ff380  00007358  2**0
                  CONTENTS
945 .inttab_tc3_09D 00000000  809ff3a0  809ff3a0  00007358  2**0
                  CONTENTS
946 .inttab_tc3_09E 00000000  809ff3c0  809ff3c0  00007358  2**0
                  CONTENTS
947 .inttab_tc3_09F 00000000  809ff3e0  809ff3e0  00007358  2**0
                  CONTENTS
948 .inttab_tc3_0A0 00000000  809ff400  809ff400  00007358  2**0
                  CONTENTS
949 .inttab_tc3_0A1 00000000  809ff420  809ff420  00007358  2**0
                  CONTENTS
950 .inttab_tc3_0A2 00000000  809ff440  809ff440  00007358  2**0
                  CONTENTS
951 .inttab_tc3_0A3 00000000  809ff460  809ff460  00007358  2**0
                  CONTENTS
952 .inttab_tc3_0A4 00000000  809ff480  809ff480  00007358  2**0
                  CONTENTS
953 .inttab_tc3_0A5 00000000  809ff4a0  809ff4a0  00007358  2**0
                  CONTENTS
954 .inttab_tc3_0A6 00000000  809ff4c0  809ff4c0  00007358  2**0
                  CONTENTS
955 .inttab_tc3_0A7 00000000  809ff4e0  809ff4e0  00007358  2**0
                  CONTENTS
956 .inttab_tc3_0A8 00000000  809ff500  809ff500  00007358  2**0
                  CONTENTS
957 .inttab_tc3_0A9 00000000  809ff520  809ff520  00007358  2**0
                  CONTENTS
958 .inttab_tc3_0AA 00000000  809ff540  809ff540  00007358  2**0
                  CONTENTS
959 .inttab_tc3_0AB 00000000  809ff560  809ff560  00007358  2**0
                  CONTENTS
960 .inttab_tc3_0AC 00000000  809ff580  809ff580  00007358  2**0
                  CONTENTS
961 .inttab_tc3_0AD 00000000  809ff5a0  809ff5a0  00007358  2**0
                  CONTENTS
962 .inttab_tc3_0AE 00000000  809ff5c0  809ff5c0  00007358  2**0
                  CONTENTS
963 .inttab_tc3_0AF 00000000  809ff5e0  809ff5e0  00007358  2**0
                  CONTENTS
964 .inttab_tc3_0B0 00000000  809ff600  809ff600  00007358  2**0
                  CONTENTS
965 .inttab_tc3_0B1 00000000  809ff620  809ff620  00007358  2**0
                  CONTENTS
966 .inttab_tc3_0B2 00000000  809ff640  809ff640  00007358  2**0
                  CONTENTS
967 .inttab_tc3_0B3 00000000  809ff660  809ff660  00007358  2**0
                  CONTENTS
968 .inttab_tc3_0B4 00000000  809ff680  809ff680  00007358  2**0
                  CONTENTS
969 .inttab_tc3_0B5 00000000  809ff6a0  809ff6a0  00007358  2**0
                  CONTENTS
970 .inttab_tc3_0B6 00000000  809ff6c0  809ff6c0  00007358  2**0
                  CONTENTS
971 .inttab_tc3_0B7 00000000  809ff6e0  809ff6e0  00007358  2**0
                  CONTENTS
972 .inttab_tc3_0B8 00000000  809ff700  809ff700  00007358  2**0
                  CONTENTS
973 .inttab_tc3_0B9 00000000  809ff720  809ff720  00007358  2**0
                  CONTENTS
974 .inttab_tc3_0BA 00000000  809ff740  809ff740  00007358  2**0
                  CONTENTS
975 .inttab_tc3_0BB 00000000  809ff760  809ff760  00007358  2**0
                  CONTENTS
976 .inttab_tc3_0BC 00000000  809ff780  809ff780  00007358  2**0
                  CONTENTS
977 .inttab_tc3_0BD 00000000  809ff7a0  809ff7a0  00007358  2**0
                  CONTENTS
978 .inttab_tc3_0BE 00000000  809ff7c0  809ff7c0  00007358  2**0
                  CONTENTS
979 .inttab_tc3_0BF 00000000  809ff7e0  809ff7e0  00007358  2**0
                  CONTENTS
980 .inttab_tc3_0C0 00000000  809ff800  809ff800  00007358  2**0
                  CONTENTS
981 .inttab_tc3_0C1 00000000  809ff820  809ff820  00007358  2**0
                  CONTENTS
982 .inttab_tc3_0C2 00000000  809ff840  809ff840  00007358  2**0
                  CONTENTS
983 .inttab_tc3_0C3 00000000  809ff860  809ff860  00007358  2**0
                  CONTENTS
984 .inttab_tc3_0C4 00000000  809ff880  809ff880  00007358  2**0
                  CONTENTS
985 .inttab_tc3_0C5 00000000  809ff8a0  809ff8a0  00007358  2**0
                  CONTENTS
986 .inttab_tc3_0C6 00000000  809ff8c0  809ff8c0  00007358  2**0
                  CONTENTS
987 .inttab_tc3_0C7 00000000  809ff8e0  809ff8e0  00007358  2**0
                  CONTENTS
988 .inttab_tc3_0C8 00000000  809ff900  809ff900  00007358  2**0
                  CONTENTS
989 .inttab_tc3_0C9 00000000  809ff920  809ff920  00007358  2**0
                  CONTENTS
990 .inttab_tc3_0CA 00000000  809ff940  809ff940  00007358  2**0
                  CONTENTS
991 .inttab_tc3_0CB 00000000  809ff960  809ff960  00007358  2**0
                  CONTENTS
992 .inttab_tc3_0CC 00000000  809ff980  809ff980  00007358  2**0
                  CONTENTS
993 .inttab_tc3_0CD 00000000  809ff9a0  809ff9a0  00007358  2**0
                  CONTENTS
994 .inttab_tc3_0CE 00000000  809ff9c0  809ff9c0  00007358  2**0
                  CONTENTS
995 .inttab_tc3_0CF 00000000  809ff9e0  809ff9e0  00007358  2**0
                  CONTENTS
996 .inttab_tc3_0D0 00000000  809ffa00  809ffa00  00007358  2**0
                  CONTENTS
997 .inttab_tc3_0D1 00000000  809ffa20  809ffa20  00007358  2**0
                  CONTENTS
998 .inttab_tc3_0D2 00000000  809ffa40  809ffa40  00007358  2**0
                  CONTENTS
999 .inttab_tc3_0D3 00000000  809ffa60  809ffa60  00007358  2**0
                  CONTENTS
1000 .inttab_tc3_0D4 00000000  809ffa80  809ffa80  00007358  2**0
                  CONTENTS
1001 .inttab_tc3_0D5 00000000  809ffaa0  809ffaa0  00007358  2**0
                  CONTENTS
1002 .inttab_tc3_0D6 00000000  809ffac0  809ffac0  00007358  2**0
                  CONTENTS
1003 .inttab_tc3_0D7 00000000  809ffae0  809ffae0  00007358  2**0
                  CONTENTS
1004 .inttab_tc3_0D8 00000000  809ffb00  809ffb00  00007358  2**0
                  CONTENTS
1005 .inttab_tc3_0D9 00000000  809ffb20  809ffb20  00007358  2**0
                  CONTENTS
1006 .inttab_tc3_0DA 00000000  809ffb40  809ffb40  00007358  2**0
                  CONTENTS
1007 .inttab_tc3_0DB 00000000  809ffb60  809ffb60  00007358  2**0
                  CONTENTS
1008 .inttab_tc3_0DC 00000000  809ffb80  809ffb80  00007358  2**0
                  CONTENTS
1009 .inttab_tc3_0DD 00000000  809ffba0  809ffba0  00007358  2**0
                  CONTENTS
1010 .inttab_tc3_0DE 00000000  809ffbc0  809ffbc0  00007358  2**0
                  CONTENTS
1011 .inttab_tc3_0DF 00000000  809ffbe0  809ffbe0  00007358  2**0
                  CONTENTS
1012 .inttab_tc3_0E0 00000000  809ffc00  809ffc00  00007358  2**0
                  CONTENTS
1013 .inttab_tc3_0E1 00000000  809ffc20  809ffc20  00007358  2**0
                  CONTENTS
1014 .inttab_tc3_0E2 00000000  809ffc40  809ffc40  00007358  2**0
                  CONTENTS
1015 .inttab_tc3_0E3 00000000  809ffc60  809ffc60  00007358  2**0
                  CONTENTS
1016 .inttab_tc3_0E4 00000000  809ffc80  809ffc80  00007358  2**0
                  CONTENTS
1017 .inttab_tc3_0E5 00000000  809ffca0  809ffca0  00007358  2**0
                  CONTENTS
1018 .inttab_tc3_0E6 00000000  809ffcc0  809ffcc0  00007358  2**0
                  CONTENTS
1019 .inttab_tc3_0E7 00000000  809ffce0  809ffce0  00007358  2**0
                  CONTENTS
1020 .inttab_tc3_0E8 00000000  809ffd00  809ffd00  00007358  2**0
                  CONTENTS
1021 .inttab_tc3_0E9 00000000  809ffd20  809ffd20  00007358  2**0
                  CONTENTS
1022 .inttab_tc3_0EA 00000000  809ffd40  809ffd40  00007358  2**0
                  CONTENTS
1023 .inttab_tc3_0EB 00000000  809ffd60  809ffd60  00007358  2**0
                  CONTENTS
1024 .inttab_tc3_0EC 00000000  809ffd80  809ffd80  00007358  2**0
                  CONTENTS
1025 .inttab_tc3_0ED 00000000  809ffda0  809ffda0  00007358  2**0
                  CONTENTS
1026 .inttab_tc3_0EE 00000000  809ffdc0  809ffdc0  00007358  2**0
                  CONTENTS
1027 .inttab_tc3_0EF 00000000  809ffde0  809ffde0  00007358  2**0
                  CONTENTS
1028 .inttab_tc3_0F0 00000000  809ffe00  809ffe00  00007358  2**0
                  CONTENTS
1029 .inttab_tc3_0F1 00000000  809ffe20  809ffe20  00007358  2**0
                  CONTENTS
1030 .inttab_tc3_0F2 00000000  809ffe40  809ffe40  00007358  2**0
                  CONTENTS
1031 .inttab_tc3_0F3 00000000  809ffe60  809ffe60  00007358  2**0
                  CONTENTS
1032 .inttab_tc3_0F4 00000000  809ffe80  809ffe80  00007358  2**0
                  CONTENTS
1033 .inttab_tc3_0F5 00000000  809ffea0  809ffea0  00007358  2**0
                  CONTENTS
1034 .inttab_tc3_0F6 00000000  809ffec0  809ffec0  00007358  2**0
                  CONTENTS
1035 .inttab_tc3_0F7 00000000  809ffee0  809ffee0  00007358  2**0
                  CONTENTS
1036 .inttab_tc3_0F8 00000000  809fff00  809fff00  00007358  2**0
                  CONTENTS
1037 .inttab_tc3_0F9 00000000  809fff20  809fff20  00007358  2**0
                  CONTENTS
1038 .inttab_tc3_0FA 00000000  809fff40  809fff40  00007358  2**0
                  CONTENTS
1039 .inttab_tc3_0FB 00000000  809fff60  809fff60  00007358  2**0
                  CONTENTS
1040 .inttab_tc3_0FC 00000000  809fff80  809fff80  00007358  2**0
                  CONTENTS
1041 .inttab_tc3_0FD 00000000  809fffa0  809fffa0  00007358  2**0
                  CONTENTS
1042 .inttab_tc3_0FE 00000000  809fffc0  809fffc0  00007358  2**0
                  CONTENTS
1043 .inttab_tc3_0FF 00000000  809fffe0  809fffe0  00007358  2**0
                  CONTENTS
1044 .bmhd_0_org   000001f4  af400000  af400000  000063b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1045 .bmhd_1_org   000001f4  af400200  af400200  000065ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1046 .bmhd_2_org   000001f4  af400400  af400400  000067a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1047 .bmhd_3_org   000001f4  af400600  af400600  00006994  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1048 .bmhd_0_copy  000001f4  af401000  af401000  00006b88  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1049 .bmhd_1_copy  000001f4  af401200  af401200  00006d7c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1050 .bmhd_2_copy  000001f4  af401400  af401400  00006f70  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1051 .bmhd_3_copy  000001f4  af401600  af401600  00007164  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1052 .CPU3.zdata   00000000  40000000  40000000  00007358  2**0
                  CONTENTS
1053 .CPU2.zdata   00000000  50000000  50000000  00007358  2**0
                  CONTENTS
1054 .CPU1.zdata   00000000  60000000  60000000  00007358  2**0
                  CONTENTS
1055 .CPU0.zdata   00000000  70000000  70000000  00007358  2**0
                  CONTENTS
1056 .zdata_powerOn 00000000  70000000  70000000  00007358  2**0
                  CONTENTS
1057 .zdata        00000000  70000000  70000000  00007358  2**0
                  CONTENTS, ALLOC, LOAD, DATA
1058 .lmuzdata     00000000  90000000  90000000  00007358  2**0
                  CONTENTS
1059 .sdata        00000000  70000000  70000000  00007358  2**0
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
1060 .sdata4       00000000  90040000  90040000  00007358  2**0
                  CONTENTS, ALLOC, LOAD, DATA
1061 .CPU3.data    00000000  40000000  40000000  00007358  2**0
                  CONTENTS
1062 .CPU3.lmudata 00000000  90030000  90030000  00007358  2**0
                  CONTENTS
1063 .CPU2.data    00000000  50000000  50000000  00007358  2**0
                  CONTENTS
1064 .CPU2.lmudata 00000000  90020000  90020000  00007358  2**0
                  CONTENTS
1065 .CPU1.data    00000000  60000000  60000000  00007358  2**0
                  CONTENTS
1066 .CPU1.lmudata 00000000  90010000  90010000  00007358  2**0
                  CONTENTS
1067 .CPU0.data    00000000  70000000  70000000  00007358  2**0
                  CONTENTS
1068 .CPU0.lmudata 00000000  90000000  90000000  00007358  2**0
                  CONTENTS
1069 .data         00000000  70000000  70000000  00007358  2**0
                  CONTENTS, ALLOC, LOAD, DATA
1070 .bss          000107e8  70000000  80000200  000006c0  2**3
                  ALLOC
1071 .heap         00001000  700107e8  80000200  000006c0  2**0
                  ALLOC
1072 .lmudata      00000000  90040000  90040000  00007358  2**0
                  CONTENTS
1073 .CPU0.rodata  00000009  80000200  80000200  000006c0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1074 .rodata       0000050c  8000020c  8000020c  000006cc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1075 .CPU0.psram_text 00000000  70100000  70100000  00007358  2**0
                  CONTENTS
1076 .CPU1.psram_text 00000000  60100000  60100000  00007358  2**0
                  CONTENTS
1077 .CPU2.psram_text 00000000  50100000  50100000  00007358  2**0
                  CONTENTS
1078 .CPU3.psram_text 00000000  40100000  40100000  00007358  2**0
                  CONTENTS
1079 .CPU0.text    000003e0  80000718  80000718  00000bd8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1080 .init         00000010  80000af8  80000af8  00000fb8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1081 .fini         00000008  80000b08  80000b08  00000fc8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1082 .CPU1.text    000001f8  8030010c  8030010c  00005ba0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1083 .CPU2.text    000001f8  8060010c  8060010c  00005ea0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1084 .CPU3.text    000001e6  8090010c  8090010c  000061a0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1085 .text         00004a34  80000b10  80000b10  00000fd0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1086 .eh_frame     00000004  80005544  80005544  00005a04  2**0
                  ALLOC
1087 .ctors        00000010  80005548  80005548  00005a04  2**2
                  CONTENTS, ALLOC, LOAD, DATA
1088 .dtors        00000010  80005558  80005558  00005a14  2**2
                  CONTENTS, ALLOC, LOAD, DATA
1089 .comment      00000082  00000000  00000000  00007358  2**0
                  CONTENTS, READONLY
1090 .debug_aranges 00000fa0  00000000  00000000  000073e0  2**3
                  CONTENTS, READONLY, DEBUGGING
1091 .debug_info   000ca44f  00000000  00000000  00008380  2**0
                  CONTENTS, READONLY, DEBUGGING
1092 .debug_abbrev 00006a19  00000000  00000000  000d27cf  2**0
                  CONTENTS, READONLY, DEBUGGING
1093 .debug_line   0001b170  00000000  00000000  000d91e8  2**0
                  CONTENTS, READONLY, DEBUGGING
1094 .debug_frame  000024a0  00000000  00000000  000f4358  2**2
                  CONTENTS, READONLY, DEBUGGING
1095 .debug_str    00002998  00000000  00000000  000f67f8  2**0
                  CONTENTS, READONLY, DEBUGGING
1096 .debug_loc    0000ea72  00000000  00000000  000f9190  2**0
                  CONTENTS, READONLY, DEBUGGING
1097 .debug_ranges 00001480  00000000  00000000  00107c08  2**3
                  CONTENTS, READONLY, DEBUGGING
1098 .debug_macro  00036f4a  00000000  00000000  00109088  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .start_tc0:

a0000000 <_START>:
}


IFX_SSW_INLINE void Ifx_Ssw_jumpToFunction(void (*fun)(void))
{
    __asm__ volatile ("ji %0" ::"a" (fun));
a0000000:	91 00 00 28 	movh.a %a2,32768
a0000004:	d9 22 80 40 	lea %a2,[%a2]2304 <80000900 <__StartUpSoftware>>
a0000008:	dc 02       	ji %a2
#endif

void _START(void)
{
    Ifx_Ssw_jumpToFunction(__StartUpSoftware);
}
a000000a:	00 90       	ret 

Disassembly of section .traptab_tc0:

80000100 <IfxCpu_Trap_vectorTable0>:
#pragma ghs section
#pragma ghs section text=".traptab_cpu0"
#endif
void IfxCpu_Trap_vectorTable0(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
80000100:	0d 00 00 02 	svlcx 
80000104:	02 f4       	mov %d4,%d15
80000106:	91 00 00 28 	movh.a %a2,32768
8000010a:	d9 22 c4 41 	lea %a2,[%a2]7428 <80001d04 <IfxCpu_Trap_memoryManagementError>>
8000010e:	dc 02       	ji %a2
80000110:	00 80       	rfe 
	...
8000011e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
80000120:	0d 00 00 02 	svlcx 
80000124:	02 f4       	mov %d4,%d15
80000126:	91 00 00 28 	movh.a %a2,32768
8000012a:	d9 22 f2 41 	lea %a2,[%a2]7474 <80001d32 <IfxCpu_Trap_internalProtectionError>>
8000012e:	dc 02       	ji %a2
80000130:	00 80       	rfe 
	...
8000013e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
80000140:	0d 00 00 02 	svlcx 
80000144:	02 f4       	mov %d4,%d15
80000146:	91 00 00 28 	movh.a %a2,32768
8000014a:	d9 22 e0 51 	lea %a2,[%a2]7520 <80001d60 <IfxCpu_Trap_instructionError>>
8000014e:	dc 02       	ji %a2
80000150:	00 80       	rfe 
	...
8000015e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
80000160:	02 f4       	mov %d4,%d15
80000162:	91 00 00 28 	movh.a %a2,32768
80000166:	d9 22 ce 61 	lea %a2,[%a2]7566 <80001d8e <IfxCpu_Trap_contextManagementError>>
8000016a:	dc 02       	ji %a2
8000016c:	00 80       	rfe 
	...
8000017e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
80000180:	0d 00 00 02 	svlcx 
80000184:	02 f4       	mov %d4,%d15
80000186:	91 00 00 28 	movh.a %a2,32768
8000018a:	d9 22 fc 61 	lea %a2,[%a2]7612 <80001dbc <IfxCpu_Trap_busError>>
8000018e:	dc 02       	ji %a2
80000190:	00 80       	rfe 
	...
8000019e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
800001a0:	0d 00 00 02 	svlcx 
800001a4:	02 f4       	mov %d4,%d15
800001a6:	91 00 00 28 	movh.a %a2,32768
800001aa:	d9 22 ea 71 	lea %a2,[%a2]7658 <80001dea <IfxCpu_Trap_assertion>>
800001ae:	dc 02       	ji %a2
800001b0:	00 80       	rfe 
	...
800001be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu0);
800001c0:	0d 00 00 02 	svlcx 
800001c4:	02 f4       	mov %d4,%d15
800001c6:	91 00 00 28 	movh.a %a2,32768
800001ca:	d9 22 de 81 	lea %a2,[%a2]7710 <80001e1e <IfxCpu_Trap_systemCall_Cpu0>>
800001ce:	dc 02       	ji %a2
800001d0:	00 80       	rfe 
	...
800001de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
800001e0:	0d 00 00 02 	svlcx 
800001e4:	02 f4       	mov %d4,%d15
800001e6:	91 00 00 28 	movh.a %a2,32768
800001ea:	d9 22 ce b1 	lea %a2,[%a2]7886 <80001ece <IfxCpu_Trap_nonMaskableInterrupt>>
800001ee:	dc 02       	ji %a2
800001f0:	00 80       	rfe 
}
800001f2:	00 90       	ret 

800001f4 <IfxCpu_Trap_vectorTable0_end>:
	...

Disassembly of section .traptab_tc1:

80300000 <IfxCpu_Trap_vectorTable1>:
#pragma ghs section
#pragma ghs section text=".traptab_cpu1"
#endif
void IfxCpu_Trap_vectorTable1(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
80300000:	0d 00 00 02 	svlcx 
80300004:	02 f4       	mov %d4,%d15
80300006:	91 00 00 28 	movh.a %a2,32768
8030000a:	d9 22 c4 41 	lea %a2,[%a2]7428 <80001d04 <IfxCpu_Trap_memoryManagementError>>
8030000e:	dc 02       	ji %a2
80300010:	00 80       	rfe 
	...
8030001e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
80300020:	0d 00 00 02 	svlcx 
80300024:	02 f4       	mov %d4,%d15
80300026:	91 00 00 28 	movh.a %a2,32768
8030002a:	d9 22 f2 41 	lea %a2,[%a2]7474 <80001d32 <IfxCpu_Trap_internalProtectionError>>
8030002e:	dc 02       	ji %a2
80300030:	00 80       	rfe 
	...
8030003e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
80300040:	0d 00 00 02 	svlcx 
80300044:	02 f4       	mov %d4,%d15
80300046:	91 00 00 28 	movh.a %a2,32768
8030004a:	d9 22 e0 51 	lea %a2,[%a2]7520 <80001d60 <IfxCpu_Trap_instructionError>>
8030004e:	dc 02       	ji %a2
80300050:	00 80       	rfe 
	...
8030005e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
80300060:	02 f4       	mov %d4,%d15
80300062:	91 00 00 28 	movh.a %a2,32768
80300066:	d9 22 ce 61 	lea %a2,[%a2]7566 <80001d8e <IfxCpu_Trap_contextManagementError>>
8030006a:	dc 02       	ji %a2
8030006c:	00 80       	rfe 
	...
8030007e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
80300080:	0d 00 00 02 	svlcx 
80300084:	02 f4       	mov %d4,%d15
80300086:	91 00 00 28 	movh.a %a2,32768
8030008a:	d9 22 fc 61 	lea %a2,[%a2]7612 <80001dbc <IfxCpu_Trap_busError>>
8030008e:	dc 02       	ji %a2
80300090:	00 80       	rfe 
	...
8030009e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
803000a0:	0d 00 00 02 	svlcx 
803000a4:	02 f4       	mov %d4,%d15
803000a6:	91 00 00 28 	movh.a %a2,32768
803000aa:	d9 22 ea 71 	lea %a2,[%a2]7658 <80001dea <IfxCpu_Trap_assertion>>
803000ae:	dc 02       	ji %a2
803000b0:	00 80       	rfe 
	...
803000be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu1);
803000c0:	0d 00 00 02 	svlcx 
803000c4:	02 f4       	mov %d4,%d15
803000c6:	91 00 00 28 	movh.a %a2,32768
803000ca:	d9 22 ca 91 	lea %a2,[%a2]7754 <80001e4a <IfxCpu_Trap_systemCall_Cpu1>>
803000ce:	dc 02       	ji %a2
803000d0:	00 80       	rfe 
	...
803000de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
803000e0:	0d 00 00 02 	svlcx 
803000e4:	02 f4       	mov %d4,%d15
803000e6:	91 00 00 28 	movh.a %a2,32768
803000ea:	d9 22 ce b1 	lea %a2,[%a2]7886 <80001ece <IfxCpu_Trap_nonMaskableInterrupt>>
803000ee:	dc 02       	ji %a2
803000f0:	00 80       	rfe 
}
803000f2:	00 90       	ret 

803000f4 <IfxCpu_Trap_vectorTable1_end>:
	...

Disassembly of section .traptab_tc2:

80600000 <IfxCpu_Trap_vectorTable2>:
#pragma ghs section text=".traptab_cpu2"
#endif

void IfxCpu_Trap_vectorTable2(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
80600000:	0d 00 00 02 	svlcx 
80600004:	02 f4       	mov %d4,%d15
80600006:	91 00 00 28 	movh.a %a2,32768
8060000a:	d9 22 c4 41 	lea %a2,[%a2]7428 <80001d04 <IfxCpu_Trap_memoryManagementError>>
8060000e:	dc 02       	ji %a2
80600010:	00 80       	rfe 
	...
8060001e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
80600020:	0d 00 00 02 	svlcx 
80600024:	02 f4       	mov %d4,%d15
80600026:	91 00 00 28 	movh.a %a2,32768
8060002a:	d9 22 f2 41 	lea %a2,[%a2]7474 <80001d32 <IfxCpu_Trap_internalProtectionError>>
8060002e:	dc 02       	ji %a2
80600030:	00 80       	rfe 
	...
8060003e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
80600040:	0d 00 00 02 	svlcx 
80600044:	02 f4       	mov %d4,%d15
80600046:	91 00 00 28 	movh.a %a2,32768
8060004a:	d9 22 e0 51 	lea %a2,[%a2]7520 <80001d60 <IfxCpu_Trap_instructionError>>
8060004e:	dc 02       	ji %a2
80600050:	00 80       	rfe 
	...
8060005e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
80600060:	02 f4       	mov %d4,%d15
80600062:	91 00 00 28 	movh.a %a2,32768
80600066:	d9 22 ce 61 	lea %a2,[%a2]7566 <80001d8e <IfxCpu_Trap_contextManagementError>>
8060006a:	dc 02       	ji %a2
8060006c:	00 80       	rfe 
	...
8060007e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
80600080:	0d 00 00 02 	svlcx 
80600084:	02 f4       	mov %d4,%d15
80600086:	91 00 00 28 	movh.a %a2,32768
8060008a:	d9 22 fc 61 	lea %a2,[%a2]7612 <80001dbc <IfxCpu_Trap_busError>>
8060008e:	dc 02       	ji %a2
80600090:	00 80       	rfe 
	...
8060009e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
806000a0:	0d 00 00 02 	svlcx 
806000a4:	02 f4       	mov %d4,%d15
806000a6:	91 00 00 28 	movh.a %a2,32768
806000aa:	d9 22 ea 71 	lea %a2,[%a2]7658 <80001dea <IfxCpu_Trap_assertion>>
806000ae:	dc 02       	ji %a2
806000b0:	00 80       	rfe 
	...
806000be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu2);
806000c0:	0d 00 00 02 	svlcx 
806000c4:	02 f4       	mov %d4,%d15
806000c6:	91 00 00 28 	movh.a %a2,32768
806000ca:	d9 22 f6 91 	lea %a2,[%a2]7798 <80001e76 <IfxCpu_Trap_systemCall_Cpu2>>
806000ce:	dc 02       	ji %a2
806000d0:	00 80       	rfe 
	...
806000de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
806000e0:	0d 00 00 02 	svlcx 
806000e4:	02 f4       	mov %d4,%d15
806000e6:	91 00 00 28 	movh.a %a2,32768
806000ea:	d9 22 ce b1 	lea %a2,[%a2]7886 <80001ece <IfxCpu_Trap_nonMaskableInterrupt>>
806000ee:	dc 02       	ji %a2
806000f0:	00 80       	rfe 
}
806000f2:	00 90       	ret 

806000f4 <IfxCpu_Trap_vectorTable2_end>:
	...

Disassembly of section .traptab_tc3:

80900000 <IfxCpu_Trap_vectorTable3>:
#endif


void IfxCpu_Trap_vectorTable3(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
80900000:	0d 00 00 02 	svlcx 
80900004:	02 f4       	mov %d4,%d15
80900006:	91 00 00 28 	movh.a %a2,32768
8090000a:	d9 22 c4 41 	lea %a2,[%a2]7428 <80001d04 <IfxCpu_Trap_memoryManagementError>>
8090000e:	dc 02       	ji %a2
80900010:	00 80       	rfe 
	...
8090001e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
80900020:	0d 00 00 02 	svlcx 
80900024:	02 f4       	mov %d4,%d15
80900026:	91 00 00 28 	movh.a %a2,32768
8090002a:	d9 22 f2 41 	lea %a2,[%a2]7474 <80001d32 <IfxCpu_Trap_internalProtectionError>>
8090002e:	dc 02       	ji %a2
80900030:	00 80       	rfe 
	...
8090003e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
80900040:	0d 00 00 02 	svlcx 
80900044:	02 f4       	mov %d4,%d15
80900046:	91 00 00 28 	movh.a %a2,32768
8090004a:	d9 22 e0 51 	lea %a2,[%a2]7520 <80001d60 <IfxCpu_Trap_instructionError>>
8090004e:	dc 02       	ji %a2
80900050:	00 80       	rfe 
	...
8090005e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
80900060:	02 f4       	mov %d4,%d15
80900062:	91 00 00 28 	movh.a %a2,32768
80900066:	d9 22 ce 61 	lea %a2,[%a2]7566 <80001d8e <IfxCpu_Trap_contextManagementError>>
8090006a:	dc 02       	ji %a2
8090006c:	00 80       	rfe 
	...
8090007e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
80900080:	0d 00 00 02 	svlcx 
80900084:	02 f4       	mov %d4,%d15
80900086:	91 00 00 28 	movh.a %a2,32768
8090008a:	d9 22 fc 61 	lea %a2,[%a2]7612 <80001dbc <IfxCpu_Trap_busError>>
8090008e:	dc 02       	ji %a2
80900090:	00 80       	rfe 
	...
8090009e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
809000a0:	0d 00 00 02 	svlcx 
809000a4:	02 f4       	mov %d4,%d15
809000a6:	91 00 00 28 	movh.a %a2,32768
809000aa:	d9 22 ea 71 	lea %a2,[%a2]7658 <80001dea <IfxCpu_Trap_assertion>>
809000ae:	dc 02       	ji %a2
809000b0:	00 80       	rfe 
	...
809000be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu3);
809000c0:	0d 00 00 02 	svlcx 
809000c4:	02 f4       	mov %d4,%d15
809000c6:	91 00 00 28 	movh.a %a2,32768
809000ca:	d9 22 e2 a1 	lea %a2,[%a2]7842 <80001ea2 <IfxCpu_Trap_systemCall_Cpu3>>
809000ce:	dc 02       	ji %a2
809000d0:	00 80       	rfe 
	...
809000de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
809000e0:	0d 00 00 02 	svlcx 
809000e4:	02 f4       	mov %d4,%d15
809000e6:	91 00 00 28 	movh.a %a2,32768
809000ea:	d9 22 ce b1 	lea %a2,[%a2]7886 <80001ece <IfxCpu_Trap_nonMaskableInterrupt>>
809000ee:	dc 02       	ji %a2
809000f0:	00 80       	rfe 
}
809000f2:	00 90       	ret 

809000f4 <IfxCpu_Trap_vectorTable3_end>:
	...

Disassembly of section .start_tc1:

a0300100 <_START1>:
a0300100:	91 00 03 28 	movh.a %a2,32816
a0300104:	d9 22 0c 40 	lea %a2,[%a2]268 <8030010c <__Core1_start>>
a0300108:	dc 02       	ji %a2
#endif

void _START1(void)
{
    Ifx_Ssw_jumpToFunction(__Core1_start);
}
a030010a:	00 90       	ret 

Disassembly of section .start_tc2:

a0600100 <_START2>:
a0600100:	91 00 06 28 	movh.a %a2,32864
a0600104:	d9 22 0c 40 	lea %a2,[%a2]268 <8060010c <__Core2_start>>
a0600108:	dc 02       	ji %a2
#endif

void _START2(void)
{
    Ifx_Ssw_jumpToFunction(__Core2_start);
}
a060010a:	00 90       	ret 

Disassembly of section .start_tc3:

a0900100 <_START3>:
a0900100:	91 00 09 28 	movh.a %a2,32912
a0900104:	d9 22 0c 40 	lea %a2,[%a2]268 <8090010c <__Core3_start>>
a0900108:	dc 02       	ji %a2
#endif

void _START3(void)
{
    Ifx_Ssw_jumpToFunction(__Core3_start);
}
a090010a:	00 90       	ret 

Disassembly of section .inttab_tc0_001:

802fe020 <__intvec_tc0_1>:
802fe020:	0d 00 00 02 	svlcx 
802fe024:	91 00 00 e8 	movh.a %a14,32768
802fe028:	d9 ee 8c f2 	lea %a14,[%a14]11212 <80002bcc <KERNEL_YIELD>>
802fe02c:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_002:

802fe040 <__intvec_tc0_2>:
802fe040:	0d 00 00 02 	svlcx 
802fe044:	91 00 00 e8 	movh.a %a14,32768
802fe048:	d9 ee cc 22 	lea %a14,[%a14]11404 <80002c8c <KERNEL_INTERRUPT>>
802fe04c:	dc 0e       	ji %a14

802fe04e <__intvec_tc0_2>:
802fe04e:	0d 00 00 02 	svlcx 
802fe052:	91 00 00 e8 	movh.a %a14,32768
802fe056:	d9 ee b2 34 	lea %a14,[%a14]18674 <800048f2 <canIsrTxHandler>>
802fe05a:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_003:

802fe060 <__intvec_tc0_3>:
802fe060:	0d 00 00 02 	svlcx 
802fe064:	91 00 00 e8 	movh.a %a14,32768
802fe068:	d9 ee a0 64 	lea %a14,[%a14]18848 <800049a0 <canIsrRxHandler>>
802fe06c:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_004:

802fe080 <__intvec_tc0_4>:
802fe080:	0d 00 00 02 	svlcx 
802fe084:	91 00 00 e8 	movh.a %a14,32768
802fe088:	d9 ee ac 44 	lea %a14,[%a14]18732 <8000492c <canIsrTxHandler1>>
802fe08c:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_005:

802fe0a0 <__intvec_tc0_5>:
802fe0a0:	0d 00 00 02 	svlcx 
802fe0a4:	91 00 00 e8 	movh.a %a14,32768
802fe0a8:	d9 ee ac 74 	lea %a14,[%a14]18924 <800049ec <canIsrRxHandler1>>
802fe0ac:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_006:

802fe0c0 <__intvec_tc0_6>:
802fe0c0:	0d 00 00 02 	svlcx 
802fe0c4:	91 00 00 e8 	movh.a %a14,32768
802fe0c8:	d9 ee a6 54 	lea %a14,[%a14]18790 <80004966 <canIsrTxHandler2>>
802fe0cc:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_007:

802fe0e0 <__intvec_tc0_7>:
802fe0e0:	0d 00 00 02 	svlcx 
802fe0e4:	91 00 00 e8 	movh.a %a14,32768
802fe0e8:	d9 ee b8 84 	lea %a14,[%a14]19000 <80004a38 <canIsrRxHandler2>>
802fe0ec:	dc 0e       	ji %a14

Disassembly of section .CPU0.text:

80000718 <__StartUpSoftware_Phase2>:
}


IFX_SSW_INLINE void Ifx_Ssw_jumpToFunctionWithLink(void *fun)
{
    __asm__ volatile ("jli %0" ::"a" (fun));
80000718:	91 00 00 28 	movh.a %a2,32768
8000071c:	d9 22 6a c4 	lea %a2,[%a2]18218 <8000472a <Ifx_Ssw_Pms_Init>>
80000720:	2d 02 20 00 	jli %a2
80000724:	91 00 00 28 	movh.a %a2,32768
80000728:	d9 22 90 14 	lea %a2,[%a2]18512 <80004850 <Ifx_Ssw_Pms_InitCheck>>
8000072c:	2d 02 20 00 	jli %a2
    __asm__ volatile ("ji %0" ::"a" (fun));
80000730:	91 00 00 28 	movh.a %a2,32768
80000734:	d9 22 7c c0 	lea %a2,[%a2]1852 <8000073c <__StartUpSoftware_Phase3PowerOnResetPath>>
80000738:	dc 02       	ji %a2
}
8000073a:	00 90       	ret 

8000073c <__StartUpSoftware_Phase3PowerOnResetPath>:
    IFX_SSW_INIT_CONTEXT();
8000073c:	91 40 00 a7 	movh.a %sp,28676
80000740:	d9 aa 40 89 	lea %sp,[%sp]-27136 <70039600 <__USTACK0>>
    __asm__ volatile ("dsync" : : : "memory");
80000744:	0d 00 80 04 	dsync 
{
    unsigned int  k;
    unsigned int  nxt_cxi_val = 0U;
    unsigned int *prvCsa      = csaBegin;
    unsigned int *nxtCsa      = csaBegin;
    unsigned int numOfCsa     = (((unsigned int)csaEnd - (unsigned int)csaBegin) / 64U);
80000748:	91 40 00 37 	movh.a %a3,28676
8000074c:	91 40 00 27 	movh.a %a2,28676
80000750:	d9 33 c0 09 	lea %a3,[%a3]-25600 <70039c00 <__CSA0>>
80000754:	d9 22 c0 0b 	lea %a2,[%a2]-17408 <7003bc00 <__CSA0_END>>
80000758:	01 32 20 20 	sub.a %a2,%a2,%a3
8000075c:	80 22       	mov.d %d2,%a2
8000075e:	8f a2 1f 60 	sh %d6,%d2,-6
    unsigned int *prvCsa      = csaBegin;
80000762:	40 32       	mov.aa %a2,%a3
        else
        {
            *prvCsa = nxt_cxi_val;
        }

        if (k == (numOfCsa - 3U))
80000764:	1b d6 ff 0f 	addi %d0,%d6,-3
    for (k = 0U; k < numOfCsa; k++)
80000768:	82 03       	mov %d3,0
    unsigned int *nxtCsa      = csaBegin;
8000076a:	80 32       	mov.d %d2,%a3
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
8000076c:	7b f0 00 70 	movh %d7,15
    for (k = 0U; k < numOfCsa; k++)
80000770:	df 06 2d 00 	jeq %d6,0,800007ca <__StartUpSoftware_Phase3PowerOnResetPath+0x8e>
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
80000774:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80000778:	8f 42 1f 50 	sh %d5,%d2,-12
8000077c:	26 75       	and %d5,%d7
8000077e:	a6 54       	or %d4,%d5
        if (k == 0U)
80000780:	df 03 14 00 	jeq %d3,0,800007a8 <__StartUpSoftware_Phase3PowerOnResetPath+0x6c>
            *prvCsa = nxt_cxi_val;
80000784:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
80000786:	5f 03 15 00 	jeq %d3,%d0,800007b0 <__StartUpSoftware_Phase3PowerOnResetPath+0x74>
    for (k = 0U; k < numOfCsa; k++)
8000078a:	c2 13       	add %d3,1
8000078c:	60 22       	mov.a %a2,%d2
        {
            Ifx_Ssw_MTCR(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
        }

        prvCsa  = (unsigned int *)nxtCsa;
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
8000078e:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80000792:	5f 36 17 00 	jeq %d6,%d3,800007c0 <__StartUpSoftware_Phase3PowerOnResetPath+0x84>
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80000796:	02 42       	mov %d2,%d4
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
80000798:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
8000079c:	8f 42 1f 50 	sh %d5,%d2,-12
800007a0:	26 75       	and %d5,%d7
800007a2:	a6 54       	or %d4,%d5
        if (k == 0U)
800007a4:	df 03 f0 ff 	jne %d3,0,80000784 <__StartUpSoftware_Phase3PowerOnResetPath+0x48>
            Ifx_Ssw_MTCR(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
800007a8:	cd 84 e3 0f 	mtcr $fcx,%d4
        if (k == (numOfCsa - 3U))
800007ac:	5f 03 ef ff 	jne %d3,%d0,8000078a <__StartUpSoftware_Phase3PowerOnResetPath+0x4e>
            Ifx_Ssw_MTCR(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
800007b0:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
800007b4:	c2 13       	add %d3,1
800007b6:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
800007b8:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
800007bc:	5f 36 ed ff 	jne %d6,%d3,80000796 <__StartUpSoftware_Phase3PowerOnResetPath+0x5a>
800007c0:	1b f6 ff 2f 	addi %d2,%d6,-1
800007c4:	06 62       	sh %d2,6
800007c6:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    }

    *prvCsa = 0U;                       /* Store null pointer in last CSA (= very first time!) */
800007ca:	82 02       	mov %d2,0
800007cc:	74 22       	st.w [%a2],%d2
800007ce:	0d 00 80 04 	dsync 
    __asm__ volatile ("isync" : : : "memory");
800007d2:	0d 00 c0 04 	isync 
    __asm__ volatile ("ji %0" ::"a" (fun));
800007d6:	91 00 00 28 	movh.a %a2,32768
800007da:	d9 22 b2 20 	lea %a2,[%a2]2226 <800008b2 <__StartUpSoftware_Phase4>>
800007de:	dc 02       	ji %a2
}
800007e0:	00 90       	ret 

800007e2 <__StartUpSoftware_Phase3ApplicationResetPath>:
    IFX_SSW_INIT_CONTEXT();
800007e2:	91 40 00 a7 	movh.a %sp,28676
800007e6:	d9 aa 40 89 	lea %sp,[%sp]-27136 <70039600 <__USTACK0>>
    __asm__ volatile ("dsync" : : : "memory");
800007ea:	0d 00 80 04 	dsync 
    unsigned int numOfCsa     = (((unsigned int)csaEnd - (unsigned int)csaBegin) / 64U);
800007ee:	91 40 00 37 	movh.a %a3,28676
800007f2:	91 40 00 27 	movh.a %a2,28676
800007f6:	d9 33 c0 09 	lea %a3,[%a3]-25600 <70039c00 <__CSA0>>
800007fa:	d9 22 c0 0b 	lea %a2,[%a2]-17408 <7003bc00 <__CSA0_END>>
800007fe:	01 32 20 20 	sub.a %a2,%a2,%a3
80000802:	80 22       	mov.d %d2,%a2
80000804:	8f a2 1f 60 	sh %d6,%d2,-6
    unsigned int *prvCsa      = csaBegin;
80000808:	40 32       	mov.aa %a2,%a3
        if (k == (numOfCsa - 3U))
8000080a:	1b d6 ff 0f 	addi %d0,%d6,-3
    for (k = 0U; k < numOfCsa; k++)
8000080e:	82 03       	mov %d3,0
    unsigned int *nxtCsa      = csaBegin;
80000810:	80 32       	mov.d %d2,%a3
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80000812:	7b f0 00 70 	movh %d7,15
    for (k = 0U; k < numOfCsa; k++)
80000816:	df 06 2d 00 	jeq %d6,0,80000870 <__StartUpSoftware_Phase3ApplicationResetPath+0x8e>
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
8000081a:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
8000081e:	8f 42 1f 50 	sh %d5,%d2,-12
80000822:	26 75       	and %d5,%d7
80000824:	a6 54       	or %d4,%d5
        if (k == 0U)
80000826:	df 03 14 00 	jeq %d3,0,8000084e <__StartUpSoftware_Phase3ApplicationResetPath+0x6c>
            *prvCsa = nxt_cxi_val;
8000082a:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
8000082c:	5f 03 15 00 	jeq %d3,%d0,80000856 <__StartUpSoftware_Phase3ApplicationResetPath+0x74>
    for (k = 0U; k < numOfCsa; k++)
80000830:	c2 13       	add %d3,1
80000832:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80000834:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80000838:	5f 36 17 00 	jeq %d6,%d3,80000866 <__StartUpSoftware_Phase3ApplicationResetPath+0x84>
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
8000083c:	02 42       	mov %d2,%d4
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
8000083e:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80000842:	8f 42 1f 50 	sh %d5,%d2,-12
80000846:	26 75       	and %d5,%d7
80000848:	a6 54       	or %d4,%d5
        if (k == 0U)
8000084a:	df 03 f0 ff 	jne %d3,0,8000082a <__StartUpSoftware_Phase3ApplicationResetPath+0x48>
            Ifx_Ssw_MTCR(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
8000084e:	cd 84 e3 0f 	mtcr $fcx,%d4
        if (k == (numOfCsa - 3U))
80000852:	5f 03 ef ff 	jne %d3,%d0,80000830 <__StartUpSoftware_Phase3ApplicationResetPath+0x4e>
            Ifx_Ssw_MTCR(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
80000856:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
8000085a:	c2 13       	add %d3,1
8000085c:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
8000085e:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80000862:	5f 36 ed ff 	jne %d6,%d3,8000083c <__StartUpSoftware_Phase3ApplicationResetPath+0x5a>
80000866:	1b f6 ff 2f 	addi %d2,%d6,-1
8000086a:	06 62       	sh %d2,6
8000086c:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    *prvCsa = 0U;                       /* Store null pointer in last CSA (= very first time!) */
80000870:	82 02       	mov %d2,0
80000872:	74 22       	st.w [%a2],%d2
80000874:	0d 00 80 04 	dsync 
    __asm__ volatile ("isync" : : : "memory");
80000878:	0d 00 c0 04 	isync 
    __asm__ volatile ("ji %0" ::"a" (fun));
8000087c:	91 00 00 28 	movh.a %a2,32768
80000880:	d9 22 88 20 	lea %a2,[%a2]2184 <80000888 <__StartUpSoftware_Phase5>>
80000884:	dc 02       	ji %a2
}
80000886:	00 90       	ret 

80000888 <__StartUpSoftware_Phase5>:
80000888:	91 00 00 28 	movh.a %a2,32768
8000088c:	d9 22 94 20 	lea %a2,[%a2]2196 <80000894 <__StartUpSoftware_Phase6>>
80000890:	dc 02       	ji %a2
}
80000892:	00 90       	ret 

80000894 <__StartUpSoftware_Phase6>:
    Ifx_Ssw_startCore(&MODULE_CPU1, (unsigned int)__START(1));           /*The status returned by function call is ignored */
80000894:	91 00 03 2a 	movh.a %a2,41008
80000898:	80 22       	mov.d %d2,%a2
8000089a:	1b 02 10 40 	addi %d4,%d2,256
8000089e:	91 20 88 4f 	movh.a %a4,63618
800008a2:	6d 00 c6 0d 	call 8000242e <Ifx_Ssw_startCore>
800008a6:	91 00 00 28 	movh.a %a2,32768
800008aa:	d9 22 84 60 	lea %a2,[%a2]2436 <80000984 <__Core0_start>>
800008ae:	dc 02       	ji %a2
}
800008b0:	00 90       	ret 

800008b2 <__StartUpSoftware_Phase4>:
    password  = watchdog->CON0.B.PW;
800008b2:	91 30 00 4f 	movh.a %a4,61443
800008b6:	19 44 0c 96 	ld.w %d4,[%a4]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
    password  = watchdog->CON0.B.PW;
800008ba:	91 30 00 2f 	movh.a %a2,61443
800008be:	19 28 28 a6 	ld.w %d8,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
    password  = watchdog->CON0.B.PW;
800008c2:	37 04 6e 41 	extr.u %d4,%d4,2,14
800008c6:	d9 44 0c 96 	lea %a4,[%a4]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
    password  = watchdog->CON0.B.PW;
800008ca:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
        Ifx_Ssw_serviceCpuWatchdog(&MODULE_SCU.WDTCPU[0], cpuWdtPassword);
800008ce:	8f f4 83 41 	xor %d4,%d4,63
800008d2:	37 08 6e 81 	extr.u %d8,%d8,2,14
800008d6:	6d 00 10 0d 	call 800022f6 <Ifx_Ssw_serviceCpuWatchdog>
        Ifx_Ssw_serviceSafetyWatchdog(safetyWdtPassword);
800008da:	8f f8 83 41 	xor %d4,%d8,63
800008de:	6d 00 23 0d 	call 80002324 <Ifx_Ssw_serviceSafetyWatchdog>
    IFX_CFG_SSW_CALLOUT_PLL_INIT();
800008e2:	91 00 00 48 	movh.a %a4,32768
800008e6:	d9 44 18 90 	lea %a4,[%a4]600 <80000258 <IfxScuCcu_defaultClockConfig>>
800008ea:	6d 00 3c 04 	call 80001162 <IfxScuCcu_init>
800008ee:	df 12 03 80 	jne %d2,1,800008f4 <__StartUpSoftware_Phase4+0x42>

/** Insert DEBUG instruction
 */
IFX_INLINE void Ifx__debug(void)
{
    __asm__ volatile ("debug" : : : "memory");
800008f2:	00 a0       	debug 
800008f4:	91 00 00 28 	movh.a %a2,32768
800008f8:	d9 22 88 20 	lea %a2,[%a2]2184 <80000888 <__StartUpSoftware_Phase5>>
800008fc:	dc 02       	ji %a2
}
800008fe:	00 90       	ret 

80000900 <__StartUpSoftware>:
    Ifx_Ssw_setAddressReg(a1, __SDATA2(0));
80000900:	91 10 00 18 	movh.a %a1,32769
80000904:	d9 11 00 08 	lea %a1,[%a1]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_MTCR(CPU_PSW, IFX_CFG_SSW_PSW_DEFAULT);
80000908:	3b 00 98 20 	mov %d2,2432
8000090c:	cd 42 e0 0f 	mtcr $psw,%d2
    unsigned int  tempValue = SCU_RSTSTAT.U;
80000910:	91 30 00 2f 	movh.a %a2,61443
80000914:	19 22 10 16 	ld.w %d2,[%a2]24656 <f0036050 <bmhd_3_copy+0x40c34a50>>
    if ((tempValue & IFX_SSW_POWERONRESET_MASK) > 0U)
80000918:	7b d0 38 31 	movh %d3,5005
8000091c:	26 23       	and %d3,%d2
    unsigned int  tempValue = SCU_RSTSTAT.U;
8000091e:	d9 22 10 16 	lea %a2,[%a2]24656 <f0036050 <bmhd_3_copy+0x40c34a50>>
    if ((tempValue & IFX_SSW_POWERONRESET_MASK) > 0U)
80000922:	df 03 15 80 	jne %d3,0,8000094c <__StartUpSoftware+0x4c>
    else if ((tempValue & IFX_SSW_APPLICATIONRESET_MASK) > 0U)
80000926:	8f b2 1f 31 	and %d3,%d2,507
8000092a:	df 03 17 00 	jeq %d3,0,80000958 <__StartUpSoftware+0x58>
        tempValue = (SCU_RSTCON.U >> ((31U - Ifx_Ssw_CLZ(tempValue)) << 1U)) & 3U;
8000092e:	91 30 00 2f 	movh.a %a2,61443
80000932:	0f 03 b0 21 	clz %d2,%d3
80000936:	8b f2 01 21 	rsub %d2,%d2,31
8000093a:	19 23 18 16 	ld.w %d3,[%a2]24664 <f0036058 <bmhd_3_copy+0x40c34a58>>
8000093e:	06 12       	sh %d2,1
80000940:	57 03 62 22 	extr.u %d2,%d3,%d2,2
80000944:	d9 22 18 16 	lea %a2,[%a2]24664 <f0036058 <bmhd_3_copy+0x40c34a58>>
        if (tempValue == IFX_SSW_APPLICATIONRESET)
80000948:	df 22 0a 00 	jeq %d2,2,8000095c <__StartUpSoftware+0x5c>
8000094c:	91 00 00 28 	movh.a %a2,32768
80000950:	d9 22 58 c0 	lea %a2,[%a2]1816 <80000718 <__StartUpSoftware_Phase2>>
80000954:	dc 02       	ji %a2
}
80000956:	00 90       	ret 
    else if (((unsigned int)tempValue & ((unsigned int)IFX_SCU_RSTSTAT_CB3_MSK << IFX_SCU_RSTSTAT_CB3_OFF)))
80000958:	ef 42 08 00 	jz.t %d2,20,80000968 <__StartUpSoftware+0x68>
    __asm__ volatile ("ji %0" ::"a" (fun));
8000095c:	91 00 00 28 	movh.a %a2,32768
80000960:	d9 22 62 f0 	lea %a2,[%a2]2018 <800007e2 <__StartUpSoftware_Phase3ApplicationResetPath>>
80000964:	dc 02       	ji %a2
}
80000966:	00 90       	ret 
    else if (CPU0_KRST0.B.RSTSTAT != 0)   /*CPU0 KRST status */
80000968:	91 10 88 2f 	movh.a %a2,63617
8000096c:	19 22 00 0d 	ld.w %d2,[%a2]-12288 <f880d000 <bmhd_3_copy+0x4940ba00>>
80000970:	d9 22 00 0d 	lea %a2,[%a2]-12288 <f880d000 <bmhd_3_copy+0x4940ba00>>
80000974:	37 02 e2 20 	extr.u %d2,%d2,1,2
80000978:	df 02 f2 ff 	jne %d2,0,8000095c <__StartUpSoftware+0x5c>
8000097c:	1d ff e8 ff 	j 8000094c <__StartUpSoftware+0x4c>

80000980 <hardware_init_hook>:
{}
80000980:	00 90       	ret 

80000982 <software_init_hook>:
{}
80000982:	00 90       	ret 

80000984 <__Core0_start>:
    password  = watchdog->CON0.B.PW;
80000984:	91 30 00 2f 	movh.a %a2,61443
    password  = watchdog->CON0.B.PW;
80000988:	91 30 00 3f 	movh.a %a3,61443
    password  = watchdog->CON0.B.PW;
8000098c:	19 23 0c 96 	ld.w %d3,[%a2]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
    password  = watchdog->CON0.B.PW;
80000990:	19 32 28 a6 	ld.w %d2,[%a3]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
    password  = watchdog->CON0.B.PW;
80000994:	37 03 6e 31 	extr.u %d3,%d3,2,14
    password  = watchdog->CON0.B.PW;
80000998:	37 02 6e 21 	extr.u %d2,%d2,2,14
    if (watchdog->CON0.B.LCK)
8000099c:	19 24 0c 96 	ld.w %d4,[%a2]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
800009a0:	8f f3 83 81 	xor %d8,%d3,63
    password  = watchdog->CON0.B.PW;
800009a4:	d9 22 0c 96 	lea %a2,[%a2]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
    password  = watchdog->CON0.B.PW;
800009a8:	d9 33 28 a6 	lea %a3,[%a3]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800009ac:	8f f2 83 91 	xor %d9,%d2,63
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800009b0:	8f 28 00 20 	sh %d2,%d8,2
    if (watchdog->CON0.B.LCK)
800009b4:	6f 14 0b 00 	jz.t %d4,1,800009ca <__Core0_start+0x46>
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800009b8:	54 23       	ld.w %d3,[%a2]
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800009ba:	8f 28 00 20 	sh %d2,%d8,2
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800009be:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800009c2:	a6 23       	or %d3,%d2
800009c4:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800009c8:	74 23       	st.w [%a2],%d3
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800009ca:	91 30 00 2f 	movh.a %a2,61443
800009ce:	19 24 0c 96 	ld.w %d4,[%a2]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
800009d2:	d9 22 0c 96 	lea %a2,[%a2]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
800009d6:	b7 04 10 40 	insert %d4,%d4,0,0,16
        Ifx_Ssw_MTCR(CPU_PCON0, pcon0.U);
800009da:	82 03       	mov %d3,0
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800009dc:	a6 24       	or %d4,%d2
800009de:	8f 24 40 41 	or %d4,%d4,2
    watchdog->CON0.U = ((unsigned int)0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800009e2:	74 24       	st.w [%a2],%d4
    watchdog->CON0.U;
800009e4:	54 24       	ld.w %d4,[%a2]
800009e6:	cd c3 20 09 	mtcr $pcon0,%d3
    __asm__ volatile ("isync" : : : "memory");
800009ea:	0d 00 c0 04 	isync 
        Ifx_Ssw_MTCR(CPU_DCON0, dcon0.U);
800009ee:	cd 03 04 09 	mtcr $dcon0,%d3
800009f2:	0d 00 c0 04 	isync 
    Ifx_Ssw_setAddressReg(a0, __SDATA1(0));
800009f6:	91 10 00 07 	movh.a %a0,28673
800009fa:	d9 00 00 08 	lea %a0,[%a0]-32768 <70008000 <_SMALL_DATA_>>
    Ifx_Ssw_setAddressReg(a8, __SDATA3(0));
800009fe:	91 10 00 88 	movh.a %a8,32769
80000a02:	d9 88 00 08 	lea %a8,[%a8]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a9, __SDATA4(0));
80000a06:	91 10 00 99 	movh.a %a9,36865
80000a0a:	d9 99 00 08 	lea %a9,[%a9]-32768 <90008000 <_SMALL_DATA4_>>
    Ifx_Ssw_MTCR(CPU_BTV, (unsigned int)__TRAPTAB(0));
80000a0e:	91 00 00 38 	movh.a %a3,32768
80000a12:	80 33       	mov.d %d3,%a3
80000a14:	1b 03 10 30 	addi %d3,%d3,256
80000a18:	cd 43 e2 0f 	mtcr $btv,%d3
    Ifx_Ssw_MTCR(CPU_BIV, (unsigned int)__INTTAB(0));
80000a1c:	91 00 03 38 	movh.a %a3,32816
80000a20:	80 33       	mov.d %d3,%a3
80000a22:	1b 03 00 3e 	addi %d3,%d3,-8192
80000a26:	cd 03 e2 0f 	mtcr $biv,%d3
    Ifx_Ssw_MTCR(CPU_ISP, (unsigned int)__ISTACK(0));
80000a2a:	91 40 00 37 	movh.a %a3,28676
80000a2e:	80 33       	mov.d %d3,%a3
80000a30:	1b 03 b0 39 	addi %d3,%d3,-25856
80000a34:	cd 83 e2 0f 	mtcr $isp,%d3
    if (watchdog->CON0.B.LCK)
80000a38:	54 23       	ld.w %d3,[%a2]
80000a3a:	6f 13 09 00 	jz.t %d3,1,80000a4c <__Core0_start+0xc8>
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80000a3e:	54 23       	ld.w %d3,[%a2]
80000a40:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80000a44:	a6 23       	or %d3,%d2
80000a46:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80000a4a:	74 23       	st.w [%a2],%d3
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80000a4c:	91 30 00 cf 	movh.a %a12,61443
80000a50:	19 c3 0c 96 	ld.w %d3,[%a12]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
80000a54:	d9 cc 0c 96 	lea %a12,[%a12]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
80000a58:	b7 03 10 30 	insert %d3,%d3,0,0,16
    Ifx_Ssw_disableCpuWatchdog(&MODULE_SCU.WDTCPU[0], cpuWdtPassword);
80000a5c:	40 c4       	mov.aa %a4,%a12
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80000a5e:	a6 32       	or %d2,%d3
80000a60:	8f 32 40 21 	or %d2,%d2,3
80000a64:	02 84       	mov %d4,%d8
    watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80000a66:	74 c2       	st.w [%a12],%d2
    watchdog->CON0.U;
80000a68:	54 c2       	ld.w %d2,[%a12]
80000a6a:	6d 00 7c 0c 	call 80002362 <Ifx_Ssw_disableCpuWatchdog>
    Ifx_Ssw_disableSafetyWatchdog(safetyWdtPassword);
80000a6e:	02 94       	mov %d4,%d9
80000a70:	6d 00 bb 0c 	call 800023e6 <Ifx_Ssw_disableSafetyWatchdog>
	hardware_init_hook();
80000a74:	6d ff 86 ff 	call 80000980 <hardware_init_hook>
	(void)Ifx_Ssw_doCppInit();
80000a78:	6d 00 4d 0d 	call 80002512 <Ifx_Ssw_doCppInit>
	software_init_hook();
80000a7c:	6d ff 83 ff 	call 80000982 <software_init_hook>
    Ifx_Ssw_enableSafetyWatchdog(safetyWdtPassword);
80000a80:	02 94       	mov %d4,%d9
80000a82:	6d 00 c4 0c 	call 8000240a <Ifx_Ssw_enableSafetyWatchdog>
    Ifx_Ssw_enableCpuWatchdog(&MODULE_SCU.WDTCPU[0], cpuWdtPassword);
80000a86:	02 84       	mov %d4,%d8
80000a88:	40 c4       	mov.aa %a4,%a12
80000a8a:	6d 00 8d 0c 	call 800023a4 <Ifx_Ssw_enableCpuWatchdog>
    __asm__ volatile ("ji %0" ::"a" (fun));
80000a8e:	91 00 00 28 	movh.a %a2,32768
80000a92:	d9 22 9e a0 	lea %a2,[%a2]2718 <80000a9e <core0_main>>
80000a96:	dc 02       	ji %a2

80000a98 <x>:
    __asm__ volatile ("ji %a11");
}

IFX_SSW_INLINE void Ifx_Ssw_infiniteLoop(void)
{
    __asm("x: loopu\t x");
80000a98:	fd 00 00 80 	loopu 80000a98 <x>
}
80000a9c:	00 90       	ret 

80000a9e <core0_main>:
IFX_ALIGN(4) IfxCpu_syncEvent g_cpuSyncEvent = 0;



void core0_main(void)
{
80000a9e:	40 ae       	mov.aa %a14,%sp
}


IFX_INLINE void IfxCpu_enableInterrupts(void)
{
    __enable();
80000aa0:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
80000aa4:	6d 00 64 08 	call 80001b6c <IfxScuWdt_getCpuWatchdogPassword>
80000aa8:	02 24       	mov %d4,%d2
80000aaa:	6d 00 d3 07 	call 80001a50 <IfxScuWdt_disableCpuWatchdog>
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
80000aae:	6d 00 71 08 	call 80001b90 <IfxScuWdt_getSafetyWatchdogPassword>
80000ab2:	02 24       	mov %d4,%d2
80000ab4:	6d 00 0d 08 	call 80001ace <IfxScuWdt_disableSafetyWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
80000ab8:	91 10 00 c7 	movh.a %a12,28673
80000abc:	d9 cc 34 50 	lea %a12,[%a12]372 <70010174 <g_cpuSyncEvent>>
80000ac0:	40 c4       	mov.aa %a4,%a12
80000ac2:	6d 00 5e 0a 	call 80001f7e <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
80000ac6:	82 14       	mov %d4,1
80000ac8:	40 c4       	mov.aa %a4,%a12
80000aca:	6d 00 18 0a 	call 80001efa <IfxCpu_waitEvent>
    
    initLeds();
80000ace:	6d 00 db 1f 	call 80004a84 <initLeds>
//    initMcmcan1();
//    initMcmcan2();
//    initLeds();
    //transmitCanMessage();
    //IfxPort_setPinState(g_led1.port, g_led1.pinIndex,  IfxPort_State_toggled);
    xTaskCreate(LDE1, "APP LED1", configMINIMAL_STACK_SIZE, NULL, 5, NULL);
80000ad2:	a0 07       	mov.a %a7,0
80000ad4:	82 55       	mov %d5,5
80000ad6:	a0 06       	mov.a %a6,0
80000ad8:	3b 00 08 40 	mov %d4,128
80000adc:	91 00 00 58 	movh.a %a5,32768
80000ae0:	d9 55 00 80 	lea %a5,[%a5]512 <80000200 <IfxCpu_Trap_vectorTable0_end+0xc>>
80000ae4:	91 00 00 48 	movh.a %a4,32768
80000ae8:	d9 44 b8 24 	lea %a4,[%a4]18616 <800048b8 <LDE1>>
80000aec:	6d 00 be 19 	call 80003e68 <xTaskCreate>

    /* Create LED2 app task */
    //xTaskCreate(LDE2, "APP LED2", configMINIMAL_STACK_SIZE, NULL, 11, NULL);

    /* Start the scheduler */
    vTaskStartScheduler();
80000af0:	6d 00 f1 19 	call 80003ed2 <vTaskStartScheduler>

    while(1)
80000af4:	1d 00 00 00 	j 80000af4 <core0_main+0x56>

Disassembly of section .init:

80000af8 <_init>:
80000af8:	6d 00 70 00 	call 80000bd8 <frame_dummy>
80000afc:	6d 00 11 25 	call 8000551e <__do_global_ctors_aux>
80000b00:	00 90       	ret 
80000b02:	00 00       	nop 
80000b04:	00 00       	nop 
	...

Disassembly of section .fini:

80000b08 <_fini>:
80000b08:	6d 00 36 00 	call 80000b74 <__do_global_dtors_aux>
80000b0c:	00 90       	ret 
	...

Disassembly of section .CPU1.text:

8030010c <__Core1_start>:
    password  = watchdog->CON0.B.PW;
8030010c:	91 30 00 2f 	movh.a %a2,61443
80300110:	d9 22 18 96 	lea %a2,[%a2]25176 <f0036258 <bmhd_3_copy+0x40c34c58>>
    unsigned int   stmCountBegin = STM0_TIM0.U;     /* it is necessary to get this value to have minimum 100uS delay in subsequent CPU start */
80300114:	85 f8 10 01 	ld.w %d8,f0001010 <bmhd_3_copy+0x40bffa10>
80300118:	54 22       	ld.w %d2,[%a2]
8030011a:	37 02 6e 21 	extr.u %d2,%d2,2,14
    password ^= IFX_SSW_WDT_PASSWORD_INVERT_MSK;
8030011e:	8f f2 83 21 	xor %d2,%d2,63
    Ifx_Ssw_setAddressReg(sp, __USTACK(1));
80300122:	91 40 00 a6 	movh.a %sp,24580
80300126:	d9 aa 40 89 	lea %sp,[%sp]-27136 <60039600 <__USTACK1>>
    __asm__ volatile ("dsync" : : : "memory");
8030012a:	0d 00 80 04 	dsync 
    Ifx_Ssw_MTCR(CPU_PSW, IFX_CFG_SSW_PSW_DEFAULT);
8030012e:	3b 00 98 30 	mov %d3,2432
80300132:	cd 43 e0 0f 	mtcr $psw,%d3
    if (watchdog->CON0.B.LCK)
80300136:	54 23       	ld.w %d3,[%a2]
80300138:	6f 13 c7 80 	jnz.t %d3,1,803002c6 <x+0x6>
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8030013c:	06 22       	sh %d2,2
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8030013e:	91 30 00 2f 	movh.a %a2,61443
80300142:	19 24 18 96 	ld.w %d4,[%a2]25176 <f0036258 <bmhd_3_copy+0x40c34c58>>
80300146:	d9 22 18 96 	lea %a2,[%a2]25176 <f0036258 <bmhd_3_copy+0x40c34c58>>
8030014a:	b7 04 10 40 	insert %d4,%d4,0,0,16
        Ifx_Ssw_MTCR(CPU_PCON0, pcon0.U);
8030014e:	82 03       	mov %d3,0
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80300150:	a6 24       	or %d4,%d2
80300152:	8f 24 40 41 	or %d4,%d4,2
    watchdog->CON0.U = ((unsigned int)0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80300156:	74 24       	st.w [%a2],%d4
    watchdog->CON0.U;
80300158:	54 24       	ld.w %d4,[%a2]
8030015a:	cd c3 20 09 	mtcr $pcon0,%d3
    __asm__ volatile ("isync" : : : "memory");
8030015e:	0d 00 c0 04 	isync 
        Ifx_Ssw_MTCR(CPU_DCON0, dcon0.U);
80300162:	cd 03 04 09 	mtcr $dcon0,%d3
80300166:	0d 00 c0 04 	isync 
    Ifx_Ssw_MTCR(CPU_BTV, (unsigned int)__TRAPTAB(1));
8030016a:	91 00 03 38 	movh.a %a3,32816
8030016e:	80 33       	mov.d %d3,%a3
80300170:	1b 03 00 30 	addi %d3,%d3,0
80300174:	cd 43 e2 0f 	mtcr $btv,%d3
    Ifx_Ssw_MTCR(CPU_BIV, (unsigned int)__INTTAB(1));
80300178:	91 00 06 38 	movh.a %a3,32864
8030017c:	80 33       	mov.d %d3,%a3
8030017e:	1b 03 00 3e 	addi %d3,%d3,-8192
80300182:	cd 03 e2 0f 	mtcr $biv,%d3
    Ifx_Ssw_MTCR(CPU_ISP, (unsigned int)__ISTACK(1));
80300186:	91 40 00 36 	movh.a %a3,24580
8030018a:	80 33       	mov.d %d3,%a3
8030018c:	1b 03 b0 39 	addi %d3,%d3,-25856
80300190:	cd 83 e2 0f 	mtcr $isp,%d3
    if (watchdog->CON0.B.LCK)
80300194:	54 23       	ld.w %d3,[%a2]
80300196:	6f 13 09 00 	jz.t %d3,1,803001a8 <__Core1_start+0x9c>
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8030019a:	54 23       	ld.w %d3,[%a2]
8030019c:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
803001a0:	a6 23       	or %d3,%d2
803001a2:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
803001a6:	74 23       	st.w [%a2],%d3
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
803001a8:	91 30 00 2f 	movh.a %a2,61443
803001ac:	19 23 18 96 	ld.w %d3,[%a2]25176 <f0036258 <bmhd_3_copy+0x40c34c58>>
803001b0:	d9 22 18 96 	lea %a2,[%a2]25176 <f0036258 <bmhd_3_copy+0x40c34c58>>
803001b4:	b7 03 10 30 	insert %d3,%d3,0,0,16
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
803001b8:	a6 32       	or %d2,%d3
803001ba:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
803001be:	74 22       	st.w [%a2],%d2
    watchdog->CON0.U;
803001c0:	54 22       	ld.w %d2,[%a2]
    Ifx_Ssw_setAddressReg(a0, __SDATA1(1));
803001c2:	91 10 00 07 	movh.a %a0,28673
803001c6:	d9 00 00 08 	lea %a0,[%a0]-32768 <70008000 <_SMALL_DATA_>>
    Ifx_Ssw_setAddressReg(a1, __SDATA2(1));
803001ca:	91 10 00 18 	movh.a %a1,32769
803001ce:	d9 11 00 08 	lea %a1,[%a1]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a8, __SDATA3(1));
803001d2:	91 10 00 88 	movh.a %a8,32769
803001d6:	d9 88 00 08 	lea %a8,[%a8]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a9, __SDATA4(1));
803001da:	91 10 00 99 	movh.a %a9,36865
803001de:	d9 99 00 08 	lea %a9,[%a9]-32768 <90008000 <_SMALL_DATA4_>>
    unsigned int numOfCsa     = (((unsigned int)csaEnd - (unsigned int)csaBegin) / 64U);
803001e2:	91 40 00 36 	movh.a %a3,24580
803001e6:	91 40 00 26 	movh.a %a2,24580
803001ea:	d9 33 c0 09 	lea %a3,[%a3]-25600 <60039c00 <__CSA1>>
803001ee:	d9 22 c0 0b 	lea %a2,[%a2]-17408 <6003bc00 <__CSA1_END>>
803001f2:	01 32 20 20 	sub.a %a2,%a2,%a3
803001f6:	80 22       	mov.d %d2,%a2
803001f8:	8f a2 1f 60 	sh %d6,%d2,-6
    unsigned int *prvCsa      = csaBegin;
803001fc:	40 32       	mov.aa %a2,%a3
        if (k == (numOfCsa - 3U))
803001fe:	1b d6 ff 0f 	addi %d0,%d6,-3
    for (k = 0U; k < numOfCsa; k++)
80300202:	82 03       	mov %d3,0
    unsigned int *nxtCsa      = csaBegin;
80300204:	80 32       	mov.d %d2,%a3
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80300206:	7b f0 00 70 	movh %d7,15
    for (k = 0U; k < numOfCsa; k++)
8030020a:	df 06 2d 00 	jeq %d6,0,80300264 <__Core1_start+0x158>
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
8030020e:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80300212:	8f 42 1f 50 	sh %d5,%d2,-12
80300216:	26 75       	and %d5,%d7
80300218:	a6 54       	or %d4,%d5
        if (k == 0U)
8030021a:	df 03 14 00 	jeq %d3,0,80300242 <__Core1_start+0x136>
            *prvCsa = nxt_cxi_val;
8030021e:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
80300220:	5f 03 15 00 	jeq %d3,%d0,8030024a <__Core1_start+0x13e>
    for (k = 0U; k < numOfCsa; k++)
80300224:	c2 13       	add %d3,1
80300226:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80300228:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
8030022c:	5f 36 17 00 	jeq %d6,%d3,8030025a <__Core1_start+0x14e>
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80300230:	02 42       	mov %d2,%d4
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
80300232:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80300236:	8f 42 1f 50 	sh %d5,%d2,-12
8030023a:	26 75       	and %d5,%d7
8030023c:	a6 54       	or %d4,%d5
        if (k == 0U)
8030023e:	df 03 f0 ff 	jne %d3,0,8030021e <__Core1_start+0x112>
            Ifx_Ssw_MTCR(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
80300242:	cd 84 e3 0f 	mtcr $fcx,%d4
        if (k == (numOfCsa - 3U))
80300246:	5f 03 ef ff 	jne %d3,%d0,80300224 <__Core1_start+0x118>
            Ifx_Ssw_MTCR(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
8030024a:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
8030024e:	c2 13       	add %d3,1
80300250:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80300252:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80300256:	5f 36 ed ff 	jne %d6,%d3,80300230 <__Core1_start+0x124>
8030025a:	1b f6 ff 2f 	addi %d2,%d6,-1
8030025e:	06 62       	sh %d2,6
80300260:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    *prvCsa = 0U;                       /* Store null pointer in last CSA (= very first time!) */
80300264:	82 02       	mov %d2,0
80300266:	74 22       	st.w [%a2],%d2
    __asm__ volatile ("dsync" : : : "memory");
80300268:	0d 00 80 04 	dsync 
    __asm__ volatile ("isync" : : : "memory");
8030026c:	0d 00 c0 04 	isync 
    stmCount = (unsigned int)(Ifx_Ssw_getStmFrequency() * IFX_CFG_SSW_STARTCPU_WAIT_TIME_IN_SECONDS);
80300270:	6d e8 fd 10 	call 8000246a <Ifx_Ssw_getStmFrequency>
80300274:	02 24       	mov %d4,%d2
80300276:	6d e8 98 24 	call 80004ba6 <__extendsfdf2>
8030027a:	0b 23 10 48 	mov %e4,%d3,%d2
8030027e:	7b c0 b1 6e 	movh %d6,60188
80300282:	7b a0 f1 73 	movh %d7,16154
80300286:	1b d6 32 64 	addi %d6,%d6,17197
8030028a:	1b 27 6e 73 	addi %d7,%d7,14050
8030028e:	6d e8 f4 25 	call 80004e76 <__muldf3>
80300292:	0b 23 10 48 	mov %e4,%d3,%d2
80300296:	6d e8 6c 24 	call 80004b6e <__fixunsdfsi>
    while ((unsigned int)(STM0_TIM0.U - stmCountBegin) < stmCount)
8030029a:	85 f3 10 01 	ld.w %d3,f0001010 <bmhd_3_copy+0x40bffa10>
8030029e:	a2 83       	sub %d3,%d8
803002a0:	3f 23 fd ff 	jlt.u %d3,%d2,8030029a <__Core1_start+0x18e>
    (void)Ifx_Ssw_startCore(&MODULE_CPU2, (unsigned int)__START(2));       /*The status returned by function call is ignored */
803002a4:	91 00 06 2a 	movh.a %a2,41056
803002a8:	80 22       	mov.d %d2,%a2
803002aa:	1b 02 10 40 	addi %d4,%d2,256
803002ae:	91 40 88 4f 	movh.a %a4,63620
803002b2:	6d e8 be 10 	call 8000242e <Ifx_Ssw_startCore>
    __asm__ volatile ("ji %0" ::"a" (fun));
803002b6:	91 00 03 28 	movh.a %a2,32816
803002ba:	d9 22 1a b0 	lea %a2,[%a2]730 <803002da <core1_main>>
803002be:	dc 02       	ji %a2

803002c0 <x>:
    __asm("x: loopu\t x");
803002c0:	fd 00 00 80 	loopu 803002c0 <x>
}
803002c4:	00 90       	ret 
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
803002c6:	54 23       	ld.w %d3,[%a2]
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
803002c8:	06 22       	sh %d2,2
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
803002ca:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
803002ce:	a6 23       	or %d3,%d2
803002d0:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
803002d4:	74 23       	st.w [%a2],%d3
803002d6:	1d ff 34 ff 	j 8030013e <__Core1_start+0x32>

803002da <core1_main>:
#include "IfxScuWdt.h"

extern IfxCpu_syncEvent g_cpuSyncEvent;

void core1_main(void)
{
803002da:	40 ae       	mov.aa %a14,%sp
803002dc:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG1 IS DISABLED HERE!!
     * Enable the watchdog and service it periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
803002e0:	6d e8 46 0c 	call 80001b6c <IfxScuWdt_getCpuWatchdogPassword>
803002e4:	02 24       	mov %d4,%d2
803002e6:	6d e8 b5 0b 	call 80001a50 <IfxScuWdt_disableCpuWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
803002ea:	91 10 00 c7 	movh.a %a12,28673
803002ee:	d9 cc 34 50 	lea %a12,[%a12]372 <70010174 <g_cpuSyncEvent>>
803002f2:	40 c4       	mov.aa %a4,%a12
803002f4:	6d e8 45 0e 	call 80001f7e <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
803002f8:	82 14       	mov %d4,1
803002fa:	40 c4       	mov.aa %a4,%a12
803002fc:	6d e8 ff 0d 	call 80001efa <IfxCpu_waitEvent>
    
    while(1)
80300300:	1d 00 00 00 	j 80300300 <core1_main+0x26>

Disassembly of section .CPU2.text:

8060010c <__Core2_start>:
    password  = watchdog->CON0.B.PW;
8060010c:	91 30 00 2f 	movh.a %a2,61443
80600110:	d9 22 24 96 	lea %a2,[%a2]25188 <f0036264 <bmhd_3_copy+0x40c34c64>>
    unsigned int   stmCountBegin = STM0_TIM0.U;     /* it is necessary to get this value to have minimum 100uS delay in subsequent CPU start */
80600114:	85 f8 10 01 	ld.w %d8,f0001010 <bmhd_3_copy+0x40bffa10>
80600118:	54 22       	ld.w %d2,[%a2]
8060011a:	37 02 6e 21 	extr.u %d2,%d2,2,14
    password ^= IFX_SSW_WDT_PASSWORD_INVERT_MSK;
8060011e:	8f f2 83 21 	xor %d2,%d2,63
    Ifx_Ssw_setAddressReg(sp, __USTACK(2));
80600122:	91 10 00 a5 	movh.a %sp,20481
80600126:	d9 aa 40 85 	lea %sp,[%sp]22016 <50015600 <__USTACK2>>
    __asm__ volatile ("dsync" : : : "memory");
8060012a:	0d 00 80 04 	dsync 
    Ifx_Ssw_MTCR(CPU_PSW, IFX_CFG_SSW_PSW_DEFAULT);
8060012e:	3b 00 98 30 	mov %d3,2432
80600132:	cd 43 e0 0f 	mtcr $psw,%d3
    if (watchdog->CON0.B.LCK)
80600136:	54 23       	ld.w %d3,[%a2]
80600138:	6f 13 c7 80 	jnz.t %d3,1,806002c6 <x+0x6>
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8060013c:	06 22       	sh %d2,2
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8060013e:	91 30 00 2f 	movh.a %a2,61443
80600142:	19 24 24 96 	ld.w %d4,[%a2]25188 <f0036264 <bmhd_3_copy+0x40c34c64>>
80600146:	d9 22 24 96 	lea %a2,[%a2]25188 <f0036264 <bmhd_3_copy+0x40c34c64>>
8060014a:	b7 04 10 40 	insert %d4,%d4,0,0,16
        Ifx_Ssw_MTCR(CPU_PCON0, pcon0.U);
8060014e:	82 03       	mov %d3,0
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80600150:	a6 24       	or %d4,%d2
80600152:	8f 24 40 41 	or %d4,%d4,2
    watchdog->CON0.U = ((unsigned int)0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80600156:	74 24       	st.w [%a2],%d4
    watchdog->CON0.U;
80600158:	54 24       	ld.w %d4,[%a2]
8060015a:	cd c3 20 09 	mtcr $pcon0,%d3
    __asm__ volatile ("isync" : : : "memory");
8060015e:	0d 00 c0 04 	isync 
        Ifx_Ssw_MTCR(CPU_DCON0, dcon0.U);
80600162:	cd 03 04 09 	mtcr $dcon0,%d3
80600166:	0d 00 c0 04 	isync 
    Ifx_Ssw_MTCR(CPU_BTV, (unsigned int)__TRAPTAB(2));
8060016a:	91 00 06 38 	movh.a %a3,32864
8060016e:	80 33       	mov.d %d3,%a3
80600170:	1b 03 00 30 	addi %d3,%d3,0
80600174:	cd 43 e2 0f 	mtcr $btv,%d3
    Ifx_Ssw_MTCR(CPU_BIV, (unsigned int)__INTTAB(2));
80600178:	91 00 09 38 	movh.a %a3,32912
8060017c:	80 33       	mov.d %d3,%a3
8060017e:	1b 03 00 3e 	addi %d3,%d3,-8192
80600182:	cd 03 e2 0f 	mtcr $biv,%d3
    Ifx_Ssw_MTCR(CPU_ISP, (unsigned int)__ISTACK(2));
80600186:	91 10 00 35 	movh.a %a3,20481
8060018a:	80 33       	mov.d %d3,%a3
8060018c:	1b 03 b0 35 	addi %d3,%d3,23296
80600190:	cd 83 e2 0f 	mtcr $isp,%d3
    if (watchdog->CON0.B.LCK)
80600194:	54 23       	ld.w %d3,[%a2]
80600196:	6f 13 09 00 	jz.t %d3,1,806001a8 <__Core2_start+0x9c>
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8060019a:	54 23       	ld.w %d3,[%a2]
8060019c:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
806001a0:	a6 23       	or %d3,%d2
806001a2:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
806001a6:	74 23       	st.w [%a2],%d3
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
806001a8:	91 30 00 2f 	movh.a %a2,61443
806001ac:	19 23 24 96 	ld.w %d3,[%a2]25188 <f0036264 <bmhd_3_copy+0x40c34c64>>
806001b0:	d9 22 24 96 	lea %a2,[%a2]25188 <f0036264 <bmhd_3_copy+0x40c34c64>>
806001b4:	b7 03 10 30 	insert %d3,%d3,0,0,16
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
806001b8:	a6 32       	or %d2,%d3
806001ba:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
806001be:	74 22       	st.w [%a2],%d2
    watchdog->CON0.U;
806001c0:	54 22       	ld.w %d2,[%a2]
    Ifx_Ssw_setAddressReg(a0, __SDATA1(2));
806001c2:	91 10 00 07 	movh.a %a0,28673
806001c6:	d9 00 00 08 	lea %a0,[%a0]-32768 <70008000 <_SMALL_DATA_>>
    Ifx_Ssw_setAddressReg(a1, __SDATA2(2));
806001ca:	91 10 00 18 	movh.a %a1,32769
806001ce:	d9 11 00 08 	lea %a1,[%a1]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a8, __SDATA3(2));
806001d2:	91 10 00 88 	movh.a %a8,32769
806001d6:	d9 88 00 08 	lea %a8,[%a8]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a9, __SDATA4(2));
806001da:	91 10 00 99 	movh.a %a9,36865
806001de:	d9 99 00 08 	lea %a9,[%a9]-32768 <90008000 <_SMALL_DATA4_>>
    unsigned int numOfCsa     = (((unsigned int)csaEnd - (unsigned int)csaBegin) / 64U);
806001e2:	91 10 00 35 	movh.a %a3,20481
806001e6:	91 10 00 25 	movh.a %a2,20481
806001ea:	d9 33 c0 05 	lea %a3,[%a3]23552 <50015c00 <__CSA2>>
806001ee:	d9 22 c0 07 	lea %a2,[%a2]31744 <50017c00 <__CSA2_END>>
806001f2:	01 32 20 20 	sub.a %a2,%a2,%a3
806001f6:	80 22       	mov.d %d2,%a2
806001f8:	8f a2 1f 60 	sh %d6,%d2,-6
    unsigned int *prvCsa      = csaBegin;
806001fc:	40 32       	mov.aa %a2,%a3
        if (k == (numOfCsa - 3U))
806001fe:	1b d6 ff 0f 	addi %d0,%d6,-3
    for (k = 0U; k < numOfCsa; k++)
80600202:	82 03       	mov %d3,0
    unsigned int *nxtCsa      = csaBegin;
80600204:	80 32       	mov.d %d2,%a3
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80600206:	7b f0 00 70 	movh %d7,15
    for (k = 0U; k < numOfCsa; k++)
8060020a:	df 06 2d 00 	jeq %d6,0,80600264 <__Core2_start+0x158>
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
8060020e:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80600212:	8f 42 1f 50 	sh %d5,%d2,-12
80600216:	26 75       	and %d5,%d7
80600218:	a6 54       	or %d4,%d5
        if (k == 0U)
8060021a:	df 03 14 00 	jeq %d3,0,80600242 <__Core2_start+0x136>
            *prvCsa = nxt_cxi_val;
8060021e:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
80600220:	5f 03 15 00 	jeq %d3,%d0,8060024a <__Core2_start+0x13e>
    for (k = 0U; k < numOfCsa; k++)
80600224:	c2 13       	add %d3,1
80600226:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80600228:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
8060022c:	5f 36 17 00 	jeq %d6,%d3,8060025a <__Core2_start+0x14e>
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80600230:	02 42       	mov %d2,%d4
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
80600232:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80600236:	8f 42 1f 50 	sh %d5,%d2,-12
8060023a:	26 75       	and %d5,%d7
8060023c:	a6 54       	or %d4,%d5
        if (k == 0U)
8060023e:	df 03 f0 ff 	jne %d3,0,8060021e <__Core2_start+0x112>
            Ifx_Ssw_MTCR(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
80600242:	cd 84 e3 0f 	mtcr $fcx,%d4
        if (k == (numOfCsa - 3U))
80600246:	5f 03 ef ff 	jne %d3,%d0,80600224 <__Core2_start+0x118>
            Ifx_Ssw_MTCR(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
8060024a:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
8060024e:	c2 13       	add %d3,1
80600250:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80600252:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80600256:	5f 36 ed ff 	jne %d6,%d3,80600230 <__Core2_start+0x124>
8060025a:	1b f6 ff 2f 	addi %d2,%d6,-1
8060025e:	06 62       	sh %d2,6
80600260:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    *prvCsa = 0U;                       /* Store null pointer in last CSA (= very first time!) */
80600264:	82 02       	mov %d2,0
80600266:	74 22       	st.w [%a2],%d2
    __asm__ volatile ("dsync" : : : "memory");
80600268:	0d 00 80 04 	dsync 
    __asm__ volatile ("isync" : : : "memory");
8060026c:	0d 00 c0 04 	isync 
    stmCount = (unsigned int)(Ifx_Ssw_getStmFrequency() * IFX_CFG_SSW_STARTCPU_WAIT_TIME_IN_SECONDS);
80600270:	6d d0 fd 10 	call 8000246a <Ifx_Ssw_getStmFrequency>
80600274:	02 24       	mov %d4,%d2
80600276:	6d d0 98 24 	call 80004ba6 <__extendsfdf2>
8060027a:	0b 23 10 48 	mov %e4,%d3,%d2
8060027e:	7b c0 b1 6e 	movh %d6,60188
80600282:	7b a0 f1 73 	movh %d7,16154
80600286:	1b d6 32 64 	addi %d6,%d6,17197
8060028a:	1b 27 6e 73 	addi %d7,%d7,14050
8060028e:	6d d0 f4 25 	call 80004e76 <__muldf3>
80600292:	0b 23 10 48 	mov %e4,%d3,%d2
80600296:	6d d0 6c 24 	call 80004b6e <__fixunsdfsi>
    while ((unsigned int)(STM0_TIM0.U - stmCountBegin) < stmCount)
8060029a:	85 f3 10 01 	ld.w %d3,f0001010 <bmhd_3_copy+0x40bffa10>
8060029e:	a2 83       	sub %d3,%d8
806002a0:	3f 23 fd ff 	jlt.u %d3,%d2,8060029a <__Core2_start+0x18e>
    (void)Ifx_Ssw_startCore(&MODULE_CPU3, (unsigned int)__START(3));       /*The status returned by function call is ignored */
806002a4:	91 00 09 2a 	movh.a %a2,41104
806002a8:	80 22       	mov.d %d2,%a2
806002aa:	1b 02 10 40 	addi %d4,%d2,256
806002ae:	91 60 88 4f 	movh.a %a4,63622
806002b2:	6d d0 be 10 	call 8000242e <Ifx_Ssw_startCore>
    __asm__ volatile ("ji %0" ::"a" (fun));
806002b6:	91 00 06 28 	movh.a %a2,32864
806002ba:	d9 22 1a b0 	lea %a2,[%a2]730 <806002da <core2_main>>
806002be:	dc 02       	ji %a2

806002c0 <x>:
    __asm("x: loopu\t x");
806002c0:	fd 00 00 80 	loopu 806002c0 <x>
}
806002c4:	00 90       	ret 
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
806002c6:	54 23       	ld.w %d3,[%a2]
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
806002c8:	06 22       	sh %d2,2
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
806002ca:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
806002ce:	a6 23       	or %d3,%d2
806002d0:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
806002d4:	74 23       	st.w [%a2],%d3
806002d6:	1d ff 34 ff 	j 8060013e <__Core2_start+0x32>

806002da <core2_main>:
#include "IfxScuWdt.h"

extern IfxCpu_syncEvent g_cpuSyncEvent;

void core2_main(void)
{
806002da:	40 ae       	mov.aa %a14,%sp
806002dc:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG2 IS DISABLED HERE!!
     * Enable the watchdog and service it periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
806002e0:	6d d0 46 0c 	call 80001b6c <IfxScuWdt_getCpuWatchdogPassword>
806002e4:	02 24       	mov %d4,%d2
806002e6:	6d d0 b5 0b 	call 80001a50 <IfxScuWdt_disableCpuWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
806002ea:	91 10 00 c7 	movh.a %a12,28673
806002ee:	d9 cc 34 50 	lea %a12,[%a12]372 <70010174 <g_cpuSyncEvent>>
806002f2:	40 c4       	mov.aa %a4,%a12
806002f4:	6d d0 45 0e 	call 80001f7e <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
806002f8:	82 14       	mov %d4,1
806002fa:	40 c4       	mov.aa %a4,%a12
806002fc:	6d d0 ff 0d 	call 80001efa <IfxCpu_waitEvent>
    
    while(1)
80600300:	1d 00 00 00 	j 80600300 <core2_main+0x26>

Disassembly of section .CPU3.text:

8090010c <__Core3_start>:
    password  = watchdog->CON0.B.PW;
8090010c:	91 30 00 2f 	movh.a %a2,61443
80900110:	d9 22 30 96 	lea %a2,[%a2]25200 <f0036270 <bmhd_3_copy+0x40c34c70>>
    unsigned int   stmCountBegin = STM0_TIM0.U;     /* it is necessary to get this value to have minimum 100uS delay in subsequent CPU start */
80900114:	85 f8 10 01 	ld.w %d8,f0001010 <bmhd_3_copy+0x40bffa10>
80900118:	54 22       	ld.w %d2,[%a2]
8090011a:	37 02 6e 21 	extr.u %d2,%d2,2,14
    password ^= IFX_SSW_WDT_PASSWORD_INVERT_MSK;
8090011e:	8f f2 83 21 	xor %d2,%d2,63
    Ifx_Ssw_setAddressReg(sp, __USTACK(3));
80900122:	91 10 00 a4 	movh.a %sp,16385
80900126:	d9 aa 40 85 	lea %sp,[%sp]22016 <40015600 <__USTACK3>>
    __asm__ volatile ("dsync" : : : "memory");
8090012a:	0d 00 80 04 	dsync 
    Ifx_Ssw_MTCR(CPU_PSW, IFX_CFG_SSW_PSW_DEFAULT);
8090012e:	3b 00 98 30 	mov %d3,2432
80900132:	cd 43 e0 0f 	mtcr $psw,%d3
    if (watchdog->CON0.B.LCK)
80900136:	54 23       	ld.w %d3,[%a2]
80900138:	6f 13 be 80 	jnz.t %d3,1,809002b4 <x+0x6>
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8090013c:	06 22       	sh %d2,2
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8090013e:	91 30 00 2f 	movh.a %a2,61443
80900142:	19 24 30 96 	ld.w %d4,[%a2]25200 <f0036270 <bmhd_3_copy+0x40c34c70>>
80900146:	d9 22 30 96 	lea %a2,[%a2]25200 <f0036270 <bmhd_3_copy+0x40c34c70>>
8090014a:	b7 04 10 40 	insert %d4,%d4,0,0,16
        Ifx_Ssw_MTCR(CPU_PCON0, pcon0.U);
8090014e:	82 03       	mov %d3,0
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80900150:	a6 24       	or %d4,%d2
80900152:	8f 24 40 41 	or %d4,%d4,2
    watchdog->CON0.U = ((unsigned int)0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80900156:	74 24       	st.w [%a2],%d4
    watchdog->CON0.U;
80900158:	54 24       	ld.w %d4,[%a2]
8090015a:	cd c3 20 09 	mtcr $pcon0,%d3
    __asm__ volatile ("isync" : : : "memory");
8090015e:	0d 00 c0 04 	isync 
        Ifx_Ssw_MTCR(CPU_DCON0, dcon0.U);
80900162:	cd 03 04 09 	mtcr $dcon0,%d3
80900166:	0d 00 c0 04 	isync 
    Ifx_Ssw_MTCR(CPU_BTV, (unsigned int)__TRAPTAB(3));
8090016a:	91 00 09 38 	movh.a %a3,32912
8090016e:	80 33       	mov.d %d3,%a3
80900170:	1b 03 00 30 	addi %d3,%d3,0
80900174:	cd 43 e2 0f 	mtcr $btv,%d3
    Ifx_Ssw_MTCR(CPU_BIV, (unsigned int)__INTTAB(3));
80900178:	91 00 0a 38 	movh.a %a3,32928
8090017c:	80 33       	mov.d %d3,%a3
8090017e:	1b 03 00 3e 	addi %d3,%d3,-8192
80900182:	cd 03 e2 0f 	mtcr $biv,%d3
    Ifx_Ssw_MTCR(CPU_ISP, (unsigned int)__ISTACK(3));
80900186:	91 10 00 34 	movh.a %a3,16385
8090018a:	80 33       	mov.d %d3,%a3
8090018c:	1b 03 b0 35 	addi %d3,%d3,23296
80900190:	cd 83 e2 0f 	mtcr $isp,%d3
    if (watchdog->CON0.B.LCK)
80900194:	54 23       	ld.w %d3,[%a2]
80900196:	6f 13 09 00 	jz.t %d3,1,809001a8 <__Core3_start+0x9c>
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8090019a:	54 23       	ld.w %d3,[%a2]
8090019c:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
809001a0:	a6 23       	or %d3,%d2
809001a2:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
809001a6:	74 23       	st.w [%a2],%d3
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
809001a8:	91 30 00 2f 	movh.a %a2,61443
809001ac:	19 23 30 96 	ld.w %d3,[%a2]25200 <f0036270 <bmhd_3_copy+0x40c34c70>>
809001b0:	d9 22 30 96 	lea %a2,[%a2]25200 <f0036270 <bmhd_3_copy+0x40c34c70>>
809001b4:	b7 03 10 30 	insert %d3,%d3,0,0,16
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
809001b8:	a6 32       	or %d2,%d3
809001ba:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
809001be:	74 22       	st.w [%a2],%d2
    watchdog->CON0.U;
809001c0:	54 22       	ld.w %d2,[%a2]
    Ifx_Ssw_setAddressReg(a0, __SDATA1(3));
809001c2:	91 10 00 07 	movh.a %a0,28673
809001c6:	d9 00 00 08 	lea %a0,[%a0]-32768 <70008000 <_SMALL_DATA_>>
    Ifx_Ssw_setAddressReg(a1, __SDATA2(3));
809001ca:	91 10 00 18 	movh.a %a1,32769
809001ce:	d9 11 00 08 	lea %a1,[%a1]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a8, __SDATA3(3));
809001d2:	91 10 00 88 	movh.a %a8,32769
809001d6:	d9 88 00 08 	lea %a8,[%a8]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a9, __SDATA4(3));
809001da:	91 10 00 99 	movh.a %a9,36865
809001de:	d9 99 00 08 	lea %a9,[%a9]-32768 <90008000 <_SMALL_DATA4_>>
    unsigned int numOfCsa     = (((unsigned int)csaEnd - (unsigned int)csaBegin) / 64U);
809001e2:	91 10 00 34 	movh.a %a3,16385
809001e6:	91 10 00 24 	movh.a %a2,16385
809001ea:	d9 33 c0 05 	lea %a3,[%a3]23552 <40015c00 <__CSA3>>
809001ee:	d9 22 c0 07 	lea %a2,[%a2]31744 <40017c00 <__CSA3_END>>
809001f2:	01 32 20 20 	sub.a %a2,%a2,%a3
809001f6:	80 22       	mov.d %d2,%a2
809001f8:	8f a2 1f 60 	sh %d6,%d2,-6
    unsigned int *prvCsa      = csaBegin;
809001fc:	40 32       	mov.aa %a2,%a3
        if (k == (numOfCsa - 3U))
809001fe:	1b d6 ff 0f 	addi %d0,%d6,-3
    for (k = 0U; k < numOfCsa; k++)
80900202:	82 03       	mov %d3,0
    unsigned int *nxtCsa      = csaBegin;
80900204:	80 32       	mov.d %d2,%a3
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80900206:	7b f0 00 70 	movh %d7,15
    for (k = 0U; k < numOfCsa; k++)
8090020a:	df 06 2d 00 	jeq %d6,0,80900264 <__Core3_start+0x158>
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
8090020e:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80900212:	8f 42 1f 50 	sh %d5,%d2,-12
80900216:	26 75       	and %d5,%d7
80900218:	a6 54       	or %d4,%d5
        if (k == 0U)
8090021a:	df 03 14 00 	jeq %d3,0,80900242 <__Core3_start+0x136>
            *prvCsa = nxt_cxi_val;
8090021e:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
80900220:	5f 03 15 00 	jeq %d3,%d0,8090024a <__Core3_start+0x13e>
    for (k = 0U; k < numOfCsa; k++)
80900224:	c2 13       	add %d3,1
80900226:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80900228:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
8090022c:	5f 36 17 00 	jeq %d6,%d3,8090025a <__Core3_start+0x14e>
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80900230:	02 42       	mov %d2,%d4
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
80900232:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80900236:	8f 42 1f 50 	sh %d5,%d2,-12
8090023a:	26 75       	and %d5,%d7
8090023c:	a6 54       	or %d4,%d5
        if (k == 0U)
8090023e:	df 03 f0 ff 	jne %d3,0,8090021e <__Core3_start+0x112>
            Ifx_Ssw_MTCR(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
80900242:	cd 84 e3 0f 	mtcr $fcx,%d4
        if (k == (numOfCsa - 3U))
80900246:	5f 03 ef ff 	jne %d3,%d0,80900224 <__Core3_start+0x118>
            Ifx_Ssw_MTCR(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
8090024a:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
8090024e:	c2 13       	add %d3,1
80900250:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80900252:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80900256:	5f 36 ed ff 	jne %d6,%d3,80900230 <__Core3_start+0x124>
8090025a:	1b f6 ff 2f 	addi %d2,%d6,-1
8090025e:	06 62       	sh %d2,6
80900260:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    *prvCsa = 0U;                       /* Store null pointer in last CSA (= very first time!) */
80900264:	82 02       	mov %d2,0
80900266:	74 22       	st.w [%a2],%d2
    __asm__ volatile ("dsync" : : : "memory");
80900268:	0d 00 80 04 	dsync 
    __asm__ volatile ("isync" : : : "memory");
8090026c:	0d 00 c0 04 	isync 
    stmCount = (unsigned int)(Ifx_Ssw_getStmFrequency() * IFX_CFG_SSW_STARTCPU_WAIT_TIME_IN_SECONDS);
80900270:	6d b8 fd 10 	call 8000246a <Ifx_Ssw_getStmFrequency>
80900274:	02 24       	mov %d4,%d2
80900276:	6d b8 98 24 	call 80004ba6 <__extendsfdf2>
8090027a:	0b 23 10 48 	mov %e4,%d3,%d2
8090027e:	7b c0 b1 6e 	movh %d6,60188
80900282:	7b a0 f1 73 	movh %d7,16154
80900286:	1b d6 32 64 	addi %d6,%d6,17197
8090028a:	1b 27 6e 73 	addi %d7,%d7,14050
8090028e:	6d b8 f4 25 	call 80004e76 <__muldf3>
80900292:	0b 23 10 48 	mov %e4,%d3,%d2
80900296:	6d b8 6c 24 	call 80004b6e <__fixunsdfsi>
    while ((unsigned int)(STM0_TIM0.U - stmCountBegin) < stmCount)
8090029a:	85 f3 10 01 	ld.w %d3,f0001010 <bmhd_3_copy+0x40bffa10>
8090029e:	a2 83       	sub %d3,%d8
809002a0:	3f 23 fd ff 	jlt.u %d3,%d2,8090029a <__Core3_start+0x18e>
    __asm__ volatile ("ji %0" ::"a" (fun));
809002a4:	91 00 09 28 	movh.a %a2,32912
809002a8:	d9 22 08 b0 	lea %a2,[%a2]712 <809002c8 <core3_main>>
809002ac:	dc 02       	ji %a2

809002ae <x>:
    __asm("x: loopu\t x");
809002ae:	fd 00 00 80 	loopu 809002ae <x>
}
809002b2:	00 90       	ret 
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
809002b4:	54 23       	ld.w %d3,[%a2]
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
809002b6:	06 22       	sh %d2,2
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
809002b8:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
809002bc:	a6 23       	or %d3,%d2
809002be:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
809002c2:	74 23       	st.w [%a2],%d3
809002c4:	1d ff 3d ff 	j 8090013e <__Core3_start+0x32>

809002c8 <core3_main>:
#include "IfxScuWdt.h"

extern IfxCpu_syncEvent g_cpuSyncEvent;

void core3_main(void)
{
809002c8:	40 ae       	mov.aa %a14,%sp
809002ca:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG3 IS DISABLED HERE!!
     * Enable the watchdog and service it periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
809002ce:	6d b8 4f 0c 	call 80001b6c <IfxScuWdt_getCpuWatchdogPassword>
809002d2:	02 24       	mov %d4,%d2
809002d4:	6d b8 be 0b 	call 80001a50 <IfxScuWdt_disableCpuWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
809002d8:	91 10 00 c7 	movh.a %a12,28673
809002dc:	d9 cc 34 50 	lea %a12,[%a12]372 <70010174 <g_cpuSyncEvent>>
809002e0:	40 c4       	mov.aa %a4,%a12
809002e2:	6d b8 4e 0e 	call 80001f7e <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
809002e6:	82 14       	mov %d4,1
809002e8:	40 c4       	mov.aa %a4,%a12
809002ea:	6d b8 08 0e 	call 80001efa <IfxCpu_waitEvent>
    
    while(1)
809002ee:	1d 00 00 00 	j 809002ee <core3_main+0x26>

Disassembly of section .text:

80000b10 <deregister_tm_clones>:
80000b10:	7b 00 00 27 	movh %d2,28672
80000b14:	1b 02 00 20 	addi %d2,%d2,0
80000b18:	91 00 00 47 	movh.a %a4,28672
80000b1c:	60 22       	mov.a %a2,%d2
80000b1e:	d9 44 00 00 	lea %a4,[%a4]0 <70000000 <__TMC_END__>>
80000b22:	7d 42 0a 00 	jeq.a %a2,%a4,80000b36 <deregister_tm_clones+0x26>
80000b26:	91 00 00 20 	movh.a %a2,0
80000b2a:	d9 22 00 00 	lea %a2,[%a2]0 <0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x380>>
80000b2e:	bd 02 04 00 	jz.a %a2,80000b36 <deregister_tm_clones+0x26>
80000b32:	2d 02 00 00 	calli %a2
80000b36:	00 90       	ret 

80000b38 <register_tm_clones>:
80000b38:	7b 00 00 27 	movh %d2,28672
80000b3c:	1b 02 00 20 	addi %d2,%d2,0
80000b40:	91 00 00 47 	movh.a %a4,28672
80000b44:	60 22       	mov.a %a2,%d2
80000b46:	d9 44 00 00 	lea %a4,[%a4]0 <70000000 <__TMC_END__>>
80000b4a:	01 42 20 20 	sub.a %a2,%a2,%a4
80000b4e:	80 22       	mov.d %d2,%a2
80000b50:	8f e2 3f 30 	sha %d3,%d2,-2
80000b54:	8f 12 1e 20 	sh %d2,%d2,-31
80000b58:	42 32       	add %d2,%d3
80000b5a:	8f f2 3f 40 	sha %d4,%d2,-1
80000b5e:	df 04 0a 00 	jeq %d4,0,80000b72 <register_tm_clones+0x3a>
80000b62:	91 00 00 20 	movh.a %a2,0
80000b66:	d9 22 00 00 	lea %a2,[%a2]0 <0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x380>>
80000b6a:	bd 02 04 00 	jz.a %a2,80000b72 <register_tm_clones+0x3a>
80000b6e:	2d 02 00 00 	calli %a2
80000b72:	00 90       	ret 

80000b74 <__do_global_dtors_aux>:
80000b74:	91 00 00 e7 	movh.a %a14,28672
80000b78:	39 e2 00 00 	ld.bu %d2,[%a14]0 <70000000 <__TMC_END__>>
80000b7c:	df 02 2d 80 	jne %d2,0,80000bd6 <__do_global_dtors_aux+0x62>
80000b80:	91 00 00 38 	movh.a %a3,32768
80000b84:	91 00 00 28 	movh.a %a2,32768
80000b88:	d9 33 68 55 	lea %a3,[%a3]21864 <80005568 <__DTOR_END__>>
80000b8c:	d9 22 5c 55 	lea %a2,[%a2]21852 <8000555c <__DTOR_LIST__>>
80000b90:	01 23 20 20 	sub.a %a2,%a3,%a2
80000b94:	80 22       	mov.d %d2,%a2
80000b96:	86 e2       	sha %d2,-2
80000b98:	1b f2 ff 8f 	addi %d8,%d2,-1
80000b9c:	91 00 00 c7 	movh.a %a12,28672
80000ba0:	7b 00 00 28 	movh %d2,32768
80000ba4:	1b c2 55 25 	addi %d2,%d2,21852
80000ba8:	60 2d       	mov.a %a13,%d2
80000baa:	19 c2 04 00 	ld.w %d2,[%a12]4 <70000004 <dtor_idx.0>>
80000bae:	7f 82 0f 80 	jge.u %d2,%d8,80000bcc <__do_global_dtors_aux+0x58>
80000bb2:	d9 cc 04 00 	lea %a12,[%a12]4 <70000004 <dtor_idx.0>>
80000bb6:	c2 12       	add %d2,1
80000bb8:	74 c2       	st.w [%a12],%d2
80000bba:	06 22       	sh %d2,2
80000bbc:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000bc0:	d4 22       	ld.a %a2,[%a2]
80000bc2:	2d 02 00 00 	calli %a2
80000bc6:	54 c2       	ld.w %d2,[%a12]
80000bc8:	3f 82 f7 ff 	jlt.u %d2,%d8,80000bb6 <__do_global_dtors_aux+0x42>
80000bcc:	6d ff a2 ff 	call 80000b10 <deregister_tm_clones>
80000bd0:	82 12       	mov %d2,1
80000bd2:	e9 e2 00 00 	st.b [%a14]0 <70000000 <__TMC_END__>>,%d2
80000bd6:	00 90       	ret 

80000bd8 <frame_dummy>:
80000bd8:	6d ff b0 ff 	call 80000b38 <register_tm_clones>
80000bdc:	00 90       	ret 

80000bde <IfxStm_clearCompareFlag>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxStm_clearCompareFlag(Ifx_STM *stm, IfxStm_Comparator comparator)
{
80000bde:	40 ae       	mov.aa %a14,%sp
    if (comparator == IfxStm_Comparator_0)
80000be0:	df 04 0a 80 	jne %d4,0,80000bf4 <IfxStm_clearCompareFlag+0x16>
    {
        stm->ISCR.B.CMP0IRR = 1U;
80000be4:	d9 42 00 10 	lea %a2,[%a4]64
80000be8:	19 42 00 10 	ld.w %d2,[%a4]64
80000bec:	b7 12 01 20 	insert %d2,%d2,1,0,1
80000bf0:	74 22       	st.w [%a2],%d2
80000bf2:	00 90       	ret 
    }
    else if (comparator == IfxStm_Comparator_1)
80000bf4:	df 14 03 00 	jeq %d4,1,80000bfa <IfxStm_clearCompareFlag+0x1c>
    {
        stm->ISCR.B.CMP1IRR = 1U;
    }
}
80000bf8:	00 90       	ret 
        stm->ISCR.B.CMP1IRR = 1U;
80000bfa:	d9 42 00 10 	lea %a2,[%a4]64
80000bfe:	19 42 00 10 	ld.w %d2,[%a4]64
80000c02:	b7 12 01 21 	insert %d2,%d2,1,2,1
80000c06:	74 22       	st.w [%a2],%d2
}
80000c08:	1d ff f8 ff 	j 80000bf8 <IfxStm_clearCompareFlag+0x1a>

80000c0c <IfxStm_enableComparatorInterrupt>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxStm_enableComparatorInterrupt(Ifx_STM *stm, IfxStm_Comparator comparator)
{
80000c0c:	40 ae       	mov.aa %a14,%sp
    if (comparator == IfxStm_Comparator_0)
80000c0e:	df 04 0a 80 	jne %d4,0,80000c22 <IfxStm_enableComparatorInterrupt+0x16>
    {
        stm->ICR.B.CMP0EN = 1U;
80000c12:	d9 42 3c 00 	lea %a2,[%a4]60
80000c16:	19 42 3c 00 	ld.w %d2,[%a4]60
80000c1a:	b7 12 01 20 	insert %d2,%d2,1,0,1
80000c1e:	74 22       	st.w [%a2],%d2
80000c20:	00 90       	ret 
    }
    else if (comparator == IfxStm_Comparator_1)
80000c22:	df 14 03 00 	jeq %d4,1,80000c28 <IfxStm_enableComparatorInterrupt+0x1c>
    {
        stm->ICR.B.CMP1EN = 1U;
    }
}
80000c26:	00 90       	ret 
        stm->ICR.B.CMP1EN = 1U;
80000c28:	d9 42 3c 00 	lea %a2,[%a4]60
80000c2c:	19 42 3c 00 	ld.w %d2,[%a4]60
80000c30:	b7 12 01 22 	insert %d2,%d2,1,4,1
80000c34:	74 22       	st.w [%a2],%d2
}
80000c36:	1d ff f8 ff 	j 80000c26 <IfxStm_enableComparatorInterrupt+0x1a>

80000c3a <IfxStm_getIndex>:
    return module;
}


IfxStm_Index IfxStm_getIndex(Ifx_STM *stm)
{
80000c3a:	40 ae       	mov.aa %a14,%sp
    uint32       index;
    IfxStm_Index result;

    result = IfxStm_Index_none;

    for (index = 0; index < IFXSTM_NUM_MODULES; index++)
80000c3c:	82 02       	mov %d2,0
80000c3e:	ff 42 1b 80 	jge.u %d2,4,80000c74 <IfxStm_getIndex+0x3a>
    {
        if (IfxStm_cfg_indexMap[index].module == stm)
80000c42:	8f 32 00 30 	sh %d3,%d2,3
80000c46:	91 00 00 28 	movh.a %a2,32768
80000c4a:	d9 22 30 80 	lea %a2,[%a2]560 <80000230 <IfxStm_cfg_indexMap>>
80000c4e:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80000c52:	54 23       	ld.w %d3,[%a2]
80000c54:	80 44       	mov.d %d4,%a4
80000c56:	5f 43 05 00 	jeq %d3,%d4,80000c60 <IfxStm_getIndex+0x26>
    for (index = 0; index < IFXSTM_NUM_MODULES; index++)
80000c5a:	c2 12       	add %d2,1
80000c5c:	1d ff f1 ff 	j 80000c3e <IfxStm_getIndex+0x4>
        {
            result = (IfxStm_Index)IfxStm_cfg_indexMap[index].index;
80000c60:	06 32       	sh %d2,3
80000c62:	91 00 00 28 	movh.a %a2,32768
80000c66:	d9 22 30 80 	lea %a2,[%a2]560 <80000230 <IfxStm_cfg_indexMap>>
80000c6a:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80000c6e:	19 22 04 00 	ld.w %d2,[%a2]4
            break;
80000c72:	00 90       	ret 
    result = IfxStm_Index_none;
80000c74:	82 f2       	mov %d2,-1
        }
    }

    return result;
}
80000c76:	00 90       	ret 

80000c78 <IfxStm_initCompare>:
    return comparator == IfxStm_Comparator_0 ? &MODULE_SRC.STM.STM[index].SR[0] : &MODULE_SRC.STM.STM[index].SR[1];
}


boolean IfxStm_initCompare(Ifx_STM *stm, const IfxStm_CompareConfig *config)
{
80000c78:	40 ae       	mov.aa %a14,%sp
80000c7a:	40 4d       	mov.aa %a13,%a4
80000c7c:	40 5c       	mov.aa %a12,%a5
    sint32        index;
    boolean       result;
    Ifx_STM_CMCON comcon = stm->CMCON;
80000c7e:	19 42 38 00 	ld.w %d2,[%a4]56
    Ifx_STM_ICR   icr    = stm->ICR;
80000c82:	19 43 3c 00 	ld.w %d3,[%a4]60

    if (config->comparator == 0)
80000c86:	54 54       	ld.w %d4,[%a5]
80000c88:	df 04 82 80 	jne %d4,0,80000d8c <IfxStm_initCompare+0x114>
    {
        comcon.B.MSIZE0  = config->compareSize;
80000c8c:	19 54 0c 00 	ld.w %d4,[%a5]12
80000c90:	37 42 05 20 	insert %d2,%d2,%d4,0,5
        comcon.B.MSTART0 = config->compareOffset;
80000c94:	19 54 08 00 	ld.w %d4,[%a5]8
80000c98:	37 42 05 24 	insert %d2,%d2,%d4,8,5
        icr.B.CMP0OS     = config->comparatorInterrupt;
80000c9c:	19 54 04 00 	ld.w %d4,[%a5]4
80000ca0:	67 43 02 30 	ins.t %d3,%d3,2,%d4,0
        result           = TRUE;
80000ca4:	82 18       	mov %d8,1
    {
        /*Invalid value */
        result = FALSE;
    }

    stm->ICR.U   = icr.U;
80000ca6:	59 d3 3c 00 	st.w [%a13]60,%d3
    stm->CMCON.U = comcon.U;
80000caa:	59 d2 38 00 	st.w [%a13]56,%d2

    /* configure interrupt */
    index = IfxStm_getIndex(stm);
80000cae:	40 d4       	mov.aa %a4,%a13
80000cb0:	6d ff c5 ff 	call 80000c3a <IfxStm_getIndex>

    if (config->triggerPriority > 0)
80000cb4:	b9 c3 14 00 	ld.hu %d3,[%a12]20
80000cb8:	df 03 20 00 	jeq %d3,0,80000cf8 <IfxStm_initCompare+0x80>
    {
        volatile Ifx_SRC_SRCR *srcr;

        if (config->comparatorInterrupt == IfxStm_ComparatorInterrupt_ir0)
80000cbc:	19 c4 04 00 	ld.w %d4,[%a12]4
80000cc0:	df 04 7a 80 	jne %d4,0,80000db4 <IfxStm_initCompare+0x13c>
        {
            srcr = &(MODULE_SRC.STM.STM[index].SR[0]);
80000cc4:	06 32       	sh %d2,3
80000cc6:	7b 40 00 4f 	movh %d4,61444
80000cca:	1b 04 30 48 	addi %d4,%d4,-32000
80000cce:	60 42       	mov.a %a2,%d4
80000cd0:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
        else
        {
            srcr = &(MODULE_SRC.STM.STM[index].SR[1]);
        }

        IfxSrc_init(srcr, config->typeOfService, config->triggerPriority);
80000cd4:	19 c4 18 00 	ld.w %d4,[%a12]24
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80000cd8:	54 22       	ld.w %d2,[%a2]
80000cda:	37 32 08 20 	insert %d2,%d2,%d3,0,8
80000cde:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80000ce0:	54 22       	ld.w %d2,[%a2]
80000ce2:	37 42 83 25 	insert %d2,%d2,%d4,11,3
80000ce6:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
80000ce8:	54 22       	ld.w %d2,[%a2]
80000cea:	b7 12 81 2c 	insert %d2,%d2,1,25,1
80000cee:	74 22       	st.w [%a2],%d2
    src->B.SRE = 1;
80000cf0:	54 22       	ld.w %d2,[%a2]
80000cf2:	b7 12 01 25 	insert %d2,%d2,1,10,1
80000cf6:	74 22       	st.w [%a2],%d2
        IfxSrc_enable(srcr);
    }

    /*Configure the comparator ticks to current value to avoid any wrong triggering*/
    stm->CMP[config->comparator].U = IfxStm_getOffsetTimer(stm, (uint8)config->compareOffset);
80000cf8:	39 c5 08 00 	ld.bu %d5,[%a12]8

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80000cfc:	19 d6 10 00 	ld.w %d6,[%a13]16
    result |= ((uint64)stm->CAP.U) << 32;
80000d00:	19 d2 2c 00 	ld.w %d2,[%a13]44
80000d04:	8f 06 40 41 	or %d4,%d6,0
80000d08:	02 23       	mov %d3,%d2
{
    uint64 now;

    now = IfxStm_get(stm);

    return (uint32)(now >> offset);
80000d0a:	8b 05 82 22 	ge %d2,%d5,32
80000d0e:	2b 34 50 42 	seln %d4,%d2,%d4,%d3
80000d12:	ab 03 a0 32 	seln %d3,%d2,%d3,0
80000d16:	8f f5 01 21 	and %d2,%d5,31
80000d1a:	8b 02 02 51 	rsub %d5,%d2,32
80000d1e:	17 43 80 35 	dextr %d3,%d3,%d4,%d5
80000d22:	2b 43 40 32 	sel %d3,%d2,%d3,%d4
80000d26:	54 c2       	ld.w %d2,[%a12]
80000d28:	1b c2 00 20 	addi %d2,%d2,12
80000d2c:	06 22       	sh %d2,2
80000d2e:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000d32:	74 23       	st.w [%a2],%d3

    /* clear the interrupt flag of the selected comparator before enabling the interrupt */
    /* this is to avaoid the unneccesary interrupt for the compare match of reset values of the registers */
    IfxStm_clearCompareFlag(stm, config->comparator);
80000d34:	54 c4       	ld.w %d4,[%a12]
80000d36:	40 d4       	mov.aa %a4,%a13
80000d38:	6d ff 53 ff 	call 80000bde <IfxStm_clearCompareFlag>
    /* enable the interrupt for the selected comparator */
    IfxStm_enableComparatorInterrupt(stm, config->comparator);
80000d3c:	54 c4       	ld.w %d4,[%a12]
80000d3e:	40 d4       	mov.aa %a4,%a13
80000d40:	6d ff 66 ff 	call 80000c0c <IfxStm_enableComparatorInterrupt>

    /*Configure the comparator ticks */
    stm->CMP[config->comparator].U = IfxStm_getOffsetTimer(stm, (uint8)config->compareOffset) + config->ticks;
80000d44:	39 c5 08 00 	ld.bu %d5,[%a12]8
    result  = stm->TIM0.U;
80000d48:	19 d6 10 00 	ld.w %d6,[%a13]16
    result |= ((uint64)stm->CAP.U) << 32;
80000d4c:	19 d2 2c 00 	ld.w %d2,[%a13]44
80000d50:	8f 06 40 41 	or %d4,%d6,0
80000d54:	02 23       	mov %d3,%d2
    return (uint32)(now >> offset);
80000d56:	8b 05 82 22 	ge %d2,%d5,32
80000d5a:	2b 34 50 42 	seln %d4,%d2,%d4,%d3
80000d5e:	ab 03 a0 32 	seln %d3,%d2,%d3,0
80000d62:	8f f5 01 21 	and %d2,%d5,31
80000d66:	8b 02 02 51 	rsub %d5,%d2,32
80000d6a:	17 43 80 35 	dextr %d3,%d3,%d4,%d5
80000d6e:	2b 43 40 32 	sel %d3,%d2,%d3,%d4
80000d72:	02 34       	mov %d4,%d3
80000d74:	19 c3 10 00 	ld.w %d3,[%a12]16
80000d78:	54 c2       	ld.w %d2,[%a12]
80000d7a:	42 43       	add %d3,%d4
80000d7c:	1b c2 00 20 	addi %d2,%d2,12
80000d80:	06 22       	sh %d2,2
80000d82:	01 d2 00 d6 	addsc.a %a13,%a13,%d2,0
80000d86:	74 d3       	st.w [%a13],%d3

    return result;
}
80000d88:	02 82       	mov %d2,%d8
80000d8a:	00 90       	ret 
    else if (config->comparator == 1)
80000d8c:	df 14 05 00 	jeq %d4,1,80000d96 <IfxStm_initCompare+0x11e>
        result = FALSE;
80000d90:	82 08       	mov %d8,0
80000d92:	1d ff 8a ff 	j 80000ca6 <IfxStm_initCompare+0x2e>
        comcon.B.MSIZE1  = config->compareSize;
80000d96:	19 54 0c 00 	ld.w %d4,[%a5]12
80000d9a:	37 42 05 28 	insert %d2,%d2,%d4,16,5
        comcon.B.MSTART1 = config->compareOffset;
80000d9e:	19 54 08 00 	ld.w %d4,[%a5]8
80000da2:	37 42 05 2c 	insert %d2,%d2,%d4,24,5
        icr.B.CMP1OS     = config->comparatorInterrupt;
80000da6:	19 54 04 00 	ld.w %d4,[%a5]4
80000daa:	67 43 06 30 	ins.t %d3,%d3,6,%d4,0
        result           = TRUE;
80000dae:	82 18       	mov %d8,1
80000db0:	1d ff 7b ff 	j 80000ca6 <IfxStm_initCompare+0x2e>
            srcr = &(MODULE_SRC.STM.STM[index].SR[1]);
80000db4:	06 32       	sh %d2,3
80000db6:	c2 42       	add %d2,4
80000db8:	7b 40 00 4f 	movh %d4,61444
80000dbc:	1b 04 30 48 	addi %d4,%d4,-32000
80000dc0:	60 42       	mov.a %a2,%d4
80000dc2:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80000dc6:	1d ff 87 ff 	j 80000cd4 <IfxStm_initCompare+0x5c>

80000dca <IfxStm_initCompareConfig>:


void IfxStm_initCompareConfig(IfxStm_CompareConfig *config)
{
80000dca:	40 ae       	mov.aa %a14,%sp
    config->comparator          = IfxStm_Comparator_0;
80000dcc:	82 02       	mov %d2,0
80000dce:	74 42       	st.w [%a4],%d2
    config->compareOffset       = IfxStm_ComparatorOffset_0;
80000dd0:	59 42 08 00 	st.w [%a4]8,%d2
    config->compareSize         = IfxStm_ComparatorSize_32Bits;
80000dd4:	3b f0 01 30 	mov %d3,31
80000dd8:	59 43 0c 00 	st.w [%a4]12,%d3
    config->comparatorInterrupt = IfxStm_ComparatorInterrupt_ir0;     /*User must select the interrupt output */
80000ddc:	59 42 04 00 	st.w [%a4]4,%d2
    config->ticks               = 0xFFFFFFFF;
80000de0:	82 f3       	mov %d3,-1
80000de2:	59 43 10 00 	st.w [%a4]16,%d3
    config->triggerPriority     = 0;
80000de6:	f9 42 14 00 	st.h [%a4]20,%d2
    config->typeOfService       = IfxSrc_Tos_cpu0;
80000dea:	59 42 18 00 	st.w [%a4]24,%d2
}
80000dee:	00 90       	ret 

80000df0 <IfxScuCcu_calRGainParameters>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxScuCcu_calRGainParameters(IfxScuCcu_ModulationAmplitude modamp, IfxScuCcu_RGain_Values *RGain_P)
{
80000df0:	40 ae       	mov.aa %a14,%sp
    float32  mod_amp       = IfxScuCcu_MA_percent[modamp];
80000df2:	8f 24 00 20 	sh %d2,%d4,2
80000df6:	91 00 00 28 	movh.a %a2,32768
80000dfa:	d9 22 00 b0 	lea %a2,[%a2]704 <800002c0 <IfxScuCcu_MA_percent>>
80000dfe:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80000e02:	54 22       	ld.w %d2,[%a2]

IFX_INLINE float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc1)
80000e04:	91 30 00 2f 	movh.a %a2,61443
80000e08:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80000e0c:	54 23       	ld.w %d3,[%a2]
80000e0e:	8f 23 1e 30 	sh %d3,%d3,-30
80000e12:	df 03 15 00 	jeq %d3,0,80000e3c <IfxScuCcu_calRGainParameters+0x4c>
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc0)
80000e16:	54 23       	ld.w %d3,[%a2]
80000e18:	8f 23 1e 30 	sh %d3,%d3,-30
80000e1c:	df 13 47 00 	jeq %d3,1,80000eaa <IfxScuCcu_calRGainParameters+0xba>
    {
        freq = (float32)IFX_CFG_SCU_XTAL_FREQUENCY;
    }
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fSysclk)
80000e20:	54 23       	ld.w %d3,[%a2]
80000e22:	8f 23 1e 30 	sh %d3,%d3,-30
80000e26:	df 23 05 00 	jeq %d3,2,80000e30 <IfxScuCcu_calRGainParameters+0x40>
        freq = IFX_CFG_SCU_SYSCLK_FREQUENCY;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80000e2a:	82 04       	mov %d4,0
80000e2c:	1d 00 0c 00 	j 80000e44 <IfxScuCcu_calRGainParameters+0x54>
        freq = IFX_CFG_SCU_SYSCLK_FREQUENCY;
80000e30:	7b 90 b9 44 	movh %d4,19353
80000e34:	1b 04 68 49 	addi %d4,%d4,-27008
80000e38:	1d 00 06 00 	j 80000e44 <IfxScuCcu_calRGainParameters+0x54>
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80000e3c:	7b f0 cb 44 	movh %d4,19647
80000e40:	1b 04 c2 4b 	addi %d4,%d4,-17376
    float32 *RGainNom_Temp = &(RGain_P->RGainNom);
    uint16  *RGain_Temp    = &(RGain_P->RGainHex);

    Ifx_SCU *scu           = &MODULE_SCU;
    float32  Fosc_Hz       = IfxScuCcu_getOscFrequency();
    float32  Fdco_hz       = (Fosc_Hz * (scu->SYSPLLCON0.B.NDIV + 1)) / (scu->SYSPLLCON0.B.PDIV + 1);
80000e44:	91 30 00 2f 	movh.a %a2,61443
80000e48:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <bmhd_3_copy+0x40c34a00>>
80000e4c:	d9 23 18 00 	lea %a3,[%a2]24 <f0030018 <bmhd_3_copy+0x40c2ea18>>
80000e50:	19 23 18 00 	ld.w %d3,[%a2]24 <f0030018 <bmhd_3_copy+0x40c2ea18>>
80000e54:	37 03 e7 34 	extr.u %d3,%d3,9,7
80000e58:	c2 13       	add %d3,1
80000e5a:	4b 03 41 31 	itof %d3,%d3
80000e5e:	4b 43 41 40 	mul.f %d4,%d3,%d4
80000e62:	54 33       	ld.w %d3,[%a3]
80000e64:	37 03 63 3c 	extr.u %d3,%d3,24,3
80000e68:	c2 13       	add %d3,1
80000e6a:	4b 03 41 31 	itof %d3,%d3
80000e6e:	4b 34 51 40 	div.f %d4,%d4,%d3

    *RGainNom_Temp = IFXSCUCCU_GET_RGAIN_NOM(mod_amp, Fdco_hz);
80000e72:	7b 80 2c 34 	movh %d3,17096
80000e76:	4b 32 51 30 	div.f %d3,%d2,%d3
80000e7a:	6b 03 21 33 	add.f %d3,%d3,%d3
80000e7e:	7b c0 a5 24 	movh %d2,19036
80000e82:	1b 02 a0 2b 	addi %d2,%d2,-17920
80000e86:	4b 24 51 20 	div.f %d2,%d4,%d2
80000e8a:	4b 23 41 20 	mul.f %d2,%d3,%d2
80000e8e:	74 42       	st.w [%a4],%d2
    *RGain_Temp    = IFXSCUCCU_GET_RGAIN_HEX(*RGainNom_Temp);
80000e90:	7b 00 20 34 	movh %d3,16896
80000e94:	4b 32 41 20 	mul.f %d2,%d2,%d3
80000e98:	7b 00 f0 33 	movh %d3,16128
80000e9c:	6b 03 21 22 	add.f %d2,%d2,%d3
80000ea0:	4b 02 71 21 	ftouz %d2,%d2
80000ea4:	f9 42 04 00 	st.h [%a4]4,%d2
}
80000ea8:	00 90       	ret 
        freq = (float32)IFX_CFG_SCU_XTAL_FREQUENCY;
80000eaa:	7b 90 b9 44 	movh %d4,19353
80000eae:	1b 04 68 49 	addi %d4,%d4,-27008
80000eb2:	1d ff c9 ff 	j 80000e44 <IfxScuCcu_calRGainParameters+0x54>

80000eb6 <IfxScuCcu_getPerPllFrequency1>:
    return mscFreq;
}


float32 IfxScuCcu_getPerPllFrequency1(void)
{
80000eb6:	40 ae       	mov.aa %a14,%sp
    if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc1)
80000eb8:	91 30 00 2f 	movh.a %a2,61443
80000ebc:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80000ec0:	54 22       	ld.w %d2,[%a2]
80000ec2:	8f 22 1e 20 	sh %d2,%d2,-30
80000ec6:	df 02 15 00 	jeq %d2,0,80000ef0 <IfxScuCcu_getPerPllFrequency1+0x3a>
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc0)
80000eca:	54 22       	ld.w %d2,[%a2]
80000ecc:	8f 22 1e 20 	sh %d2,%d2,-30
80000ed0:	df 12 32 00 	jeq %d2,1,80000f34 <IfxScuCcu_getPerPllFrequency1+0x7e>
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fSysclk)
80000ed4:	54 22       	ld.w %d2,[%a2]
80000ed6:	8f 22 1e 20 	sh %d2,%d2,-30
80000eda:	df 22 05 00 	jeq %d2,2,80000ee4 <IfxScuCcu_getPerPllFrequency1+0x2e>
        freq = 0.0f;
80000ede:	82 04       	mov %d4,0
80000ee0:	1d 00 0c 00 	j 80000ef8 <IfxScuCcu_getPerPllFrequency1+0x42>
        freq = IFX_CFG_SCU_SYSCLK_FREQUENCY;
80000ee4:	7b 90 b9 44 	movh %d4,19353
80000ee8:	1b 04 68 49 	addi %d4,%d4,-27008
80000eec:	1d 00 06 00 	j 80000ef8 <IfxScuCcu_getPerPllFrequency1+0x42>
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80000ef0:	7b f0 cb 44 	movh %d4,19647
80000ef4:	1b 04 c2 4b 	addi %d4,%d4,-17376
    Ifx_SCU *scu = &MODULE_SCU;
    float32  pllFrequency1;
    float32  oscFreq;
    oscFreq       = IfxScuCcu_getOscFrequency();

    pllFrequency1 = (oscFreq * (scu->PERPLLCON0.B.NDIV + 1)) / ((scu->PERPLLCON0.B.PDIV + 1) * (scu->PERPLLCON1.B.K2DIV + 1));
80000ef8:	91 30 00 2f 	movh.a %a2,61443
80000efc:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <bmhd_3_copy+0x40c34a00>>
80000f00:	d9 23 28 00 	lea %a3,[%a2]40 <f0030028 <bmhd_3_copy+0x40c2ea28>>
80000f04:	19 22 28 00 	ld.w %d2,[%a2]40 <f0030028 <bmhd_3_copy+0x40c2ea28>>
80000f08:	37 02 e7 24 	extr.u %d2,%d2,9,7
80000f0c:	c2 12       	add %d2,1
80000f0e:	4b 02 41 21 	itof %d2,%d2
80000f12:	4b 42 41 40 	mul.f %d4,%d2,%d4
80000f16:	54 32       	ld.w %d2,[%a3]
80000f18:	37 02 63 2c 	extr.u %d2,%d2,24,3
80000f1c:	19 23 2c 00 	ld.w %d3,[%a2]44 <f003002c <bmhd_3_copy+0x40c2ea2c>>
80000f20:	8f 73 00 31 	and %d3,%d3,7
80000f24:	c2 13       	add %d3,1
80000f26:	03 32 0a 23 	madd %d2,%d3,%d2,%d3
80000f2a:	4b 02 41 21 	itof %d2,%d2

    return pllFrequency1;
}
80000f2e:	4b 24 51 20 	div.f %d2,%d4,%d2
80000f32:	00 90       	ret 
        freq = (float32)IFX_CFG_SCU_XTAL_FREQUENCY;
80000f34:	7b 90 b9 44 	movh %d4,19353
80000f38:	1b 04 68 49 	addi %d4,%d4,-27008
80000f3c:	1d ff de ff 	j 80000ef8 <IfxScuCcu_getPerPllFrequency1+0x42>

80000f40 <IfxScuCcu_getPerPllFrequency2>:


float32 IfxScuCcu_getPerPllFrequency2(void)
{
80000f40:	40 ae       	mov.aa %a14,%sp
    if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc1)
80000f42:	91 30 00 2f 	movh.a %a2,61443
80000f46:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80000f4a:	54 22       	ld.w %d2,[%a2]
80000f4c:	8f 22 1e 20 	sh %d2,%d2,-30
80000f50:	df 02 15 00 	jeq %d2,0,80000f7a <IfxScuCcu_getPerPllFrequency2+0x3a>
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc0)
80000f54:	54 22       	ld.w %d2,[%a2]
80000f56:	8f 22 1e 20 	sh %d2,%d2,-30
80000f5a:	df 12 40 00 	jeq %d2,1,80000fda <IfxScuCcu_getPerPllFrequency2+0x9a>
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fSysclk)
80000f5e:	54 22       	ld.w %d2,[%a2]
80000f60:	8f 22 1e 20 	sh %d2,%d2,-30
80000f64:	df 22 05 00 	jeq %d2,2,80000f6e <IfxScuCcu_getPerPllFrequency2+0x2e>
        freq = 0.0f;
80000f68:	82 02       	mov %d2,0
80000f6a:	1d 00 0c 00 	j 80000f82 <IfxScuCcu_getPerPllFrequency2+0x42>
        freq = IFX_CFG_SCU_SYSCLK_FREQUENCY;
80000f6e:	7b 90 b9 24 	movh %d2,19353
80000f72:	1b 02 68 29 	addi %d2,%d2,-27008
80000f76:	1d 00 06 00 	j 80000f82 <IfxScuCcu_getPerPllFrequency2+0x42>
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80000f7a:	7b f0 cb 24 	movh %d2,19647
80000f7e:	1b 02 c2 2b 	addi %d2,%d2,-17376
    Ifx_SCU *scu = &MODULE_SCU;
    float32  pllFrequency2;
    float32  oscFreq;
    oscFreq = IfxScuCcu_getOscFrequency();

    if (!(scu->PERPLLCON0.B.DIVBY))
80000f82:	91 30 00 2f 	movh.a %a2,61443
80000f86:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <bmhd_3_copy+0x40c34a00>>
80000f8a:	19 23 28 00 	ld.w %d3,[%a2]40 <f0030028 <bmhd_3_copy+0x40c2ea28>>
80000f8e:	6f 03 2c 80 	jnz.t %d3,0,80000fe6 <IfxScuCcu_getPerPllFrequency2+0xa6>
    {
        pllFrequency2 = (oscFreq * (scu->PERPLLCON0.B.NDIV + 1)) / ((scu->PERPLLCON0.B.PDIV + 1) * (scu->PERPLLCON1.B.K3DIV + 1) * 1.6f);
80000f92:	91 30 00 2f 	movh.a %a2,61443
80000f96:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <bmhd_3_copy+0x40c34a00>>
80000f9a:	d9 23 28 00 	lea %a3,[%a2]40 <f0030028 <bmhd_3_copy+0x40c2ea28>>
80000f9e:	19 23 28 00 	ld.w %d3,[%a2]40 <f0030028 <bmhd_3_copy+0x40c2ea28>>
80000fa2:	37 03 e7 34 	extr.u %d3,%d3,9,7
80000fa6:	c2 13       	add %d3,1
80000fa8:	4b 03 41 31 	itof %d3,%d3
80000fac:	4b 23 41 30 	mul.f %d3,%d3,%d2
80000fb0:	54 34       	ld.w %d4,[%a3]
80000fb2:	37 04 63 4c 	extr.u %d4,%d4,24,3
80000fb6:	19 22 2c 00 	ld.w %d2,[%a2]44 <f003002c <bmhd_3_copy+0x40c2ea2c>>
80000fba:	37 02 63 24 	extr.u %d2,%d2,8,3
80000fbe:	c2 12       	add %d2,1
80000fc0:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
80000fc4:	4b 02 41 21 	itof %d2,%d2
80000fc8:	7b d0 fc 43 	movh %d4,16333
80000fcc:	1b d4 cc 4c 	addi %d4,%d4,-13107
80000fd0:	4b 42 41 20 	mul.f %d2,%d2,%d4
80000fd4:	4b 23 51 20 	div.f %d2,%d3,%d2
80000fd8:	00 90       	ret 
        freq = (float32)IFX_CFG_SCU_XTAL_FREQUENCY;
80000fda:	7b 90 b9 24 	movh %d2,19353
80000fde:	1b 02 68 29 	addi %d2,%d2,-27008
80000fe2:	1d ff d0 ff 	j 80000f82 <IfxScuCcu_getPerPllFrequency2+0x42>
    }
    else
    {
        pllFrequency2 = (oscFreq * (scu->PERPLLCON0.B.NDIV + 1)) / ((scu->PERPLLCON0.B.PDIV + 1) * (scu->PERPLLCON1.B.K3DIV + 1) * 2);
80000fe6:	91 30 00 2f 	movh.a %a2,61443
80000fea:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <bmhd_3_copy+0x40c34a00>>
80000fee:	d9 23 28 00 	lea %a3,[%a2]40 <f0030028 <bmhd_3_copy+0x40c2ea28>>
80000ff2:	19 23 28 00 	ld.w %d3,[%a2]40 <f0030028 <bmhd_3_copy+0x40c2ea28>>
80000ff6:	37 03 e7 34 	extr.u %d3,%d3,9,7
80000ffa:	c2 13       	add %d3,1
80000ffc:	4b 03 41 31 	itof %d3,%d3
80001000:	4b 23 41 30 	mul.f %d3,%d3,%d2
80001004:	54 34       	ld.w %d4,[%a3]
80001006:	37 04 63 4c 	extr.u %d4,%d4,24,3
8000100a:	19 22 2c 00 	ld.w %d2,[%a2]44 <f003002c <bmhd_3_copy+0x40c2ea2c>>
8000100e:	37 02 63 24 	extr.u %d2,%d2,8,3
80001012:	c2 12       	add %d2,1
80001014:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
80001018:	06 12       	sh %d2,1
8000101a:	4b 02 41 21 	itof %d2,%d2
8000101e:	4b 23 51 20 	div.f %d2,%d3,%d2
    }

    return pllFrequency2;
}
80001022:	00 90       	ret 

80001024 <IfxScuCcu_getPllFrequency>:


float32 IfxScuCcu_getPllFrequency(void)
{
80001024:	40 ae       	mov.aa %a14,%sp
    if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc1)
80001026:	91 30 00 2f 	movh.a %a2,61443
8000102a:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
8000102e:	54 22       	ld.w %d2,[%a2]
80001030:	8f 22 1e 20 	sh %d2,%d2,-30
80001034:	df 02 15 00 	jeq %d2,0,8000105e <IfxScuCcu_getPllFrequency+0x3a>
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc0)
80001038:	54 22       	ld.w %d2,[%a2]
8000103a:	8f 22 1e 20 	sh %d2,%d2,-30
8000103e:	df 12 31 00 	jeq %d2,1,800010a0 <IfxScuCcu_getPllFrequency+0x7c>
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fSysclk)
80001042:	54 22       	ld.w %d2,[%a2]
80001044:	8f 22 1e 20 	sh %d2,%d2,-30
80001048:	df 22 05 00 	jeq %d2,2,80001052 <IfxScuCcu_getPllFrequency+0x2e>
        freq = 0.0f;
8000104c:	82 04       	mov %d4,0
8000104e:	1d 00 0c 00 	j 80001066 <IfxScuCcu_getPllFrequency+0x42>
        freq = IFX_CFG_SCU_SYSCLK_FREQUENCY;
80001052:	7b 90 b9 44 	movh %d4,19353
80001056:	1b 04 68 49 	addi %d4,%d4,-27008
8000105a:	1d 00 06 00 	j 80001066 <IfxScuCcu_getPllFrequency+0x42>
        freq = IFXSCU_EVR_OSC_FREQUENCY;
8000105e:	7b f0 cb 44 	movh %d4,19647
80001062:	1b 04 c2 4b 	addi %d4,%d4,-17376
    Ifx_SCU *scu = &MODULE_SCU;
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();
    freq    = (oscFreq * (scu->SYSPLLCON0.B.NDIV + 1)) / ((scu->SYSPLLCON1.B.K2DIV + 1) * (scu->SYSPLLCON0.B.PDIV + 1));
80001066:	91 30 00 2f 	movh.a %a2,61443
8000106a:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <bmhd_3_copy+0x40c34a00>>
8000106e:	19 22 18 00 	ld.w %d2,[%a2]24 <f0030018 <bmhd_3_copy+0x40c2ea18>>
80001072:	37 02 e7 24 	extr.u %d2,%d2,9,7
80001076:	c2 12       	add %d2,1
80001078:	4b 02 41 21 	itof %d2,%d2
8000107c:	4b 42 41 40 	mul.f %d4,%d2,%d4
80001080:	19 22 1c 00 	ld.w %d2,[%a2]28 <f003001c <bmhd_3_copy+0x40c2ea1c>>
80001084:	8f 72 00 21 	and %d2,%d2,7
80001088:	19 23 18 00 	ld.w %d3,[%a2]24 <f0030018 <bmhd_3_copy+0x40c2ea18>>
8000108c:	37 03 63 3c 	extr.u %d3,%d3,24,3
80001090:	c2 13       	add %d3,1
80001092:	03 32 0a 23 	madd %d2,%d3,%d2,%d3
80001096:	4b 02 41 21 	itof %d2,%d2
    return freq;
}
8000109a:	4b 24 51 20 	div.f %d2,%d4,%d2
8000109e:	00 90       	ret 
        freq = (float32)IFX_CFG_SCU_XTAL_FREQUENCY;
800010a0:	7b 90 b9 44 	movh %d4,19353
800010a4:	1b 04 68 49 	addi %d4,%d4,-27008
800010a8:	1d ff df ff 	j 80001066 <IfxScuCcu_getPllFrequency+0x42>

800010ac <IfxScuCcu_getSourceFrequency>:
    return freq;
}


float32 IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource fsource)
{
800010ac:	40 ae       	mov.aa %a14,%sp
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
800010ae:	91 30 00 2f 	movh.a %a2,61443
800010b2:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
800010b6:	54 22       	ld.w %d2,[%a2]
800010b8:	37 02 62 2e 	extr.u %d2,%d2,28,2
800010bc:	df 02 20 00 	jeq %d2,0,800010fc <IfxScuCcu_getSourceFrequency+0x50>
800010c0:	df 12 23 80 	jne %d2,1,80001106 <IfxScuCcu_getSourceFrequency+0x5a>
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:

        switch (fsource)
800010c4:	df 14 0b 00 	jeq %d4,1,800010da <IfxScuCcu_getSourceFrequency+0x2e>
800010c8:	df 24 17 00 	jeq %d4,2,800010f6 <IfxScuCcu_getSourceFrequency+0x4a>
800010cc:	df 04 04 00 	jeq %d4,0,800010d4 <IfxScuCcu_getSourceFrequency+0x28>
800010d0:	82 02       	mov %d2,0
        sourcefreq = 0;
        break;
    }

    return sourcefreq;
}
800010d2:	00 90       	ret 
            sourcefreq = IfxScuCcu_getPllFrequency();
800010d4:	6d ff a8 ff 	call 80001024 <IfxScuCcu_getPllFrequency>
            break;
800010d8:	00 90       	ret 
            sourcefreq = IfxScuCcu_getPerPllFrequency1();
800010da:	6d ff ee fe 	call 80000eb6 <IfxScuCcu_getPerPllFrequency1>
            if (SCU_CCUCON1.B.PLL1DIVDIS == 0)
800010de:	91 30 00 2f 	movh.a %a2,61443
800010e2:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
800010e6:	54 23       	ld.w %d3,[%a2]
800010e8:	6f 73 f5 ff 	jnz.t %d3,7,800010d2 <IfxScuCcu_getSourceFrequency+0x26>
                sourcefreq = sourcefreq / 2.0f;
800010ec:	7b 00 f0 33 	movh %d3,16128
800010f0:	4b 32 41 20 	mul.f %d2,%d2,%d3
800010f4:	00 90       	ret 
            sourcefreq = IfxScuCcu_getPerPllFrequency2();
800010f6:	6d ff 25 ff 	call 80000f40 <IfxScuCcu_getPerPllFrequency2>
            break;
800010fa:	00 90       	ret 
    switch (SCU_CCUCON0.B.CLKSEL)
800010fc:	7b f0 cb 24 	movh %d2,19647
80001100:	1b 02 c2 2b 	addi %d2,%d2,-17376
80001104:	00 90       	ret 
        sourcefreq = 0;
80001106:	82 02       	mov %d2,0
80001108:	00 90       	ret 

8000110a <IfxScuCcu_modulation_init>:
    *cfg = IfxScuCcu_defaultClockConfig;
}


void IfxScuCcu_modulation_init(const IfxScuCcu_Mod_Config *Mod_Cfg)
{
8000110a:	40 ae       	mov.aa %a14,%sp
8000110c:	20 08       	sub.a %sp,8
    uint16                        endinitSfty_pw;
    IfxScuCcu_RGain_Values        RGain_P;
    IfxScuCcu_ModEn               mod_enable = Mod_Cfg->Mod_Enable;
8000110e:	54 42       	ld.w %d2,[%a4]
    IfxScuCcu_ModulationAmplitude Mod_Amp    = Mod_Cfg->Mod_Amp;
80001110:	19 44 04 00 	ld.w %d4,[%a4]4

    Ifx_SCU_SYSPLLCON0            syspllcon0;
    Ifx_SCU_SYSPLLCON2            syspllcon2;

    if (mod_enable == IfxScuCcu_ModEn_enabled)  /* do this only if modulation is enabled */
80001114:	df 12 03 00 	jeq %d2,1,8000111a <IfxScuCcu_modulation_init+0x10>
        SCU_SYSPLLCON0.U   = syspllcon0.U;

        /* set the endinit protection again */
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
}
80001118:	00 90       	ret 
        IfxScuCcu_calRGainParameters(Mod_Amp, &RGain_P);
8000111a:	d9 e4 f8 ff 	lea %a4,[%a14]-8
8000111e:	6d ff 69 fe 	call 80000df0 <IfxScuCcu_calRGainParameters>
        endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80001122:	6d 00 37 05 	call 80001b90 <IfxScuWdt_getSafetyWatchdogPassword>
80001126:	02 28       	mov %d8,%d2
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80001128:	02 24       	mov %d4,%d2
8000112a:	6d 00 6b 04 	call 80001a00 <IfxScuWdt_clearSafetyEndinit>
        syspllcon2.U        = SCU_SYSPLLCON2.U;
8000112e:	91 30 00 2f 	movh.a %a2,61443
80001132:	d9 22 20 06 	lea %a2,[%a2]24608 <f0036020 <bmhd_3_copy+0x40c34a20>>
80001136:	54 22       	ld.w %d2,[%a2]
        syspllcon2.B.MODCFG = IFXSCUCCU_GET_MODCFG(RGain_P.RGainHex);
80001138:	b9 e3 fc ff 	ld.hu %d3,[%a14]-4 <f0036020 <bmhd_3_copy+0x40c34a20>>
8000113c:	3b 00 40 4f 	mov %d4,-3072
80001140:	a6 43       	or %d3,%d4
80001142:	37 32 10 20 	insert %d2,%d2,%d3,0,16
        SCU_SYSPLLCON2.U    = syspllcon2.U;
80001146:	74 22       	st.w [%a2],%d2
        syspllcon0.U       = SCU_SYSPLLCON0.U;
80001148:	91 30 00 2f 	movh.a %a2,61443
8000114c:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80001150:	54 22       	ld.w %d2,[%a2]
        syspllcon0.B.MODEN = (uint32)IfxScuCcu_ModEn_enabled;
80001152:	b7 12 01 21 	insert %d2,%d2,1,2,1
        SCU_SYSPLLCON0.U   = syspllcon0.U;
80001156:	74 22       	st.w [%a2],%d2
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80001158:	02 84       	mov %d4,%d8
8000115a:	6d 00 4b 05 	call 80001bf0 <IfxScuWdt_setSafetyEndinit>
}
8000115e:	1d ff dd ff 	j 80001118 <IfxScuCcu_modulation_init+0xe>

80001162 <IfxScuCcu_init>:
{
80001162:	40 ae       	mov.aa %a14,%sp
80001164:	40 4c       	mov.aa %a12,%a4
    Ifx_SCU_WDTS *watchdog = &MODULE_SCU.WDTS;

    /* Read Password from Safety WDT CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
80001166:	91 30 00 2f 	movh.a %a2,61443
8000116a:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000116e:	54 22       	ld.w %d2,[%a2]
80001170:	37 02 6e 21 	extr.u %d2,%d2,2,14
    IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);
80001174:	8f f2 83 21 	xor %d2,%d2,63
    if (SCU_WDTS_CON0.B.LCK)
80001178:	54 23       	ld.w %d3,[%a2]
8000117a:	6f 13 0b 00 	jz.t %d3,1,80001190 <IfxScuCcu_init+0x2e>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000117e:	8f 22 00 40 	sh %d4,%d2,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001182:	8f 14 40 41 	or %d4,%d4,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001186:	54 23       	ld.w %d3,[%a2]
80001188:	b7 03 10 30 	insert %d3,%d3,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000118c:	a6 43       	or %d3,%d4
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000118e:	74 23       	st.w [%a2],%d3
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001190:	8f 22 00 50 	sh %d5,%d2,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001194:	8f 25 40 31 	or %d3,%d5,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001198:	91 30 00 2f 	movh.a %a2,61443
8000119c:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800011a0:	54 22       	ld.w %d2,[%a2]
800011a2:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800011a6:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800011a8:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
800011aa:	91 30 00 2f 	movh.a %a2,61443
800011ae:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800011b2:	54 22       	ld.w %d2,[%a2]
800011b4:	6f 02 fb ff 	jnz.t %d2,0,800011aa <IfxScuCcu_init+0x48>
    timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
800011b8:	3b 00 00 21 	mov %d2,4096
    while (SCU_CCUCON0.B.LCK != 0U)
800011bc:	91 30 00 2f 	movh.a %a2,61443
800011c0:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
800011c4:	54 23       	ld.w %d3,[%a2]
800011c6:	ff 03 08 00 	jge %d3,0,800011d6 <IfxScuCcu_init+0x74>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800011ca:	c2 f2       	add %d2,-1
800011cc:	ff 12 f8 7f 	jge %d2,1,800011bc <IfxScuCcu_init+0x5a>
800011d0:	82 19       	mov %d9,1
800011d2:	1d 00 03 00 	j 800011d8 <IfxScuCcu_init+0x76>
    uint8                                initError = 0;
800011d6:	82 09       	mov %d9,0
        scuCcucon0.U        = SCU_CCUCON0.U;
800011d8:	91 30 00 2f 	movh.a %a2,61443
800011dc:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
800011e0:	54 22       	ld.w %d2,[%a2]
        scuCcucon0.B.CLKSEL = 0; /*Select the EVR as fsource0/1/2 for the clock distribution */
800011e2:	b7 02 02 2e 	insert %d2,%d2,0,28,2
        scuCcucon0.B.UP     = 1; /*Update the ccucon0 register */
800011e6:	b7 12 01 2f 	insert %d2,%d2,1,30,1
        SCU_CCUCON0.U       = scuCcucon0.U;
800011ea:	74 22       	st.w [%a2],%d2
    timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
800011ec:	3b 00 00 21 	mov %d2,4096
    while (SCU_CCUCON0.B.LCK != 0U)
800011f0:	91 30 00 2f 	movh.a %a2,61443
800011f4:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
800011f8:	54 23       	ld.w %d3,[%a2]
800011fa:	ff 03 06 00 	jge %d3,0,80001206 <IfxScuCcu_init+0xa4>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800011fe:	c2 f2       	add %d2,-1
80001200:	ff 12 f8 7f 	jge %d2,1,800011f0 <IfxScuCcu_init+0x8e>
80001204:	82 19       	mov %d9,1
        SMU_KEYS.U    = (uint32)0xBCU;        /* Enable access to SMU registers */
80001206:	91 30 00 2f 	movh.a %a2,61443
8000120a:	d9 22 b4 06 	lea %a2,[%a2]26676 <f0036834 <bmhd_3_copy+0x40c35234>>
8000120e:	3b c0 0b 20 	mov %d2,188
80001212:	74 22       	st.w [%a2],%d2
        SMU_AG8CF0.U &= ~IFXSCUCCU_SMUALARM_MASK;
80001214:	91 30 00 3f 	movh.a %a3,61443
80001218:	d9 33 a0 56 	lea %a3,[%a3]26976 <f0036960 <bmhd_3_copy+0x40c35360>>
8000121c:	54 32       	ld.w %d2,[%a3]
8000121e:	8f d2 c1 21 	andn %d2,%d2,29
80001222:	74 32       	st.w [%a3],%d2
        SMU_AG8CF1.U &= ~IFXSCUCCU_SMUALARM_MASK;
80001224:	91 30 00 3f 	movh.a %a3,61443
80001228:	d9 33 a4 56 	lea %a3,[%a3]26980 <f0036964 <bmhd_3_copy+0x40c35364>>
8000122c:	54 32       	ld.w %d2,[%a3]
8000122e:	8f d2 c1 21 	andn %d2,%d2,29
80001232:	74 32       	st.w [%a3],%d2
        SMU_AG8CF2.U &= ~IFXSCUCCU_SMUALARM_MASK;
80001234:	91 30 00 3f 	movh.a %a3,61443
80001238:	d9 33 a8 56 	lea %a3,[%a3]26984 <f0036968 <bmhd_3_copy+0x40c35368>>
8000123c:	54 32       	ld.w %d2,[%a3]
8000123e:	8f d2 c1 21 	andn %d2,%d2,29
80001242:	74 32       	st.w [%a3],%d2
        SMU_KEYS.U    = (uint32)0U;
80001244:	82 02       	mov %d2,0
80001246:	74 22       	st.w [%a2],%d2
    SCU_SYSPLLCON0.B.PLLPWD = 0;
80001248:	91 30 00 2f 	movh.a %a2,61443
8000124c:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80001250:	54 22       	ld.w %d2,[%a2]
80001252:	7b f0 ff 3f 	movh %d3,65535
80001256:	c2 f3       	add %d3,-1
80001258:	26 32       	and %d2,%d3
8000125a:	74 22       	st.w [%a2],%d2
    SCU_PERPLLCON0.B.PLLPWD = 0;
8000125c:	91 30 00 2f 	movh.a %a2,61443
80001260:	d9 22 28 06 	lea %a2,[%a2]24616 <f0036028 <bmhd_3_copy+0x40c34a28>>
80001264:	54 22       	ld.w %d2,[%a2]
80001266:	26 32       	and %d2,%d3
80001268:	74 22       	st.w [%a2],%d2
    timeoutCycleCount       = IFXSCUCCU_SYSPLLSTAT_PWDSTAT_TIMEOUT_COUNT;
8000126a:	3b 00 00 23 	mov %d2,12288
    while ((SCU_SYSPLLSTAT.B.PWDSTAT == 0) || (SCU_PERPLLSTAT.B.PWDSTAT == 0))
8000126e:	1d 00 05 00 	j 80001278 <IfxScuCcu_init+0x116>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80001272:	c2 f2       	add %d2,-1
80001274:	bf 12 45 00 	jlt %d2,1,800012fe <IfxScuCcu_init+0x19c>
    while ((SCU_SYSPLLSTAT.B.PWDSTAT == 0) || (SCU_PERPLLSTAT.B.PWDSTAT == 0))
80001278:	91 30 00 2f 	movh.a %a2,61443
8000127c:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <bmhd_3_copy+0x40c34a14>>
80001280:	54 23       	ld.w %d3,[%a2]
80001282:	6f 13 f8 7f 	jz.t %d3,1,80001272 <IfxScuCcu_init+0x110>
80001286:	91 30 00 2f 	movh.a %a2,61443
8000128a:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <bmhd_3_copy+0x40c34a24>>
8000128e:	54 23       	ld.w %d3,[%a2]
80001290:	6f 13 f1 7f 	jz.t %d3,1,80001272 <IfxScuCcu_init+0x110>
    if ((pllsParamCfg->pllInputClockSelection == IfxScuCcu_PllInputClockSelection_fOsc0) || (pllsParamCfg->pllInputClockSelection == IfxScuCcu_PllInputClockSelection_fSysclk))
80001294:	19 c2 04 00 	ld.w %d2,[%a12]4
80001298:	c2 f2       	add %d2,-1
8000129a:	bf 22 35 80 	jlt.u %d2,2,80001304 <IfxScuCcu_init+0x1a2>
        sysPllCon0.U       = SCU_SYSPLLCON0.U;
8000129e:	91 30 00 3f 	movh.a %a3,61443
800012a2:	d9 33 18 06 	lea %a3,[%a3]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
800012a6:	54 32       	ld.w %d2,[%a3]
        sysPllCon0.B.PDIV  = pllsParamCfg->sysPllConfig.pDivider;
800012a8:	39 c3 08 00 	ld.bu %d3,[%a12]8 <f0036018 <bmhd_3_copy+0x40c34a18>>
800012ac:	37 32 03 2c 	insert %d2,%d2,%d3,24,3
        sysPllCon0.B.NDIV  = pllsParamCfg->sysPllConfig.nDivider;
800012b0:	39 c3 09 00 	ld.bu %d3,[%a12]9
800012b4:	37 32 87 24 	insert %d2,%d2,%d3,9,7
        sysPllCon0.B.INSEL = pllsParamCfg->pllInputClockSelection;
800012b8:	19 c3 04 00 	ld.w %d3,[%a12]4
800012bc:	37 32 02 2f 	insert %d2,%d2,%d3,30,2
        SCU_SYSPLLCON0.U   = sysPllCon0.U;
800012c0:	74 32       	st.w [%a3],%d2
        scuPerPllCon0.U       = SCU_PERPLLCON0.U;
800012c2:	91 30 00 2f 	movh.a %a2,61443
800012c6:	d9 22 28 06 	lea %a2,[%a2]24616 <f0036028 <bmhd_3_copy+0x40c34a28>>
800012ca:	54 22       	ld.w %d2,[%a2]
        scuPerPllCon0.B.DIVBY = pllsParamCfg->perPllConfig.k3DividerBypass;
800012cc:	39 c3 10 00 	ld.bu %d3,[%a12]16 <f0036028 <bmhd_3_copy+0x40c34a28>>
800012d0:	67 32 00 20 	ins.t %d2,%d2,0,%d3,0
        scuPerPllCon0.B.PDIV  = pllsParamCfg->perPllConfig.pDivider;
800012d4:	39 c3 0c 00 	ld.bu %d3,[%a12]12
800012d8:	37 32 03 2c 	insert %d2,%d2,%d3,24,3
        scuPerPllCon0.B.NDIV  = pllsParamCfg->perPllConfig.nDivider;
800012dc:	39 c3 0d 00 	ld.bu %d3,[%a12]13
800012e0:	37 32 87 24 	insert %d2,%d2,%d3,9,7
        SCU_PERPLLCON0.U      = scuPerPllCon0.U;
800012e4:	74 22       	st.w [%a2],%d2
    SCU_SYSPLLCON0.B.PLLPWD = 1;
800012e6:	54 32       	ld.w %d2,[%a3]
800012e8:	b7 12 01 28 	insert %d2,%d2,1,16,1
800012ec:	74 32       	st.w [%a3],%d2
    SCU_PERPLLCON0.B.PLLPWD = 1;
800012ee:	54 22       	ld.w %d2,[%a2]
800012f0:	b7 12 01 28 	insert %d2,%d2,1,16,1
800012f4:	74 22       	st.w [%a2],%d2
    timeoutCycleCount       = IFXSCUCCU_SYSPLLSTAT_PWDSTAT_TIMEOUT_COUNT;
800012f6:	3b 00 00 23 	mov %d2,12288
    while ((SCU_SYSPLLSTAT.B.PWDSTAT == 1) || (SCU_PERPLLSTAT.B.PWDSTAT == 1))
800012fa:	1d 00 1f 00 	j 80001338 <IfxScuCcu_init+0x1d6>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800012fe:	82 19       	mov %d9,1
80001300:	1d ff ca ff 	j 80001294 <IfxScuCcu_init+0x132>
        scuOsccon.U      = SCU_OSCCON.U;
80001304:	91 30 00 2f 	movh.a %a2,61443
80001308:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <bmhd_3_copy+0x40c34a10>>
8000130c:	54 24       	ld.w %d4,[%a2]
        scuOsccon.B.MODE = 0U;
8000130e:	8f 04 c6 41 	andn %d4,%d4,96
        scuOsccon.B.OSCVAL = (uint32)(pllsParamCfg->xtalFrequency / 1000000U) - 15; /*XTAL range 16MHz to 40MHz*/
80001312:	54 c3       	ld.w %d3,[%a12]
80001314:	7b c0 31 24 	movh %d2,17180
80001318:	1b 32 e8 2d 	addi %d2,%d2,-8573
8000131c:	73 23 68 20 	mul.u %e2,%d3,%d2
80001320:	8f e3 1e 20 	sh %d2,%d3,-18
80001324:	1b 12 ff 2f 	addi %d2,%d2,-15
80001328:	37 24 05 48 	insert %d4,%d4,%d2,16,5
        SCU_OSCCON.U       = scuOsccon.U;
8000132c:	74 24       	st.w [%a2],%d4
8000132e:	1d ff b8 ff 	j 8000129e <IfxScuCcu_init+0x13c>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80001332:	c2 f2       	add %d2,-1
80001334:	bf 12 14 00 	jlt %d2,1,8000135c <IfxScuCcu_init+0x1fa>
    while ((SCU_SYSPLLSTAT.B.PWDSTAT == 1) || (SCU_PERPLLSTAT.B.PWDSTAT == 1))
80001338:	91 30 00 2f 	movh.a %a2,61443
8000133c:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <bmhd_3_copy+0x40c34a14>>
80001340:	54 23       	ld.w %d3,[%a2]
80001342:	6f 13 f8 ff 	jnz.t %d3,1,80001332 <IfxScuCcu_init+0x1d0>
80001346:	91 30 00 2f 	movh.a %a2,61443
8000134a:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <bmhd_3_copy+0x40c34a24>>
8000134e:	54 23       	ld.w %d3,[%a2]
80001350:	6f 13 f1 ff 	jnz.t %d3,1,80001332 <IfxScuCcu_init+0x1d0>
    timeoutCycleCount = IFXSCUCCU_PLL_KRDY_TIMEOUT_COUNT;
80001354:	3b 00 00 26 	mov %d2,24576
    while ((SCU_SYSPLLSTAT.B.K2RDY == 0U) ||
80001358:	1d 00 08 00 	j 80001368 <IfxScuCcu_init+0x206>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
8000135c:	82 19       	mov %d9,1
8000135e:	1d ff fb ff 	j 80001354 <IfxScuCcu_init+0x1f2>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80001362:	c2 f2       	add %d2,-1
80001364:	bf 12 2f 00 	jlt %d2,1,800013c2 <IfxScuCcu_init+0x260>
    while ((SCU_SYSPLLSTAT.B.K2RDY == 0U) ||
80001368:	91 30 00 2f 	movh.a %a2,61443
8000136c:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <bmhd_3_copy+0x40c34a14>>
80001370:	54 23       	ld.w %d3,[%a2]
           (SCU_PERPLLSTAT.B.K2RDY == 0U) ||
80001372:	6f 53 f8 7f 	jz.t %d3,5,80001362 <IfxScuCcu_init+0x200>
80001376:	91 30 00 2f 	movh.a %a2,61443
8000137a:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <bmhd_3_copy+0x40c34a24>>
8000137e:	54 23       	ld.w %d3,[%a2]
    while ((SCU_SYSPLLSTAT.B.K2RDY == 0U) ||
80001380:	6f 53 f1 7f 	jz.t %d3,5,80001362 <IfxScuCcu_init+0x200>
           (SCU_PERPLLSTAT.B.K3RDY == 0U))
80001384:	54 23       	ld.w %d3,[%a2]
           (SCU_PERPLLSTAT.B.K2RDY == 0U) ||
80001386:	6f 43 ee 7f 	jz.t %d3,4,80001362 <IfxScuCcu_init+0x200>
    SCU_SYSPLLCON1.B.K2DIV = pllsParamCfg->sysPllConfig.k2Divider;
8000138a:	39 c3 0a 00 	ld.bu %d3,[%a12]10
8000138e:	91 30 00 2f 	movh.a %a2,61443
80001392:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <bmhd_3_copy+0x40c34a1c>>
80001396:	54 22       	ld.w %d2,[%a2]
80001398:	37 32 03 20 	insert %d2,%d2,%d3,0,3
8000139c:	74 22       	st.w [%a2],%d2
        scuPerPllCon1.U       = SCU_PERPLLCON1.U;
8000139e:	91 30 00 2f 	movh.a %a2,61443
800013a2:	d9 22 2c 06 	lea %a2,[%a2]24620 <f003602c <bmhd_3_copy+0x40c34a2c>>
800013a6:	54 22       	ld.w %d2,[%a2]
        scuPerPllCon1.B.K2DIV = pllsParamCfg->perPllConfig.k2Divider;
800013a8:	39 c3 0e 00 	ld.bu %d3,[%a12]14 <f003602c <bmhd_3_copy+0x40c34a2c>>
800013ac:	37 32 03 20 	insert %d2,%d2,%d3,0,3
        scuPerPllCon1.B.K3DIV = pllsParamCfg->perPllConfig.k3Divider;
800013b0:	39 c3 0f 00 	ld.bu %d3,[%a12]15
800013b4:	37 32 03 24 	insert %d2,%d2,%d3,8,3
        SCU_PERPLLCON1.U      = scuPerPllCon1.U;
800013b8:	74 22       	st.w [%a2],%d2
    timeoutCycleCount = IFXSCUCCU_PLL_KRDY_TIMEOUT_COUNT;
800013ba:	3b 00 00 26 	mov %d2,24576
    while ((SCU_SYSPLLSTAT.B.K2RDY == 0U) ||
800013be:	1d 00 08 00 	j 800013ce <IfxScuCcu_init+0x26c>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800013c2:	82 19       	mov %d9,1
800013c4:	1d ff e3 ff 	j 8000138a <IfxScuCcu_init+0x228>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800013c8:	c2 f2       	add %d2,-1
800013ca:	bf 12 39 00 	jlt %d2,1,8000143c <IfxScuCcu_init+0x2da>
    while ((SCU_SYSPLLSTAT.B.K2RDY == 0U) ||
800013ce:	91 30 00 2f 	movh.a %a2,61443
800013d2:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <bmhd_3_copy+0x40c34a14>>
800013d6:	54 23       	ld.w %d3,[%a2]
           (SCU_PERPLLSTAT.B.K2RDY == 0U) ||
800013d8:	6f 53 f8 7f 	jz.t %d3,5,800013c8 <IfxScuCcu_init+0x266>
800013dc:	91 30 00 2f 	movh.a %a2,61443
800013e0:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <bmhd_3_copy+0x40c34a24>>
800013e4:	54 23       	ld.w %d3,[%a2]
    while ((SCU_SYSPLLSTAT.B.K2RDY == 0U) ||
800013e6:	6f 53 f1 7f 	jz.t %d3,5,800013c8 <IfxScuCcu_init+0x266>
           (SCU_PERPLLSTAT.B.K3RDY == 0U))
800013ea:	54 23       	ld.w %d3,[%a2]
           (SCU_PERPLLSTAT.B.K2RDY == 0U) ||
800013ec:	6f 43 ee 7f 	jz.t %d3,4,800013c8 <IfxScuCcu_init+0x266>
    timeoutCycleCount = IFXSCUCCU_OSCCON_PLLLV_OR_HV_TIMEOUT_COUNT;
800013f0:	7b 50 00 20 	movh %d2,5
800013f4:	1b 02 3e 29 	addi %d2,%d2,-27680
    while ((SCU_OSCCON.B.PLLLV == 0) && (SCU_OSCCON.B.PLLHV == 0))
800013f8:	91 30 00 2f 	movh.a %a2,61443
800013fc:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <bmhd_3_copy+0x40c34a10>>
80001400:	54 23       	ld.w %d3,[%a2]
80001402:	6f 13 09 80 	jnz.t %d3,1,80001414 <IfxScuCcu_init+0x2b2>
80001406:	54 23       	ld.w %d3,[%a2]
80001408:	6f 83 06 80 	jnz.t %d3,8,80001414 <IfxScuCcu_init+0x2b2>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
8000140c:	c2 f2       	add %d2,-1
8000140e:	ff 12 f5 7f 	jge %d2,1,800013f8 <IfxScuCcu_init+0x296>
80001412:	82 19       	mov %d9,1
        SCU_SYSPLLCON0.B.RESLD = 1;             /* Restart Sys PLL lock detection */
80001414:	91 30 00 2f 	movh.a %a2,61443
80001418:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
8000141c:	54 22       	ld.w %d2,[%a2]
8000141e:	b7 12 01 29 	insert %d2,%d2,1,18,1
80001422:	74 22       	st.w [%a2],%d2
        SCU_PERPLLCON0.B.RESLD = 1;             /* Restart Per PLL lock detection */
80001424:	91 30 00 2f 	movh.a %a2,61443
80001428:	d9 22 28 06 	lea %a2,[%a2]24616 <f0036028 <bmhd_3_copy+0x40c34a28>>
8000142c:	54 22       	ld.w %d2,[%a2]
8000142e:	b7 12 01 29 	insert %d2,%d2,1,18,1
80001432:	74 22       	st.w [%a2],%d2
        timeoutCycleCount      = IFXSCUCCU_PLL_LOCK_TIMEOUT_COUNT;
80001434:	3b 00 00 23 	mov %d2,12288
        while ((SCU_SYSPLLSTAT.B.LOCK == 0) || (SCU_PERPLLSTAT.B.LOCK == 0))
80001438:	1d 00 08 00 	j 80001448 <IfxScuCcu_init+0x2e6>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
8000143c:	82 19       	mov %d9,1
8000143e:	1d ff d9 ff 	j 800013f0 <IfxScuCcu_init+0x28e>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80001442:	c2 f2       	add %d2,-1
80001444:	bf 12 b7 00 	jlt %d2,1,800015b2 <IfxScuCcu_init+0x450>
        while ((SCU_SYSPLLSTAT.B.LOCK == 0) || (SCU_PERPLLSTAT.B.LOCK == 0))
80001448:	91 30 00 2f 	movh.a %a2,61443
8000144c:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <bmhd_3_copy+0x40c34a14>>
80001450:	54 23       	ld.w %d3,[%a2]
80001452:	6f 23 f8 7f 	jz.t %d3,2,80001442 <IfxScuCcu_init+0x2e0>
80001456:	91 30 00 2f 	movh.a %a2,61443
8000145a:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <bmhd_3_copy+0x40c34a24>>
8000145e:	54 23       	ld.w %d3,[%a2]
80001460:	6f 23 f1 7f 	jz.t %d3,2,80001442 <IfxScuCcu_init+0x2e0>
        SMU_KEYS.U = (uint32)0xBCU;           /* Enable access to SMU registers */
80001464:	91 30 00 2f 	movh.a %a2,61443
80001468:	d9 22 b4 06 	lea %a2,[%a2]26676 <f0036834 <bmhd_3_copy+0x40c35234>>
8000146c:	3b c0 0b 20 	mov %d2,188
80001470:	74 22       	st.w [%a2],%d2
        SMU_CMD.U  = (uint32)0x00000005;
80001472:	91 30 00 3f 	movh.a %a3,61443
80001476:	d9 33 a0 06 	lea %a3,[%a3]26656 <f0036820 <bmhd_3_copy+0x40c35220>>
8000147a:	82 52       	mov %d2,5
8000147c:	74 32       	st.w [%a3],%d2
        SMU_AG8.U  = IFXSCUCCU_SMUALARM_MASK; /* Clear SMU Alarms*/
8000147e:	91 30 00 3f 	movh.a %a3,61443
80001482:	d9 33 a0 76 	lea %a3,[%a3]27104 <f00369e0 <bmhd_3_copy+0x40c353e0>>
80001486:	3b d0 01 20 	mov %d2,29
8000148a:	74 32       	st.w [%a3],%d2
        SMU_KEYS.U = (uint32)0U;
8000148c:	82 02       	mov %d2,0
8000148e:	74 22       	st.w [%a2],%d2
        scu_ccucon0.U        = SCU_CCUCON0.U;
80001490:	91 30 00 2f 	movh.a %a2,61443
80001494:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
80001498:	54 24       	ld.w %d4,[%a2]
        scu_ccucon0.B.CLKSEL = 1; /*Select the PLLs for fsource0/1/2 */
8000149a:	b7 14 02 4e 	insert %d4,%d4,1,28,2
        scu_ccucon0.B.UP     = 1; /*Update the ccucon0 register */
8000149e:	b7 14 01 4f 	insert %d4,%d4,1,30,1
        timeoutCycleCount    = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
800014a2:	3b 00 00 21 	mov %d2,4096
        while (SCU_CCUCON0.B.LCK != 0U)
800014a6:	91 30 00 2f 	movh.a %a2,61443
800014aa:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
800014ae:	54 23       	ld.w %d3,[%a2]
800014b0:	ff 03 06 00 	jge %d3,0,800014bc <IfxScuCcu_init+0x35a>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800014b4:	c2 f2       	add %d2,-1
800014b6:	ff 12 f8 7f 	jge %d2,1,800014a6 <IfxScuCcu_init+0x344>
800014ba:	82 19       	mov %d9,1
        SCU_CCUCON0.U     = scu_ccucon0.U;
800014bc:	91 30 00 2f 	movh.a %a2,61443
800014c0:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
800014c4:	74 24       	st.w [%a2],%d4
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
800014c6:	3b 00 00 21 	mov %d2,4096
        while (SCU_CCUCON0.B.LCK != 0U)
800014ca:	91 30 00 2f 	movh.a %a2,61443
800014ce:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
800014d2:	54 23       	ld.w %d3,[%a2]
800014d4:	ff 03 06 00 	jge %d3,0,800014e0 <IfxScuCcu_init+0x37e>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800014d8:	c2 f2       	add %d2,-1
800014da:	ff 12 f8 7f 	jge %d2,1,800014ca <IfxScuCcu_init+0x368>
800014de:	82 19       	mov %d9,1
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
800014e0:	91 30 00 2f 	movh.a %a2,61443
800014e4:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800014e8:	54 22       	ld.w %d2,[%a2]
800014ea:	6f 12 09 00 	jz.t %d2,1,800014fc <IfxScuCcu_init+0x39a>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
800014ee:	8f 15 40 31 	or %d3,%d5,1
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800014f2:	54 22       	ld.w %d2,[%a2]
800014f4:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800014f8:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800014fa:	74 22       	st.w [%a2],%d2
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
800014fc:	8f 35 40 51 	or %d5,%d5,3
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001500:	91 30 00 2f 	movh.a %a2,61443
80001504:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001508:	54 22       	ld.w %d2,[%a2]
8000150a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000150e:	a6 52       	or %d2,%d5
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001510:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80001512:	91 30 00 2f 	movh.a %a2,61443
80001516:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000151a:	54 22       	ld.w %d2,[%a2]
8000151c:	6f 02 fb 7f 	jz.t %d2,0,80001512 <IfxScuCcu_init+0x3b0>
    if (!status)
80001520:	df 09 4c 00 	jeq %d9,0,800015b8 <IfxScuCcu_init+0x456>
    if (!status)
80001524:	df 09 b1 81 	jne %d9,0,80001886 <IfxScuCcu_init+0x724>
    password  = watchdog->CON0.B.PW;
80001528:	91 30 00 2f 	movh.a %a2,61443
8000152c:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001530:	54 22       	ld.w %d2,[%a2]
80001532:	37 02 6e 21 	extr.u %d2,%d2,2,14
    IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);
80001536:	8f f2 83 21 	xor %d2,%d2,63
    if (SCU_WDTS_CON0.B.LCK)
8000153a:	54 23       	ld.w %d3,[%a2]
8000153c:	6f 13 0b 00 	jz.t %d3,1,80001552 <IfxScuCcu_init+0x3f0>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001540:	8f 22 00 40 	sh %d4,%d2,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001544:	8f 14 40 41 	or %d4,%d4,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001548:	54 23       	ld.w %d3,[%a2]
8000154a:	b7 03 10 30 	insert %d3,%d3,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000154e:	a6 43       	or %d3,%d4
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001550:	74 23       	st.w [%a2],%d3
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001552:	8f 22 00 50 	sh %d5,%d2,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001556:	8f 25 40 31 	or %d3,%d5,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000155a:	91 30 00 2f 	movh.a %a2,61443
8000155e:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001562:	54 22       	ld.w %d2,[%a2]
80001564:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001568:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000156a:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000156c:	91 30 00 2f 	movh.a %a2,61443
80001570:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001574:	54 22       	ld.w %d2,[%a2]
80001576:	6f 02 fb ff 	jnz.t %d2,0,8000156c <IfxScuCcu_init+0x40a>
        ccucon0.U         = SCU_CCUCON0.U & ~clockDistributionConfig->ccucon0.mask;
8000157a:	91 30 00 2f 	movh.a %a2,61443
8000157e:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
80001582:	54 22       	ld.w %d2,[%a2]
80001584:	19 c4 24 00 	ld.w %d4,[%a12]36 <f0036030 <bmhd_3_copy+0x40c34a30>>
80001588:	0f 42 e0 20 	andn %d2,%d2,%d4
        ccucon0.U        |= (clockDistributionConfig->ccucon0.mask & clockDistributionConfig->ccucon0.value);
8000158c:	19 c3 20 00 	ld.w %d3,[%a12]32
80001590:	26 34       	and %d4,%d3
80001592:	a6 24       	or %d4,%d2
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80001594:	3b 00 00 21 	mov %d2,4096
        while (SCU_CCUCON0.B.LCK != 0U)
80001598:	91 30 00 2f 	movh.a %a2,61443
8000159c:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
800015a0:	54 23       	ld.w %d3,[%a2]
800015a2:	ff 03 11 00 	jge %d3,0,800015c4 <IfxScuCcu_init+0x462>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800015a6:	c2 f2       	add %d2,-1
800015a8:	ff 12 f8 7f 	jge %d2,1,80001598 <IfxScuCcu_init+0x436>
800015ac:	82 19       	mov %d9,1
800015ae:	1d 00 0c 00 	j 800015c6 <IfxScuCcu_init+0x464>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800015b2:	82 19       	mov %d9,1
800015b4:	1d ff 58 ff 	j 80001464 <IfxScuCcu_init+0x302>
        IfxScuCcu_modulation_init(config->modulationConfig);  /* initialize modulation */
800015b8:	99 c4 24 10 	ld.a %a4,[%a12]100
800015bc:	6d ff a7 fd 	call 8000110a <IfxScuCcu_modulation_init>
800015c0:	1d ff b2 ff 	j 80001524 <IfxScuCcu_init+0x3c2>
    uint32 initError = 0;
800015c4:	82 09       	mov %d9,0
        SCU_CCUCON0.U     = ccucon0.U;      /*Set update bit explicitly to make above configurations effective */
800015c6:	91 30 00 2f 	movh.a %a2,61443
800015ca:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
800015ce:	74 24       	st.w [%a2],%d4
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
800015d0:	3b 00 00 21 	mov %d2,4096
        while (SCU_CCUCON0.B.LCK != 0U)
800015d4:	91 30 00 2f 	movh.a %a2,61443
800015d8:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
800015dc:	54 23       	ld.w %d3,[%a2]
800015de:	ff 03 06 00 	jge %d3,0,800015ea <IfxScuCcu_init+0x488>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800015e2:	c2 f2       	add %d2,-1
800015e4:	ff 12 f8 7f 	jge %d2,1,800015d4 <IfxScuCcu_init+0x472>
800015e8:	82 19       	mov %d9,1
        ccucon1.U = SCU_CCUCON1.U;
800015ea:	91 30 00 2f 	movh.a %a2,61443
800015ee:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
800015f2:	54 22       	ld.w %d2,[%a2]
            || ccucon1.B.CLKSELQSPI)
800015f4:	7b 00 03 33 	movh %d3,12336
800015f8:	1b 03 03 30 	addi %d3,%d3,48
800015fc:	26 32       	and %d2,%d3
        if (ccucon1.B.CLKSELMCAN
800015fe:	df 02 30 00 	jeq %d2,0,8000165e <IfxScuCcu_init+0x4fc>
            ccucon1.U  = SCU_CCUCON1.U & ~clockDistributionConfig->ccucon1.mask;
80001602:	54 22       	ld.w %d2,[%a2]
80001604:	19 c4 2c 00 	ld.w %d4,[%a12]44
80001608:	0f 42 e0 20 	andn %d2,%d2,%d4
            ccucon1.U |= (clockDistributionConfig->ccucon1.mask & clockDistributionConfig->ccucon1.value);
8000160c:	19 c3 28 00 	ld.w %d3,[%a12]40
80001610:	26 34       	and %d4,%d3
80001612:	a6 24       	or %d4,%d2
            ccucon1.B.CLKSELMCAN = (uint32)0;
80001614:	8f 04 c3 41 	andn %d4,%d4,48
            ccucon1.B.CLKSELMSC  = (uint32)0;
80001618:	b7 04 02 4a 	insert %d4,%d4,0,20,2
            ccucon1.B.CLKSELQSPI = (uint32)0;
8000161c:	b7 04 02 4e 	insert %d4,%d4,0,28,2
            timeoutCycleCount    = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80001620:	3b 00 00 21 	mov %d2,4096
            while (SCU_CCUCON1.B.LCK != 0U)
80001624:	91 30 00 2f 	movh.a %a2,61443
80001628:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
8000162c:	54 23       	ld.w %d3,[%a2]
8000162e:	ff 03 06 00 	jge %d3,0,8000163a <IfxScuCcu_init+0x4d8>
                IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80001632:	c2 f2       	add %d2,-1
80001634:	ff 12 f8 7f 	jge %d2,1,80001624 <IfxScuCcu_init+0x4c2>
80001638:	82 19       	mov %d9,1
            SCU_CCUCON1.U     = ccucon1.U;
8000163a:	91 30 00 2f 	movh.a %a2,61443
8000163e:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
80001642:	74 24       	st.w [%a2],%d4
            timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80001644:	3b 00 00 21 	mov %d2,4096
            while (SCU_CCUCON1.B.LCK != 0U)
80001648:	91 30 00 2f 	movh.a %a2,61443
8000164c:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
80001650:	54 23       	ld.w %d3,[%a2]
80001652:	ff 03 06 00 	jge %d3,0,8000165e <IfxScuCcu_init+0x4fc>
                IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80001656:	c2 f2       	add %d2,-1
80001658:	ff 12 f8 7f 	jge %d2,1,80001648 <IfxScuCcu_init+0x4e6>
8000165c:	82 19       	mov %d9,1
        ccucon1.U         = SCU_CCUCON1.U & ~clockDistributionConfig->ccucon1.mask;
8000165e:	91 30 00 2f 	movh.a %a2,61443
80001662:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
80001666:	54 22       	ld.w %d2,[%a2]
80001668:	19 c4 2c 00 	ld.w %d4,[%a12]44 <f0036034 <bmhd_3_copy+0x40c34a34>>
8000166c:	0f 42 e0 20 	andn %d2,%d2,%d4
        ccucon1.U        |= (clockDistributionConfig->ccucon1.mask & clockDistributionConfig->ccucon1.value);
80001670:	19 c3 28 00 	ld.w %d3,[%a12]40
80001674:	26 34       	and %d4,%d3
80001676:	a6 24       	or %d4,%d2
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80001678:	3b 00 00 21 	mov %d2,4096
        while (SCU_CCUCON1.B.LCK != 0U)
8000167c:	91 30 00 2f 	movh.a %a2,61443
80001680:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
80001684:	54 23       	ld.w %d3,[%a2]
80001686:	ff 03 06 00 	jge %d3,0,80001692 <IfxScuCcu_init+0x530>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
8000168a:	c2 f2       	add %d2,-1
8000168c:	ff 12 f8 7f 	jge %d2,1,8000167c <IfxScuCcu_init+0x51a>
80001690:	82 19       	mov %d9,1
        SCU_CCUCON1.U     = ccucon1.U;
80001692:	91 30 00 2f 	movh.a %a2,61443
80001696:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
8000169a:	74 24       	st.w [%a2],%d4
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
8000169c:	3b 00 00 21 	mov %d2,4096
        while (SCU_CCUCON1.B.LCK != 0U)
800016a0:	91 30 00 2f 	movh.a %a2,61443
800016a4:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
800016a8:	54 23       	ld.w %d3,[%a2]
800016aa:	ff 03 06 00 	jge %d3,0,800016b6 <IfxScuCcu_init+0x554>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800016ae:	c2 f2       	add %d2,-1
800016b0:	ff 12 f8 7f 	jge %d2,1,800016a0 <IfxScuCcu_init+0x53e>
800016b4:	82 19       	mov %d9,1
        ccucon2.U = SCU_CCUCON2.U;
800016b6:	91 30 00 2f 	movh.a %a2,61443
800016ba:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
800016be:	54 22       	ld.w %d2,[%a2]
        if (ccucon2.B.CLKSELASCLINS)
800016c0:	3b 00 00 33 	mov %d3,12288
800016c4:	26 32       	and %d2,%d3
800016c6:	df 02 2c 00 	jeq %d2,0,8000171e <IfxScuCcu_init+0x5bc>
            ccucon2.U               = SCU_CCUCON2.U & ~clockDistributionConfig->ccucon2.mask;
800016ca:	54 22       	ld.w %d2,[%a2]
800016cc:	19 c4 34 00 	ld.w %d4,[%a12]52
800016d0:	0f 42 e0 20 	andn %d2,%d2,%d4
            ccucon2.U              |= (clockDistributionConfig->ccucon2.mask & clockDistributionConfig->ccucon2.value);
800016d4:	19 c3 30 00 	ld.w %d3,[%a12]48
800016d8:	26 34       	and %d4,%d3
800016da:	a6 24       	or %d4,%d2
            ccucon2.B.CLKSELASCLINS = (uint32)0;
800016dc:	b7 04 02 46 	insert %d4,%d4,0,12,2
            timeoutCycleCount       = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
800016e0:	3b 00 00 21 	mov %d2,4096
            while (SCU_CCUCON2.B.LCK != 0U)
800016e4:	91 30 00 2f 	movh.a %a2,61443
800016e8:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
800016ec:	54 23       	ld.w %d3,[%a2]
800016ee:	ff 03 06 00 	jge %d3,0,800016fa <IfxScuCcu_init+0x598>
                IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800016f2:	c2 f2       	add %d2,-1
800016f4:	ff 12 f8 7f 	jge %d2,1,800016e4 <IfxScuCcu_init+0x582>
800016f8:	82 19       	mov %d9,1
            SCU_CCUCON2.U     = ccucon2.U;
800016fa:	91 30 00 2f 	movh.a %a2,61443
800016fe:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
80001702:	74 24       	st.w [%a2],%d4
            timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80001704:	3b 00 00 21 	mov %d2,4096
            while (SCU_CCUCON2.B.LCK != 0U)
80001708:	91 30 00 2f 	movh.a %a2,61443
8000170c:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
80001710:	54 23       	ld.w %d3,[%a2]
80001712:	ff 03 06 00 	jge %d3,0,8000171e <IfxScuCcu_init+0x5bc>
                IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80001716:	c2 f2       	add %d2,-1
80001718:	ff 12 f8 7f 	jge %d2,1,80001708 <IfxScuCcu_init+0x5a6>
8000171c:	82 19       	mov %d9,1
        ccucon2.U         = SCU_CCUCON2.U & ~clockDistributionConfig->ccucon2.mask;
8000171e:	91 30 00 2f 	movh.a %a2,61443
80001722:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
80001726:	54 22       	ld.w %d2,[%a2]
80001728:	19 c4 34 00 	ld.w %d4,[%a12]52 <f0036040 <bmhd_3_copy+0x40c34a40>>
8000172c:	0f 42 e0 20 	andn %d2,%d2,%d4
        ccucon2.U        |= (clockDistributionConfig->ccucon2.mask & clockDistributionConfig->ccucon2.value);
80001730:	19 c3 30 00 	ld.w %d3,[%a12]48
80001734:	26 34       	and %d4,%d3
80001736:	a6 24       	or %d4,%d2
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80001738:	3b 00 00 21 	mov %d2,4096
        while (SCU_CCUCON2.B.LCK != 0U)
8000173c:	91 30 00 2f 	movh.a %a2,61443
80001740:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
80001744:	54 23       	ld.w %d3,[%a2]
80001746:	ff 03 06 00 	jge %d3,0,80001752 <IfxScuCcu_init+0x5f0>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
8000174a:	c2 f2       	add %d2,-1
8000174c:	ff 12 f8 7f 	jge %d2,1,8000173c <IfxScuCcu_init+0x5da>
80001750:	82 19       	mov %d9,1
        SCU_CCUCON2.U     = ccucon2.U;
80001752:	91 30 00 2f 	movh.a %a2,61443
80001756:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
8000175a:	74 24       	st.w [%a2],%d4
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
8000175c:	3b 00 00 21 	mov %d2,4096
        while (SCU_CCUCON2.B.LCK != 0U)
80001760:	91 30 00 2f 	movh.a %a2,61443
80001764:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
80001768:	54 23       	ld.w %d3,[%a2]
8000176a:	ff 03 06 00 	jge %d3,0,80001776 <IfxScuCcu_init+0x614>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
8000176e:	c2 f2       	add %d2,-1
80001770:	ff 12 f8 7f 	jge %d2,1,80001760 <IfxScuCcu_init+0x5fe>
80001774:	82 19       	mov %d9,1
        ccucon5.U         = SCU_CCUCON5.U & ~clockDistributionConfig->ccucon5.mask;
80001776:	91 30 00 2f 	movh.a %a2,61443
8000177a:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <bmhd_3_copy+0x40c34a4c>>
8000177e:	54 22       	ld.w %d2,[%a2]
80001780:	19 c4 3c 00 	ld.w %d4,[%a12]60 <f003604c <bmhd_3_copy+0x40c34a4c>>
80001784:	0f 42 e0 20 	andn %d2,%d2,%d4
        ccucon5.U        |= (clockDistributionConfig->ccucon5.mask & clockDistributionConfig->ccucon5.value);
80001788:	19 c3 38 00 	ld.w %d3,[%a12]56
8000178c:	26 34       	and %d4,%d3
8000178e:	a6 24       	or %d4,%d2
        ccucon5.B.UP      = 1;
80001790:	b7 14 01 4f 	insert %d4,%d4,1,30,1
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80001794:	3b 00 00 21 	mov %d2,4096
        while (SCU_CCUCON5.B.LCK != 0U)
80001798:	91 30 00 2f 	movh.a %a2,61443
8000179c:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <bmhd_3_copy+0x40c34a4c>>
800017a0:	54 23       	ld.w %d3,[%a2]
800017a2:	ff 03 06 00 	jge %d3,0,800017ae <IfxScuCcu_init+0x64c>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800017a6:	c2 f2       	add %d2,-1
800017a8:	ff 12 f8 7f 	jge %d2,1,80001798 <IfxScuCcu_init+0x636>
800017ac:	82 19       	mov %d9,1
        SCU_CCUCON5.U     = ccucon5.U;
800017ae:	91 30 00 2f 	movh.a %a2,61443
800017b2:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <bmhd_3_copy+0x40c34a4c>>
800017b6:	74 24       	st.w [%a2],%d4
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
800017b8:	3b 00 00 21 	mov %d2,4096
        while (SCU_CCUCON5.B.LCK != 0U)
800017bc:	91 30 00 2f 	movh.a %a2,61443
800017c0:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <bmhd_3_copy+0x40c34a4c>>
800017c4:	54 23       	ld.w %d3,[%a2]
800017c6:	ff 03 06 00 	jge %d3,0,800017d2 <IfxScuCcu_init+0x670>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800017ca:	c2 f2       	add %d2,-1
800017cc:	ff 12 f8 7f 	jge %d2,1,800017bc <IfxScuCcu_init+0x65a>
800017d0:	82 19       	mov %d9,1
        ccucon6.U     = SCU_CCUCON6.U & ~clockDistributionConfig->ccucon6.mask;
800017d2:	91 30 00 2f 	movh.a %a2,61443
800017d6:	d9 22 00 26 	lea %a2,[%a2]24704 <f0036080 <bmhd_3_copy+0x40c34a80>>
800017da:	54 23       	ld.w %d3,[%a2]
800017dc:	19 c4 04 10 	ld.w %d4,[%a12]68 <f0036080 <bmhd_3_copy+0x40c34a80>>
800017e0:	0f 43 e0 30 	andn %d3,%d3,%d4
        ccucon6.U    |= (clockDistributionConfig->ccucon6.mask & clockDistributionConfig->ccucon6.value);
800017e4:	19 c2 00 10 	ld.w %d2,[%a12]64
800017e8:	26 42       	and %d2,%d4
800017ea:	a6 32       	or %d2,%d3
        SCU_CCUCON6.U = ccucon6.U;
800017ec:	74 22       	st.w [%a2],%d2
        ccucon7.U     = SCU_CCUCON7.U & ~clockDistributionConfig->ccucon7.mask;
800017ee:	91 30 00 2f 	movh.a %a2,61443
800017f2:	d9 22 04 26 	lea %a2,[%a2]24708 <f0036084 <bmhd_3_copy+0x40c34a84>>
800017f6:	54 23       	ld.w %d3,[%a2]
800017f8:	19 c4 0c 10 	ld.w %d4,[%a12]76 <f0036084 <bmhd_3_copy+0x40c34a84>>
800017fc:	0f 43 e0 30 	andn %d3,%d3,%d4
        ccucon7.U    |= (clockDistributionConfig->ccucon7.mask & clockDistributionConfig->ccucon7.value);
80001800:	19 c2 08 10 	ld.w %d2,[%a12]72
80001804:	26 42       	and %d2,%d4
80001806:	a6 32       	or %d2,%d3
        SCU_CCUCON7.U = ccucon7.U;
80001808:	74 22       	st.w [%a2],%d2
        ccucon8.U     = SCU_CCUCON8.U & ~clockDistributionConfig->ccucon8.mask;
8000180a:	91 30 00 2f 	movh.a %a2,61443
8000180e:	d9 22 08 26 	lea %a2,[%a2]24712 <f0036088 <bmhd_3_copy+0x40c34a88>>
80001812:	54 23       	ld.w %d3,[%a2]
80001814:	19 c4 14 10 	ld.w %d4,[%a12]84 <f0036088 <bmhd_3_copy+0x40c34a88>>
80001818:	0f 43 e0 30 	andn %d3,%d3,%d4
        ccucon8.U    |= (clockDistributionConfig->ccucon8.mask & clockDistributionConfig->ccucon8.value);
8000181c:	19 c2 10 10 	ld.w %d2,[%a12]80
80001820:	26 42       	and %d2,%d4
80001822:	a6 32       	or %d2,%d3
        SCU_CCUCON8.U = ccucon8.U;
80001824:	74 22       	st.w [%a2],%d2
        ccucon9.U     = SCU_CCUCON9.U & ~clockDistributionConfig->ccucon9.mask;
80001826:	91 30 00 2f 	movh.a %a2,61443
8000182a:	d9 22 0c 26 	lea %a2,[%a2]24716 <f003608c <bmhd_3_copy+0x40c34a8c>>
8000182e:	54 23       	ld.w %d3,[%a2]
80001830:	19 c4 1c 10 	ld.w %d4,[%a12]92 <f003608c <bmhd_3_copy+0x40c34a8c>>
80001834:	0f 43 e0 30 	andn %d3,%d3,%d4
        ccucon9.U    |= (clockDistributionConfig->ccucon9.mask & clockDistributionConfig->ccucon9.value);
80001838:	19 c2 18 10 	ld.w %d2,[%a12]88
8000183c:	26 42       	and %d2,%d4
8000183e:	a6 32       	or %d2,%d3
        SCU_CCUCON9.U = ccucon9.U;
80001840:	74 22       	st.w [%a2],%d2
    if (SCU_WDTS_CON0.B.LCK)
80001842:	91 30 00 2f 	movh.a %a2,61443
80001846:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000184a:	54 22       	ld.w %d2,[%a2]
8000184c:	6f 12 09 00 	jz.t %d2,1,8000185e <IfxScuCcu_init+0x6fc>
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001850:	8f 15 40 31 	or %d3,%d5,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001854:	54 22       	ld.w %d2,[%a2]
80001856:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000185a:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000185c:	74 22       	st.w [%a2],%d2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
8000185e:	8f 35 40 51 	or %d5,%d5,3
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001862:	91 30 00 2f 	movh.a %a2,61443
80001866:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000186a:	54 22       	ld.w %d2,[%a2]
8000186c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001870:	a6 52       	or %d2,%d5
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001872:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80001874:	91 30 00 2f 	movh.a %a2,61443
80001878:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000187c:	54 22       	ld.w %d2,[%a2]
8000187e:	6f 02 fb 7f 	jz.t %d2,0,80001874 <IfxScuCcu_init+0x712>
    return (boolean)initError;
80001882:	8f f9 0f 91 	and %d9,%d9,255
    if (!status)
80001886:	df 09 96 80 	jne %d9,0,800019b2 <IfxScuCcu_init+0x850>
    password  = watchdog->CON0.B.PW;
8000188a:	91 30 00 2f 	movh.a %a2,61443
8000188e:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001892:	54 22       	ld.w %d2,[%a2]
80001894:	37 02 6e 21 	extr.u %d2,%d2,2,14
    password ^= 0x003F;
80001898:	8f f2 83 b1 	xor %d11,%d2,63

    /*get the watch-dog passwords for usage with this function*/
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPasswordInline();

    /*Start Pll ramp up sequence */
    for (pllStepsCount = 0; pllStepsCount < pllThrottleConfig->numOfSteps; pllStepsCount++)
8000189c:	02 98       	mov %d8,%d9
8000189e:	1d 00 53 00 	j 80001944 <IfxScuCcu_init+0x7e2>
            {
                IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_SYSPLLCON1.B.K2DIV = pllThrottleConfig->pllSteps[pllStepsCount].k2Step;
800018a2:	8f 38 00 50 	sh %d5,%d8,3
800018a6:	99 c2 1c 00 	ld.a %a2,[%a12]28
800018aa:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
800018ae:	14 23       	ld.bu %d3,[%a2]
800018b0:	91 30 00 2f 	movh.a %a2,61443
800018b4:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <bmhd_3_copy+0x40c34a1c>>
800018b8:	54 22       	ld.w %d2,[%a2]
800018ba:	37 32 03 20 	insert %d2,%d2,%d3,0,3
800018be:	74 22       	st.w [%a2],%d2
    if (SCU_WDTS_CON0.B.LCK)
800018c0:	91 30 00 2f 	movh.a %a2,61443
800018c4:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800018c8:	54 22       	ld.w %d2,[%a2]
800018ca:	6f 12 09 00 	jz.t %d2,1,800018dc <IfxScuCcu_init+0x77a>
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
800018ce:	8f 14 40 31 	or %d3,%d4,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800018d2:	54 22       	ld.w %d2,[%a2]
800018d4:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800018d8:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800018da:	74 22       	st.w [%a2],%d2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
800018dc:	8f 34 40 41 	or %d4,%d4,3
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800018e0:	91 30 00 2f 	movh.a %a2,61443
800018e4:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800018e8:	54 22       	ld.w %d2,[%a2]
800018ea:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800018ee:	a6 42       	or %d2,%d4
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800018f0:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
800018f2:	91 30 00 2f 	movh.a %a2,61443
800018f6:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800018fa:	54 22       	ld.w %d2,[%a2]
800018fc:	6f 02 fb 7f 	jz.t %d2,0,800018f2 <IfxScuCcu_init+0x790>
            IfxScuWdt_setSafetyEndinitInline(endinitSfty_pw);
        }

        /*Wait for waitCounter corresponding to the pll step */
        IfxScuCcu_wait(pllThrottleConfig->pllSteps[pllStepsCount].waitTime);
80001900:	99 c2 1c 00 	ld.a %a2,[%a12]28
80001904:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
80001908:	19 2a 04 00 	ld.w %d10,[%a2]4
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_0) / SCU_CCUCON0.B.STMDIV;
8000190c:	82 04       	mov %d4,0
8000190e:	6d ff cf fb 	call 800010ac <IfxScuCcu_getSourceFrequency>
80001912:	91 30 00 2f 	movh.a %a2,61443
80001916:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
8000191a:	54 23       	ld.w %d3,[%a2]
8000191c:	8f f3 00 31 	and %d3,%d3,15
80001920:	4b 03 41 31 	itof %d3,%d3
80001924:	4b 32 51 20 	div.f %d2,%d2,%d3
}


IFX_INLINE void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
80001928:	4b 2a 41 20 	mul.f %d2,%d10,%d2
8000192c:	4b 02 71 31 	ftouz %d3,%d2
    uint32 stmCountBegin = STM0_TIM0.U;
80001930:	85 f4 10 01 	ld.w %d4,f0001010 <bmhd_3_copy+0x40bffa10>

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
80001934:	85 f2 10 01 	ld.w %d2,f0001010 <bmhd_3_copy+0x40bffa10>
80001938:	a2 42       	sub %d2,%d4
8000193a:	3f 32 fd ff 	jlt.u %d2,%d3,80001934 <IfxScuCcu_init+0x7d2>
    for (pllStepsCount = 0; pllStepsCount < pllThrottleConfig->numOfSteps; pllStepsCount++)
8000193e:	c2 18       	add %d8,1
80001940:	8f f8 0f 81 	and %d8,%d8,255
80001944:	39 c2 18 00 	ld.bu %d2,[%a12]24
80001948:	7f 28 35 80 	jge.u %d8,%d2,800019b2 <IfxScuCcu_init+0x850>
    if (SCU_WDTS_CON0.B.LCK)
8000194c:	91 30 00 2f 	movh.a %a2,61443
80001950:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001954:	54 22       	ld.w %d2,[%a2]
80001956:	6f 12 0b 00 	jz.t %d2,1,8000196c <IfxScuCcu_init+0x80a>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000195a:	8f 2b 00 30 	sh %d3,%d11,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
8000195e:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001962:	54 22       	ld.w %d2,[%a2]
80001964:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001968:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000196a:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000196c:	8f 2b 00 40 	sh %d4,%d11,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001970:	8f 24 40 31 	or %d3,%d4,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001974:	91 30 00 2f 	movh.a %a2,61443
80001978:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000197c:	54 22       	ld.w %d2,[%a2]
8000197e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001982:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001984:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80001986:	91 30 00 2f 	movh.a %a2,61443
8000198a:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000198e:	54 22       	ld.w %d2,[%a2]
80001990:	6f 02 fb ff 	jnz.t %d2,0,80001986 <IfxScuCcu_init+0x824>
            timeoutCycleCount = IFXSCUCCU_PLL_KRDY_TIMEOUT_COUNT;
80001994:	3b 00 00 26 	mov %d2,24576
            while (SCU_SYSPLLSTAT.B.K2RDY == 0U)
80001998:	91 30 00 2f 	movh.a %a2,61443
8000199c:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <bmhd_3_copy+0x40c34a14>>
800019a0:	54 23       	ld.w %d3,[%a2]
800019a2:	6f 53 80 ff 	jnz.t %d3,5,800018a2 <IfxScuCcu_init+0x740>
                IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800019a6:	c2 f2       	add %d2,-1
800019a8:	ff 12 f8 7f 	jge %d2,1,80001998 <IfxScuCcu_init+0x836>
800019ac:	82 19       	mov %d9,1
800019ae:	1d ff 7a ff 	j 800018a2 <IfxScuCcu_init+0x740>
}
800019b2:	02 92       	mov %d2,%d9
800019b4:	00 90       	ret 

800019b6 <IfxScuWdt_clearCpuEndinit>:
    {}
}


void IfxScuWdt_clearCpuEndinit(uint16 password)
{
800019b6:	40 ae       	mov.aa %a14,%sp


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800019b8:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800019bc:	8f 72 00 21 	and %d2,%d2,7
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
800019c0:	7b 30 00 3f 	movh %d3,61443
800019c4:	1b c3 24 36 	addi %d3,%d3,25164
800019c8:	13 c2 20 23 	madd %d2,%d3,%d2,12
800019cc:	60 22       	mov.a %a2,%d2
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
800019ce:	54 22       	ld.w %d2,[%a2]
800019d0:	6f 12 0b 00 	jz.t %d2,1,800019e6 <IfxScuWdt_clearCpuEndinit+0x30>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800019d4:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800019d8:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800019dc:	54 22       	ld.w %d2,[%a2]
800019de:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800019e2:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800019e4:	74 22       	st.w [%a2],%d2
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800019e6:	8f 24 00 30 	sh %d3,%d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800019ea:	8f 23 40 31 	or %d3,%d3,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800019ee:	54 22       	ld.w %d2,[%a2]
800019f0:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800019f4:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800019f6:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
800019f8:	54 22       	ld.w %d2,[%a2]
800019fa:	6f 02 ff ff 	jnz.t %d2,0,800019f8 <IfxScuWdt_clearCpuEndinit+0x42>
}
800019fe:	00 90       	ret 

80001a00 <IfxScuWdt_clearSafetyEndinit>:
    {}
}


void IfxScuWdt_clearSafetyEndinit(uint16 password)
{
80001a00:	40 ae       	mov.aa %a14,%sp
80001a02:	37 04 70 40 	extr.u %d4,%d4,0,16
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80001a06:	91 30 00 2f 	movh.a %a2,61443
80001a0a:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001a0e:	54 22       	ld.w %d2,[%a2]
80001a10:	6f 12 0b 00 	jz.t %d2,1,80001a26 <IfxScuWdt_clearSafetyEndinit+0x26>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001a14:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001a18:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001a1c:	54 22       	ld.w %d2,[%a2]
80001a1e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001a22:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001a24:	74 22       	st.w [%a2],%d2
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001a26:	8f 24 00 30 	sh %d3,%d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001a2a:	8f 23 40 31 	or %d3,%d3,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001a2e:	91 30 00 2f 	movh.a %a2,61443
80001a32:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001a36:	54 22       	ld.w %d2,[%a2]
80001a38:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001a3c:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001a3e:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80001a40:	91 30 00 2f 	movh.a %a2,61443
80001a44:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001a48:	54 22       	ld.w %d2,[%a2]
80001a4a:	6f 02 fb ff 	jnz.t %d2,0,80001a40 <IfxScuWdt_clearSafetyEndinit+0x40>
    IfxScuWdt_clearSafetyEndinitInline(password);
}
80001a4e:	00 90       	ret 

80001a50 <IfxScuWdt_disableCpuWatchdog>:


void IfxScuWdt_disableCpuWatchdog(uint16 password)
{
80001a50:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
80001a52:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80001a56:	8f 72 00 21 	and %d2,%d2,7
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
80001a5a:	7b 30 00 3f 	movh %d3,61443
80001a5e:	1b c3 24 36 	addi %d3,%d3,25164
80001a62:	13 c2 20 23 	madd %d2,%d3,%d2,12
80001a66:	60 22       	mov.a %a2,%d2
    if (watchdog->CON0.B.LCK)
80001a68:	54 22       	ld.w %d2,[%a2]
80001a6a:	6f 12 0b 00 	jz.t %d2,1,80001a80 <IfxScuWdt_disableCpuWatchdog+0x30>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001a6e:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001a72:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001a76:	54 22       	ld.w %d2,[%a2]
80001a78:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001a7c:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001a7e:	74 22       	st.w [%a2],%d2
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001a80:	06 24       	sh %d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001a82:	8f 24 40 31 	or %d3,%d4,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001a86:	54 22       	ld.w %d2,[%a2]
80001a88:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001a8c:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001a8e:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80001a90:	54 22       	ld.w %d2,[%a2]
80001a92:	6f 02 ff ff 	jnz.t %d2,0,80001a90 <IfxScuWdt_disableCpuWatchdog+0x40>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 1;         //Set DR bit in Config_1 register
80001a96:	d9 23 04 00 	lea %a3,[%a2]4
80001a9a:	19 22 04 00 	ld.w %d2,[%a2]4
80001a9e:	b7 12 81 21 	insert %d2,%d2,1,3,1
80001aa2:	74 32       	st.w [%a3],%d2
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80001aa4:	54 22       	ld.w %d2,[%a2]
80001aa6:	6f 12 09 00 	jz.t %d2,1,80001ab8 <IfxScuWdt_disableCpuWatchdog+0x68>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001aaa:	8f 14 40 31 	or %d3,%d4,1
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001aae:	54 22       	ld.w %d2,[%a2]
80001ab0:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001ab4:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001ab6:	74 22       	st.w [%a2],%d2
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001ab8:	8f 34 40 41 	or %d4,%d4,3
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001abc:	54 22       	ld.w %d2,[%a2]
80001abe:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001ac2:	a6 42       	or %d2,%d4
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001ac4:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80001ac6:	54 22       	ld.w %d2,[%a2]
80001ac8:	6f 02 ff 7f 	jz.t %d2,0,80001ac6 <IfxScuWdt_disableCpuWatchdog+0x76>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
80001acc:	00 90       	ret 

80001ace <IfxScuWdt_disableSafetyWatchdog>:


void IfxScuWdt_disableSafetyWatchdog(uint16 password)
{
80001ace:	40 ae       	mov.aa %a14,%sp
80001ad0:	37 04 70 40 	extr.u %d4,%d4,0,16
    if (SCU_WDTS_CON0.B.LCK)
80001ad4:	91 30 00 2f 	movh.a %a2,61443
80001ad8:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001adc:	54 22       	ld.w %d2,[%a2]
80001ade:	6f 12 0b 00 	jz.t %d2,1,80001af4 <IfxScuWdt_disableSafetyWatchdog+0x26>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001ae2:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001ae6:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001aea:	54 22       	ld.w %d2,[%a2]
80001aec:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001af0:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001af2:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001af4:	06 24       	sh %d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001af6:	8f 24 40 31 	or %d3,%d4,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001afa:	91 30 00 2f 	movh.a %a2,61443
80001afe:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001b02:	54 22       	ld.w %d2,[%a2]
80001b04:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001b08:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001b0a:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80001b0c:	91 30 00 2f 	movh.a %a2,61443
80001b10:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001b14:	54 22       	ld.w %d2,[%a2]
80001b16:	6f 02 fb ff 	jnz.t %d2,0,80001b0c <IfxScuWdt_disableSafetyWatchdog+0x3e>
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 1;     //Set DR bit in Config_1 register
80001b1a:	91 30 00 2f 	movh.a %a2,61443
80001b1e:	d9 22 2c a6 	lea %a2,[%a2]25260 <f00362ac <bmhd_3_copy+0x40c34cac>>
80001b22:	54 22       	ld.w %d2,[%a2]
80001b24:	b7 12 81 21 	insert %d2,%d2,1,3,1
80001b28:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80001b2a:	91 30 00 2f 	movh.a %a2,61443
80001b2e:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001b32:	54 22       	ld.w %d2,[%a2]
80001b34:	6f 12 09 00 	jz.t %d2,1,80001b46 <IfxScuWdt_disableSafetyWatchdog+0x78>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001b38:	8f 14 40 31 	or %d3,%d4,1
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001b3c:	54 22       	ld.w %d2,[%a2]
80001b3e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001b42:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001b44:	74 22       	st.w [%a2],%d2
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001b46:	8f 34 40 41 	or %d4,%d4,3
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001b4a:	91 30 00 2f 	movh.a %a2,61443
80001b4e:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001b52:	54 22       	ld.w %d2,[%a2]
80001b54:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001b58:	a6 42       	or %d2,%d4
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001b5a:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80001b5c:	91 30 00 2f 	movh.a %a2,61443
80001b60:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001b64:	54 22       	ld.w %d2,[%a2]
80001b66:	6f 02 fb 7f 	jz.t %d2,0,80001b5c <IfxScuWdt_disableSafetyWatchdog+0x8e>
    IfxScuWdt_setSafetyEndinitInline(password);
}
80001b6a:	00 90       	ret 

80001b6c <IfxScuWdt_getCpuWatchdogPassword>:
    IfxScuWdt_setSafetyEndinitInline(password);
}


uint16 IfxScuWdt_getCpuWatchdogPassword(void)
{
80001b6c:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
80001b6e:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80001b72:	8f 72 00 21 	and %d2,%d2,7
    return IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
80001b76:	7b 30 00 3f 	movh %d3,61443
80001b7a:	1b c3 24 36 	addi %d3,%d3,25164
80001b7e:	13 c2 20 23 	madd %d2,%d3,%d2,12
    password  = watchdog->CON0.B.PW;
80001b82:	60 22       	mov.a %a2,%d2
80001b84:	54 22       	ld.w %d2,[%a2]
80001b86:	37 02 6e 21 	extr.u %d2,%d2,2,14
}
80001b8a:	8f f2 83 21 	xor %d2,%d2,63
80001b8e:	00 90       	ret 

80001b90 <IfxScuWdt_getSafetyWatchdogPassword>:
    return password;
}


uint16 IfxScuWdt_getSafetyWatchdogPassword(void)
{
80001b90:	40 ae       	mov.aa %a14,%sp
    password  = watchdog->CON0.B.PW;
80001b92:	91 30 00 2f 	movh.a %a2,61443
80001b96:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001b9a:	54 22       	ld.w %d2,[%a2]
80001b9c:	37 02 6e 21 	extr.u %d2,%d2,2,14
    return IfxScuWdt_getSafetyWatchdogPasswordInline();
}
80001ba0:	8f f2 83 21 	xor %d2,%d2,63
80001ba4:	00 90       	ret 

80001ba6 <IfxScuWdt_setCpuEndinit>:
    IfxScuWdt_setSafetyEndinit(password);
}


void IfxScuWdt_setCpuEndinit(uint16 password)
{
80001ba6:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
80001ba8:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80001bac:	8f 72 00 21 	and %d2,%d2,7
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
80001bb0:	7b 30 00 3f 	movh %d3,61443
80001bb4:	1b c3 24 36 	addi %d3,%d3,25164
80001bb8:	13 c2 20 23 	madd %d2,%d3,%d2,12
80001bbc:	60 22       	mov.a %a2,%d2
    if (watchdog->CON0.B.LCK)
80001bbe:	54 22       	ld.w %d2,[%a2]
80001bc0:	6f 12 0b 00 	jz.t %d2,1,80001bd6 <IfxScuWdt_setCpuEndinit+0x30>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001bc4:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001bc8:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001bcc:	54 22       	ld.w %d2,[%a2]
80001bce:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001bd2:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001bd4:	74 22       	st.w [%a2],%d2
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001bd6:	8f 24 00 30 	sh %d3,%d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001bda:	8f 33 40 31 	or %d3,%d3,3
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001bde:	54 22       	ld.w %d2,[%a2]
80001be0:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001be4:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001be6:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80001be8:	54 22       	ld.w %d2,[%a2]
80001bea:	6f 02 ff 7f 	jz.t %d2,0,80001be8 <IfxScuWdt_setCpuEndinit+0x42>
}
80001bee:	00 90       	ret 

80001bf0 <IfxScuWdt_setSafetyEndinit>:
    {}
}


void IfxScuWdt_setSafetyEndinit(uint16 password)
{
80001bf0:	40 ae       	mov.aa %a14,%sp
80001bf2:	37 04 70 40 	extr.u %d4,%d4,0,16
    if (SCU_WDTS_CON0.B.LCK)
80001bf6:	91 30 00 2f 	movh.a %a2,61443
80001bfa:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001bfe:	54 22       	ld.w %d2,[%a2]
80001c00:	6f 12 0b 00 	jz.t %d2,1,80001c16 <IfxScuWdt_setSafetyEndinit+0x26>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001c04:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001c08:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001c0c:	54 22       	ld.w %d2,[%a2]
80001c0e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001c12:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001c14:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001c16:	8f 24 00 30 	sh %d3,%d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001c1a:	8f 33 40 31 	or %d3,%d3,3
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001c1e:	91 30 00 2f 	movh.a %a2,61443
80001c22:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001c26:	54 22       	ld.w %d2,[%a2]
80001c28:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001c2c:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001c2e:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80001c30:	91 30 00 2f 	movh.a %a2,61443
80001c34:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80001c38:	54 22       	ld.w %d2,[%a2]
80001c3a:	6f 02 fb 7f 	jz.t %d2,0,80001c30 <IfxScuWdt_setSafetyEndinit+0x40>
    IfxScuWdt_setSafetyEndinitInline(password);
}
80001c3e:	00 90       	ret 

80001c40 <IfxPort_setPinMode>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
80001c40:	40 ae       	mov.aa %a14,%sp
80001c42:	80 48       	mov.d %d8,%a4
80001c44:	02 5b       	mov %d11,%d5
80001c46:	8f f4 0f d1 	and %d13,%d4,255
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
80001c4a:	1b 08 01 e0 	addi %d14,%d8,16
    uint8                 iocrIndex = (pinIndex / 4);
80001c4e:	37 04 66 a1 	extr.u %d10,%d4,2,6
    uint8                 shift     = (pinIndex & 0x3U) * 8;
80001c52:	8f 34 00 41 	and %d4,%d4,3
80001c56:	8f 34 00 90 	sh %d9,%d4,3

    if ((port == &MODULE_P40) || (port == &MODULE_P41))
80001c5a:	7b 40 00 4f 	movh %d4,61444
80001c5e:	1b 04 80 4c 	addi %d4,%d4,-14336
80001c62:	7b 40 00 3f 	movh %d3,61444
80001c66:	1b 03 90 3c 	addi %d3,%d3,-14080
80001c6a:	0b 48 00 21 	eq %d2,%d8,%d4
80001c6e:	0b 38 70 22 	or.eq %d2,%d8,%d3
80001c72:	df 02 12 80 	jne %d2,0,80001c96 <IfxPort_setPinMode+0x56>
        IfxScuWdt_clearCpuEndinit(passwd);
        port->PDISC.U &= ~(1 << pinIndex);
        IfxScuWdt_setCpuEndinit(passwd);
    }

    __ldmst(&iocr[iocrIndex].U, (0xFFUL << shift), (mode << shift));
80001c76:	8f 2a 00 20 	sh %d2,%d10,2
80001c7a:	60 e2       	mov.a %a2,%d14
80001c7c:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80001c80:	3b f0 0f 40 	mov %d4,255
80001c84:	0f 94 00 40 	sh %d4,%d4,%d9
80001c88:	0f 9b 00 20 	sh %d2,%d11,%d9
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80001c8c:	82 03       	mov %d3,0
    __asm__ volatile("mov %H2,%1 \n\
80001c8e:	02 43       	mov %d3,%d4
80001c90:	49 22 40 08 	ldmst [%a2]0,%e2
}
80001c94:	00 90       	ret 
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80001c96:	6d ff 6b ff 	call 80001b6c <IfxScuWdt_getCpuWatchdogPassword>
80001c9a:	02 2c       	mov %d12,%d2
        IfxScuWdt_clearCpuEndinit(passwd);
80001c9c:	02 24       	mov %d4,%d2
80001c9e:	6d ff 8c fe 	call 800019b6 <IfxScuWdt_clearCpuEndinit>
        port->PDISC.U &= ~(1 << pinIndex);
80001ca2:	60 82       	mov.a %a2,%d8
80001ca4:	19 22 20 10 	ld.w %d2,[%a2]96
80001ca8:	d7 02 01 2d 	insert %d2,%d2,0,%d13,1
80001cac:	59 22 20 10 	st.w [%a2]96,%d2
        IfxScuWdt_setCpuEndinit(passwd);
80001cb0:	02 c4       	mov %d4,%d12
80001cb2:	6d ff 7a ff 	call 80001ba6 <IfxScuWdt_setCpuEndinit>
80001cb6:	1d ff e0 ff 	j 80001c76 <IfxPort_setPinMode+0x36>

80001cba <IfxPort_setPinPadDriver>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
80001cba:	40 ae       	mov.aa %a14,%sp
80001cbc:	80 4b       	mov.d %d11,%a4
80001cbe:	02 5a       	mov %d10,%d5
80001cc0:	8f f4 0f 81 	and %d8,%d4,255
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80001cc4:	6d ff 54 ff 	call 80001b6c <IfxScuWdt_getCpuWatchdogPassword>
80001cc8:	02 29       	mov %d9,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80001cca:	02 24       	mov %d4,%d2
80001ccc:	6d ff 75 fe 	call 800019b6 <IfxScuWdt_clearCpuEndinit>
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
80001cd0:	1b 0b 04 40 	addi %d4,%d11,64
        uint8            pdrIndex = (pinIndex / 8);
80001cd4:	8f d8 1f 20 	sh %d2,%d8,-3
        uint8            shift    = (pinIndex & 0x7U) * 4;
80001cd8:	8f 78 00 31 	and %d3,%d8,7
80001cdc:	06 23       	sh %d3,2
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
80001cde:	06 22       	sh %d2,2
80001ce0:	60 42       	mov.a %a2,%d4
80001ce2:	01 22 00 46 	addsc.a %a4,%a2,%d2,0
80001ce6:	3b f0 00 20 	mov %d2,15
80001cea:	0f 32 00 20 	sh %d2,%d2,%d3
80001cee:	0f 3a 00 30 	sh %d3,%d10,%d3
                     ::"a"(address), "d"(mask), "d"((long long)value));
80001cf2:	53 13 40 60 	mul.u %e6,%d3,1
    __asm__ volatile("mov %H2,%1 \n\
80001cf6:	02 27       	mov %d7,%d2
80001cf8:	49 46 40 08 	ldmst [%a4]0,%e6
    }
    IfxScuWdt_setCpuEndinit(passwd);
80001cfc:	02 94       	mov %d4,%d9
80001cfe:	6d ff 54 ff 	call 80001ba6 <IfxScuWdt_setCpuEndinit>
}
80001d02:	00 90       	ret 

80001d04 <IfxCpu_Trap_memoryManagementError>:
{
80001d04:	40 ae       	mov.aa %a14,%sp
80001d06:	20 08       	sub.a %sp,8
}

IFX_INLINE void* Ifx__getA11(void)
{
    uint32 *res;
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80001d08:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001d0a:	8f f4 0f 41 	and %d4,%d4,255
    reg.U = __mfcr(CPU_CORE_ID);
80001d0e:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001d12:	8f 72 00 21 	and %d2,%d2,7
80001d16:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001d1a:	80 22       	mov.d %d2,%a2
80001d1c:	0f 54 a0 30 	or %d3,%d4,%d5
80001d20:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_MME_HOOK(trapWatch);
80001d24:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80001d28:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001d2a:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001d2e:	00 80       	rfe 
}
80001d30:	00 90       	ret 

80001d32 <IfxCpu_Trap_internalProtectionError>:
{
80001d32:	40 ae       	mov.aa %a14,%sp
80001d34:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80001d36:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001d38:	b7 14 18 44 	insert %d4,%d4,1,8,24
80001d3c:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001d40:	8f 72 00 21 	and %d2,%d2,7
80001d44:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001d48:	80 22       	mov.d %d2,%a2
80001d4a:	0f 54 a0 30 	or %d3,%d4,%d5
80001d4e:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_IPE_HOOK(trapWatch);
80001d52:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80001d56:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001d58:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001d5c:	00 80       	rfe 
}
80001d5e:	00 90       	ret 

80001d60 <IfxCpu_Trap_instructionError>:
{
80001d60:	40 ae       	mov.aa %a14,%sp
80001d62:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80001d64:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001d66:	b7 24 18 44 	insert %d4,%d4,2,8,24
80001d6a:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001d6e:	8f 72 00 21 	and %d2,%d2,7
80001d72:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001d76:	80 22       	mov.d %d2,%a2
80001d78:	0f 54 a0 30 	or %d3,%d4,%d5
80001d7c:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_IE_HOOK(trapWatch);
80001d80:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80001d84:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001d86:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001d8a:	00 80       	rfe 
}
80001d8c:	00 90       	ret 

80001d8e <IfxCpu_Trap_contextManagementError>:
{
80001d8e:	40 ae       	mov.aa %a14,%sp
80001d90:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80001d92:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001d94:	b7 34 18 44 	insert %d4,%d4,3,8,24
80001d98:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001d9c:	8f 72 00 21 	and %d2,%d2,7
80001da0:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001da4:	80 22       	mov.d %d2,%a2
80001da6:	0f 54 a0 30 	or %d3,%d4,%d5
80001daa:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_CME_HOOK(trapWatch);
80001dae:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80001db2:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001db4:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001db8:	00 80       	rfe 
}
80001dba:	00 90       	ret 

80001dbc <IfxCpu_Trap_busError>:
{
80001dbc:	40 ae       	mov.aa %a14,%sp
80001dbe:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80001dc0:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001dc2:	b7 44 18 44 	insert %d4,%d4,4,8,24
80001dc6:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001dca:	8f 72 00 21 	and %d2,%d2,7
80001dce:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001dd2:	80 22       	mov.d %d2,%a2
80001dd4:	0f 54 a0 30 	or %d3,%d4,%d5
80001dd8:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_BE_HOOK(trapWatch);
80001ddc:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80001de0:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001de2:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001de6:	00 80       	rfe 
}
80001de8:	00 90       	ret 

80001dea <IfxCpu_Trap_assertion>:
{
80001dea:	40 ae       	mov.aa %a14,%sp
80001dec:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80001dee:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001df0:	8f f4 0f 41 	and %d4,%d4,255
80001df4:	3b 00 50 20 	mov %d2,1280
80001df8:	a6 24       	or %d4,%d2
80001dfa:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001dfe:	8f 72 00 21 	and %d2,%d2,7
80001e02:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001e06:	80 22       	mov.d %d2,%a2
80001e08:	0f 54 a0 30 	or %d3,%d4,%d5
80001e0c:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_ASSERT_HOOK(trapWatch);
80001e10:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80001e14:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001e16:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001e1a:	00 80       	rfe 
}
80001e1c:	00 90       	ret 

80001e1e <IfxCpu_Trap_systemCall_Cpu0>:
{
80001e1e:	40 ae       	mov.aa %a14,%sp
80001e20:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80001e22:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001e24:	b7 64 18 44 	insert %d4,%d4,6,8,24
80001e28:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001e2c:	8f 72 00 21 	and %d2,%d2,7
80001e30:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001e34:	80 22       	mov.d %d2,%a2
80001e36:	0f 54 a0 30 	or %d3,%d4,%d5
80001e3a:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU0_HOOK(trapWatch);
80001e3e:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001e42:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001e46:	00 80       	rfe 
}
80001e48:	00 90       	ret 

80001e4a <IfxCpu_Trap_systemCall_Cpu1>:
{
80001e4a:	40 ae       	mov.aa %a14,%sp
80001e4c:	20 08       	sub.a %sp,8
80001e4e:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001e50:	b7 64 18 44 	insert %d4,%d4,6,8,24
80001e54:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001e58:	8f 72 00 21 	and %d2,%d2,7
80001e5c:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001e60:	80 22       	mov.d %d2,%a2
80001e62:	0f 54 a0 30 	or %d3,%d4,%d5
80001e66:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU1_HOOK(trapWatch);
80001e6a:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001e6e:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001e72:	00 80       	rfe 
}
80001e74:	00 90       	ret 

80001e76 <IfxCpu_Trap_systemCall_Cpu2>:
{
80001e76:	40 ae       	mov.aa %a14,%sp
80001e78:	20 08       	sub.a %sp,8
80001e7a:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001e7c:	b7 64 18 44 	insert %d4,%d4,6,8,24
80001e80:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001e84:	8f 72 00 21 	and %d2,%d2,7
80001e88:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001e8c:	80 22       	mov.d %d2,%a2
80001e8e:	0f 54 a0 30 	or %d3,%d4,%d5
80001e92:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU2_HOOK(trapWatch);
80001e96:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001e9a:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001e9e:	00 80       	rfe 
}
80001ea0:	00 90       	ret 

80001ea2 <IfxCpu_Trap_systemCall_Cpu3>:
{
80001ea2:	40 ae       	mov.aa %a14,%sp
80001ea4:	20 08       	sub.a %sp,8
80001ea6:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001ea8:	b7 64 18 44 	insert %d4,%d4,6,8,24
80001eac:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001eb0:	8f 72 00 21 	and %d2,%d2,7
80001eb4:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001eb8:	80 22       	mov.d %d2,%a2
80001eba:	0f 54 a0 30 	or %d3,%d4,%d5
80001ebe:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU3_HOOK(trapWatch);
80001ec2:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001ec6:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001eca:	00 80       	rfe 
}
80001ecc:	00 90       	ret 

80001ece <IfxCpu_Trap_nonMaskableInterrupt>:
{
80001ece:	40 ae       	mov.aa %a14,%sp
80001ed0:	20 08       	sub.a %sp,8
80001ed2:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001ed4:	b7 74 18 44 	insert %d4,%d4,7,8,24
80001ed8:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001edc:	8f 72 00 21 	and %d2,%d2,7
80001ee0:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001ee4:	80 22       	mov.d %d2,%a2
80001ee6:	0f 54 a0 30 	or %d3,%d4,%d5
80001eea:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_NMI_HOOK(trapWatch);    
80001eee:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001ef2:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001ef6:	00 80       	rfe 
}
80001ef8:	00 90       	ret 

80001efa <IfxCpu_waitEvent>:
    return retVal;
}


boolean IfxCpu_waitEvent(IfxCpu_syncEvent *event, uint32 timeoutMilliSec)
{
80001efa:	40 ae       	mov.aa %a14,%sp
80001efc:	40 4c       	mov.aa %a12,%a4
80001efe:	02 48       	mov %d8,%d4
    volatile uint32 *sync          = (volatile uint32 *)IFXCPU_GLB_ADDR_DSPR(__mfcr(CPU_CORE_ID), event);
80001f00:	80 42       	mov.d %d2,%a4
80001f02:	b7 02 1c 20 	insert %d2,%d2,0,0,28
80001f06:	7b 00 00 3d 	movh %d3,53248
80001f0a:	5f 32 2b 00 	jeq %d2,%d3,80001f60 <IfxCpu_waitEvent+0x66>
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_0) / SCU_CCUCON0.B.STMDIV;
80001f0e:	82 04       	mov %d4,0
80001f10:	6d ff ce f8 	call 800010ac <IfxScuCcu_getSourceFrequency>
80001f14:	91 30 00 2f 	movh.a %a2,61443
80001f18:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
80001f1c:	54 23       	ld.w %d3,[%a2]
80001f1e:	8f f3 00 31 	and %d3,%d3,15
80001f22:	4b 03 41 31 	itof %d3,%d3
80001f26:	4b 32 51 20 	div.f %d2,%d2,%d3

    boolean          errorcnt      = 0U;
    /* Divide with 1000, gives the count value equivalent to milliseconds */
    uint32           stmCount      = (uint32)((IfxScuCcu_getStmFrequency() / 1000) * timeoutMilliSec);
80001f2a:	7b a0 47 34 	movh %d3,17530
80001f2e:	4b 32 51 20 	div.f %d2,%d2,%d3
80001f32:	4b 08 61 41 	utof %d4,%d8
80001f36:	4b 24 41 40 	mul.f %d4,%d4,%d2
80001f3a:	4b 04 71 31 	ftouz %d3,%d4
    uint32           stmCountBegin = STM0_TIM0.U;
80001f3e:	85 f4 10 01 	ld.w %d4,f0001010 <bmhd_3_copy+0x40bffa10>

    while ((*sync & IFXCPU_CFG_ALLCORE_DONE) != IFXCPU_CFG_ALLCORE_DONE)
80001f42:	54 c2       	ld.w %d2,[%a12]
80001f44:	8f f2 00 21 	and %d2,%d2,15
80001f48:	8b f2 20 22 	ne %d2,%d2,15
80001f4c:	df 02 18 00 	jeq %d2,0,80001f7c <IfxCpu_waitEvent+0x82>
    __asm__ volatile ("nop" : : : "memory");
80001f50:	00 00       	nop 
    {
        __nop();

        if ((uint32)(STM0_TIM0.U - stmCountBegin) >= stmCount)
80001f52:	85 f2 10 01 	ld.w %d2,f0001010 <bmhd_3_copy+0x40bffa10>
80001f56:	a2 42       	sub %d2,%d4
80001f58:	3f 32 f5 ff 	jlt.u %d2,%d3,80001f42 <IfxCpu_waitEvent+0x48>
        {
            errorcnt = 1;
80001f5c:	82 12       	mov %d2,1
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }

    return errorcnt;
}
80001f5e:	00 90       	ret 
    volatile uint32 *sync          = (volatile uint32 *)IFXCPU_GLB_ADDR_DSPR(__mfcr(CPU_CORE_ID), event);
80001f60:	80 42       	mov.d %d2,%a4
80001f62:	b7 02 0c 3a 	insert %d3,%d2,0,20,12
80001f66:	b7 f3 03 3e 	insert %d3,%d3,15,28,3
80001f6a:	4d c0 e1 2f 	mfcr %d2,$core_id
80001f6e:	8f c2 01 20 	sh %d2,%d2,28
80001f72:	0b 23 80 20 	sub %d2,%d3,%d2
80001f76:	60 2c       	mov.a %a12,%d2
80001f78:	1d ff cb ff 	j 80001f0e <IfxCpu_waitEvent+0x14>
80001f7c:	00 90       	ret 

80001f7e <IfxCpu_emitEvent>:


void IfxCpu_emitEvent(IfxCpu_syncEvent *event)
{
80001f7e:	40 ae       	mov.aa %a14,%sp
    Ifx__imaskldmst(event, 1, __mfcr(CPU_CORE_ID), 1);
80001f80:	4d c0 e1 2f 	mfcr %d2,$core_id
80001f84:	82 13       	mov %d3,1
80001f86:	57 30 21 22 	imask %e2,%d3,%d2,1
80001f8a:	49 42 40 08 	ldmst [%a4]0,%e2
}
80001f8e:	00 90       	ret 

80001f90 <IfxCan_Node_clearRxBufferNewDataFlag>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxCan_Node_clearRxBufferNewDataFlag(Ifx_CAN_N *node, IfxCan_RxBufferId rxBufferId)
{
80001f90:	40 ae       	mov.aa %a14,%sp
    uint32 value;

    if (rxBufferId < IfxCan_RxBufferId_32)
80001f92:	8b 04 a2 22 	ge.u %d2,%d4,32
80001f96:	df 02 08 80 	jne %d2,0,80001fa6 <IfxCan_Node_clearRxBufferNewDataFlag+0x16>
    {
        value         = (1U << rxBufferId);
80001f9a:	82 12       	mov %d2,1
80001f9c:	0f 42 00 20 	sh %d2,%d2,%d4
        node->NDAT1.U = value;
80001fa0:	59 42 18 60 	st.w [%a4]408,%d2
80001fa4:	00 90       	ret 
    }
    else
    {
        value         = (1U << (rxBufferId - 32));
80001fa6:	1b 04 fe 4f 	addi %d4,%d4,-32
80001faa:	82 13       	mov %d3,1
80001fac:	0f 43 00 30 	sh %d3,%d3,%d4
        node->NDAT2.U = value;
80001fb0:	59 43 1c 60 	st.w [%a4]412,%d3
    }
}
80001fb4:	00 90       	ret 

80001fb6 <IfxCan_Node_getDataLength>:


uint32 IfxCan_Node_getDataLength(IfxCan_DataLengthCode dataLengthCode)
{
80001fb6:	40 ae       	mov.aa %a14,%sp
    uint32 numBytes;

    if (dataLengthCode <= IfxCan_DataLengthCode_8)
80001fb8:	bf 94 08 80 	jlt.u %d4,9,80001fc8 <IfxCan_Node_getDataLength+0x12>
    {
        numBytes = (uint32)dataLengthCode;
    }
    else if (dataLengthCode <= IfxCan_DataLengthCode_24)
80001fbc:	ff d4 0a 80 	jge.u %d4,13,80001fd0 <IfxCan_Node_getDataLength+0x1a>
    {
        numBytes = ((uint32)dataLengthCode - 6) << 2;
80001fc0:	1b a4 ff 2f 	addi %d2,%d4,-6
80001fc4:	8f 22 00 40 	sh %d4,%d2,2
    else
    {
        numBytes = ((uint32)dataLengthCode - 11) << 4;
    }

    return (numBytes + 3) >> 2;
80001fc8:	1b 34 00 20 	addi %d2,%d4,3
}
80001fcc:	06 e2       	sh %d2,-2
80001fce:	00 90       	ret 
        numBytes = ((uint32)dataLengthCode - 11) << 4;
80001fd0:	1b 54 ff 4f 	addi %d4,%d4,-11
80001fd4:	06 44       	sh %d4,4
80001fd6:	1d ff f9 ff 	j 80001fc8 <IfxCan_Node_getDataLength+0x12>

80001fda <IfxCan_Node_getFrameMode>:
    return (Ifx_CAN_EXTMSG *)extendedFilterElementAddress;
}


IfxCan_FrameMode IfxCan_Node_getFrameMode(Ifx_CAN_RXMSG *rxBufferElement)
{
80001fda:	40 ae       	mov.aa %a14,%sp
    IfxCan_FrameMode frameMode;

    /* if CAN FD long frame is been selected */
    if (rxBufferElement->R1.B.FDF)
80001fdc:	d9 42 04 00 	lea %a2,[%a4]4
80001fe0:	19 42 04 00 	ld.w %d2,[%a4]4
80001fe4:	ef 52 09 00 	jz.t %d2,21,80001ff6 <IfxCan_Node_getFrameMode+0x1c>
    {
        /* if bitrate switch is been set */
        if (rxBufferElement->R1.B.BRS)
80001fe8:	54 22       	ld.w %d2,[%a2]
80001fea:	ef 42 04 80 	jnz.t %d2,20,80001ff2 <IfxCan_Node_getFrameMode+0x18>
            frameMode = IfxCan_FrameMode_fdLongAndFast;
        }
        /* if bitrate switch is not been set */
        else
        {
            frameMode = IfxCan_FrameMode_fdLong;
80001fee:	82 12       	mov %d2,1
    {
        frameMode = IfxCan_FrameMode_standard;
    }

    return frameMode;
}
80001ff0:	00 90       	ret 
            frameMode = IfxCan_FrameMode_fdLongAndFast;
80001ff2:	82 22       	mov %d2,2
80001ff4:	00 90       	ret 
        frameMode = IfxCan_FrameMode_standard;
80001ff6:	82 02       	mov %d2,0
80001ff8:	00 90       	ret 

80001ffa <IfxCan_Node_getRxBufferDataFieldSize>:
    return frameMode;
}


uint8 IfxCan_Node_getRxBufferDataFieldSize(Ifx_CAN_N *node)
{
80001ffa:	40 ae       	mov.aa %a14,%sp
    IfxCan_DataFieldSize sizeCode = (IfxCan_DataFieldSize)node->RX.ESC.B.RBDS;
80001ffc:	19 42 3c 60 	ld.w %d2,[%a4]444
80002000:	37 02 63 24 	extr.u %d2,%d2,8,3

    uint8                size;

    if (sizeCode < IfxCan_DataFieldSize_32)
80002004:	ff 52 07 80 	jge.u %d2,5,80002012 <IfxCan_Node_getRxBufferDataFieldSize+0x18>
    {
        size = ((uint8)sizeCode + 2) * 4;
80002008:	c2 22       	add %d2,2
8000200a:	06 22       	sh %d2,2
8000200c:	8f f2 0f 21 	and %d2,%d2,255
80002010:	00 90       	ret 
    }
    else
    {
        size = ((uint8)sizeCode - 3) * 16;
80002012:	c2 d2       	add %d2,-3
80002014:	06 42       	sh %d2,4
80002016:	8f f2 0f 21 	and %d2,%d2,255
    }

    return size;
}
8000201a:	00 90       	ret 

8000201c <IfxCan_Node_getRxBufferElementAddress>:


Ifx_CAN_RXMSG *IfxCan_Node_getRxBufferElementAddress(Ifx_CAN_N *node, uint32 ramBaseAddress, uint16 rxBuffersStartAddress, IfxCan_RxBufferId rxBufferNumber)
{
8000201c:	40 ae       	mov.aa %a14,%sp
8000201e:	02 49       	mov %d9,%d4
80002020:	02 6a       	mov %d10,%d6
80002022:	37 05 70 80 	extr.u %d8,%d5,0,16
    uint16 rxBufferIndex, rxBufferSize, numOfDataBytes, numOfconfigBytes = 8;

    numOfDataBytes = IfxCan_Node_getRxBufferDataFieldSize(node);
80002026:	6d ff ea ff 	call 80001ffa <IfxCan_Node_getRxBufferDataFieldSize>
8000202a:	37 02 70 20 	extr.u %d2,%d2,0,16
    rxBufferSize   = numOfconfigBytes + numOfDataBytes;
8000202e:	1b 82 00 20 	addi %d2,%d2,8
80002032:	37 02 70 20 	extr.u %d2,%d2,0,16
    rxBufferIndex  = rxBufferSize * ((uint16)rxBufferNumber);
80002036:	37 0a 70 a0 	extr.u %d10,%d10,0,16
8000203a:	e2 a2       	mul %d2,%d10
8000203c:	37 02 70 20 	extr.u %d2,%d2,0,16
    uint32 rxBufferElementAddress = ramBaseAddress + rxBuffersStartAddress + rxBufferIndex;
80002040:	60 82       	mov.a %a2,%d8
80002042:	01 29 00 26 	addsc.a %a2,%a2,%d9,0

    return (Ifx_CAN_RXMSG *)rxBufferElementAddress;
}
80002046:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000204a:	00 90       	ret 

8000204c <IfxCan_Node_getRxFifo0DataFieldSize>:


uint8 IfxCan_Node_getRxFifo0DataFieldSize(Ifx_CAN_N *node)
{
8000204c:	40 ae       	mov.aa %a14,%sp
    IfxCan_DataFieldSize sizeCode = (IfxCan_DataFieldSize)node->RX.ESC.B.F0DS;
8000204e:	19 42 3c 60 	ld.w %d2,[%a4]444
80002052:	8f 72 00 21 	and %d2,%d2,7

    uint8                size;

    if (sizeCode < IfxCan_DataFieldSize_32)
80002056:	ff 52 05 80 	jge.u %d2,5,80002060 <IfxCan_Node_getRxFifo0DataFieldSize+0x14>
    {
        size = ((uint8)sizeCode + 2) * 4;
8000205a:	c2 22       	add %d2,2
8000205c:	06 22       	sh %d2,2
8000205e:	00 90       	ret 
    }
    else
    {
        size = ((uint8)sizeCode - 3) * 16;
80002060:	c2 d2       	add %d2,-3
80002062:	06 42       	sh %d2,4
80002064:	8f f2 0f 21 	and %d2,%d2,255
    }

    return size;
}
80002068:	00 90       	ret 

8000206a <IfxCan_Node_getRxFifo0ElementAddress>:


Ifx_CAN_RXMSG *IfxCan_Node_getRxFifo0ElementAddress(Ifx_CAN_N *node, uint32 ramBaseAddress, uint16 rxFifo0StartAddress, IfxCan_RxBufferId rxBufferNumber)
{
8000206a:	40 ae       	mov.aa %a14,%sp
8000206c:	02 49       	mov %d9,%d4
8000206e:	02 6a       	mov %d10,%d6
80002070:	37 05 70 80 	extr.u %d8,%d5,0,16
    uint16 rxFifoElementIndex, rxFifoElementSize, numOfDataBytes, numOfconfigBytes = 8;

    numOfDataBytes     = IfxCan_Node_getRxFifo0DataFieldSize(node);
80002074:	6d ff ec ff 	call 8000204c <IfxCan_Node_getRxFifo0DataFieldSize>
80002078:	37 02 70 20 	extr.u %d2,%d2,0,16
    rxFifoElementSize  = numOfconfigBytes + numOfDataBytes;
8000207c:	1b 82 00 20 	addi %d2,%d2,8
80002080:	37 02 70 20 	extr.u %d2,%d2,0,16
    rxFifoElementIndex = rxFifoElementSize * ((uint16)rxBufferNumber);
80002084:	37 0a 70 a0 	extr.u %d10,%d10,0,16
80002088:	e2 a2       	mul %d2,%d10
8000208a:	37 02 70 20 	extr.u %d2,%d2,0,16
    uint32 rxFifoElementAddress = ramBaseAddress + rxFifo0StartAddress + rxFifoElementIndex;
8000208e:	60 82       	mov.a %a2,%d8
80002090:	01 29 00 26 	addsc.a %a2,%a2,%d9,0

    return (Ifx_CAN_RXMSG *)rxFifoElementAddress;
}
80002094:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80002098:	00 90       	ret 

8000209a <IfxCan_Node_getRxFifo1DataFieldSize>:


uint8 IfxCan_Node_getRxFifo1DataFieldSize(Ifx_CAN_N *node)
{
8000209a:	40 ae       	mov.aa %a14,%sp
    IfxCan_DataFieldSize sizeCode = (IfxCan_DataFieldSize)node->RX.ESC.B.F1DS;
8000209c:	19 42 3c 60 	ld.w %d2,[%a4]444
800020a0:	37 02 63 22 	extr.u %d2,%d2,4,3

    uint8                size;

    if (sizeCode < IfxCan_DataFieldSize_32)
800020a4:	ff 52 07 80 	jge.u %d2,5,800020b2 <IfxCan_Node_getRxFifo1DataFieldSize+0x18>
    {
        size = ((uint8)sizeCode + 2) * 4;
800020a8:	c2 22       	add %d2,2
800020aa:	06 22       	sh %d2,2
800020ac:	8f f2 0f 21 	and %d2,%d2,255
800020b0:	00 90       	ret 
    }
    else
    {
        size = ((uint8)sizeCode - 3) * 16;
800020b2:	c2 d2       	add %d2,-3
800020b4:	06 42       	sh %d2,4
800020b6:	8f f2 0f 21 	and %d2,%d2,255
    }

    return size;
}
800020ba:	00 90       	ret 

800020bc <IfxCan_Node_getRxFifo1ElementAddress>:


Ifx_CAN_RXMSG *IfxCan_Node_getRxFifo1ElementAddress(Ifx_CAN_N *node, uint32 ramBaseAddress, uint16 rxFifo1StartAddress, IfxCan_RxBufferId rxBufferNumber)
{
800020bc:	40 ae       	mov.aa %a14,%sp
800020be:	02 49       	mov %d9,%d4
800020c0:	02 6a       	mov %d10,%d6
800020c2:	37 05 70 80 	extr.u %d8,%d5,0,16
    uint16 rxFifoElementIndex, rxFifoElementSize, numOfDataBytes, numOfconfigBytes = 8;

    numOfDataBytes     = IfxCan_Node_getRxFifo1DataFieldSize(node);
800020c6:	6d ff ea ff 	call 8000209a <IfxCan_Node_getRxFifo1DataFieldSize>
800020ca:	37 02 70 20 	extr.u %d2,%d2,0,16
    rxFifoElementSize  = numOfconfigBytes + numOfDataBytes;
800020ce:	1b 82 00 20 	addi %d2,%d2,8
800020d2:	37 02 70 20 	extr.u %d2,%d2,0,16
    rxFifoElementIndex = rxFifoElementSize * ((uint16)rxBufferNumber);
800020d6:	37 0a 70 a0 	extr.u %d10,%d10,0,16
800020da:	e2 a2       	mul %d2,%d10
800020dc:	37 02 70 20 	extr.u %d2,%d2,0,16
    uint32 rxFifoElementAddress = ramBaseAddress + rxFifo1StartAddress + rxFifoElementIndex;
800020e0:	60 82       	mov.a %a2,%d8
800020e2:	01 29 00 26 	addsc.a %a2,%a2,%d9,0

    return (Ifx_CAN_RXMSG *)rxFifoElementAddress;
}
800020e6:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800020ea:	00 90       	ret 

800020ec <IfxCan_Node_readData>:
    }
}


void IfxCan_Node_readData(Ifx_CAN_RXMSG *rxBufferElement, IfxCan_DataLengthCode dataLengthCode, uint32 *data)
{
800020ec:	40 ae       	mov.aa %a14,%sp
800020ee:	80 49       	mov.d %d9,%a4
800020f0:	80 58       	mov.d %d8,%a5
    uint32  i;
    uint32 *destinationAddress = (uint32 *)rxBufferElement + 2;
    /* get number of data bytes from data length code (DLC) */
    uint32  length             = IfxCan_Node_getDataLength(dataLengthCode);
800020f2:	6d ff 62 ff 	call 80001fb6 <IfxCan_Node_getDataLength>

    /* read data from the data section of Rx Buffer element  */
    for (i = 0; i < length; i++)
800020f6:	82 03       	mov %d3,0
800020f8:	1d 00 0e 00 	j 80002114 <IfxCan_Node_readData+0x28>
    {
        data[i] = destinationAddress[i];
800020fc:	8f 23 00 40 	sh %d4,%d3,2
80002100:	60 82       	mov.a %a2,%d8
80002102:	01 24 00 36 	addsc.a %a3,%a2,%d4,0
80002106:	60 92       	mov.a %a2,%d9
80002108:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
8000210c:	19 24 08 00 	ld.w %d4,[%a2]8
80002110:	74 34       	st.w [%a3],%d4
    for (i = 0; i < length; i++)
80002112:	c2 13       	add %d3,1
80002114:	3f 23 f4 ff 	jlt.u %d3,%d2,800020fc <IfxCan_Node_readData+0x10>
    }
}
80002118:	00 90       	ret 

8000211a <IfxCan_Can_readMessage>:
    config->can = can->can;
}


void IfxCan_Can_readMessage(IfxCan_Can_Node *node, IfxCan_Message *message, uint32 *data)
{
8000211a:	40 ae       	mov.aa %a14,%sp
8000211c:	40 4d       	mov.aa %a13,%a4
8000211e:	40 5c       	mov.aa %a12,%a5
80002120:	80 69       	mov.d %d9,%a6
    IfxCan_RxBufferId bufferId = IfxCan_RxBufferId_0;

    Ifx_CAN_RXMSG    *rxBufferElement;

    if ((message->readFromRxFifo0) || (message->readFromRxFifo1))
80002122:	19 52 1c 00 	ld.w %d2,[%a5]28
80002126:	b7 02 10 20 	insert %d2,%d2,0,0,16
8000212a:	df 02 5a 00 	jeq %d2,0,800021de <IfxCan_Can_readMessage+0xc4>
    {
        if (message->readFromRxFifo0)
8000212e:	39 52 1e 00 	ld.bu %d2,[%a5]30
80002132:	df 02 46 00 	jeq %d2,0,800021be <IfxCan_Can_readMessage+0xa4>
        {
            /* get the Tx FIFO 0 ELement address */
            bufferId        = IfxCan_Node_getRxFifo0GetIndex(node->node);
80002136:	99 44 04 00 	ld.a %a4,[%a4]4
}


IFX_INLINE IfxCan_RxBufferId IfxCan_Node_getRxFifo0GetIndex(Ifx_CAN_N *node)
{
    return (IfxCan_RxBufferId)node->RX.F0S.B.F0GI;
8000213a:	19 48 24 60 	ld.w %d8,[%a4]420
8000213e:	37 08 66 84 	extr.u %d8,%d8,8,6
            rxBufferElement = IfxCan_Node_getRxFifo0ElementAddress(node->node, node->messageRAM.baseAddress, node->messageRAM.rxFifo0StartAddress, bufferId);
80002142:	02 86       	mov %d6,%d8
80002144:	b9 d5 14 00 	ld.hu %d5,[%a13]20
80002148:	19 d4 0c 00 	ld.w %d4,[%a13]12
8000214c:	6d ff 8f ff 	call 8000206a <IfxCan_Node_getRxFifo0ElementAddress>
80002150:	40 2f       	mov.aa %a15,%a2
    IfxCan_MessageIdLength messageIdLength = (IfxCan_MessageIdLength)rxBufferElement->R0.B.XTD;
80002152:	48 03       	ld.w %d3,[%a15]0
    return rxBufferElement->R0.B.ID >> ((messageIdLength != IfxCan_MessageIdLength_standard) ? 0 : 18);
80002154:	48 02       	ld.w %d2,[%a15]0
80002156:	37 02 7d 20 	extr.u %d2,%d2,0,29
8000215a:	ef e3 4f 00 	jz.t %d3,30,800021f8 <IfxCan_Can_readMessage+0xde>
8000215e:	82 04       	mov %d4,0
80002160:	8b 04 00 31 	rsub %d3,%d4,0
80002164:	0f 32 20 30 	shas %d3,%d2,%d3
        bufferId        = (IfxCan_RxBufferId)message->bufferNumber;
        rxBufferElement = IfxCan_Node_getRxBufferElementAddress(node->node, node->messageRAM.baseAddress, node->messageRAM.rxBuffersStartAddress, bufferId);
    }

    /*get message ID */
    message->messageId = IfxCan_Node_getMesssageId(rxBufferElement);
80002168:	59 c3 04 00 	st.w [%a12]4,%d3

    /* get message ID length */
    message->messageIdLength = (IfxCan_MessageIdLength)rxBufferElement->R0.B.XTD;
8000216c:	48 02       	ld.w %d2,[%a15]0
8000216e:	37 02 61 2f 	extr.u %d2,%d2,30,1
80002172:	59 c2 0c 00 	st.w [%a12]12,%d2
    return (IfxCan_DataLengthCode)rxBufferElement->R1.B.DLC;
80002176:	48 12       	ld.w %d2,[%a15]4
80002178:	37 02 64 28 	extr.u %d2,%d2,16,4

    /* get data length code*/
    message->dataLengthCode = (IfxCan_DataLengthCode)IfxCan_Node_getDataLengthCode(rxBufferElement);
8000217c:	59 c2 14 00 	st.w [%a12]20,%d2

    /* get CAN frame mode of operation */
    message->frameMode = IfxCan_Node_getFrameMode(rxBufferElement);
80002180:	40 f4       	mov.aa %a4,%a15
80002182:	6d ff 2c ff 	call 80001fda <IfxCan_Node_getFrameMode>
80002186:	59 c2 18 00 	st.w [%a12]24,%d2

    /*get message bufferNumber*/
    message->bufferNumber = bufferId;
8000218a:	34 c8       	st.b [%a12],%d8

    /* read data */
    IfxCan_Node_readData(rxBufferElement, message->dataLengthCode, data);
8000218c:	60 95       	mov.a %a5,%d9
8000218e:	19 c4 14 00 	ld.w %d4,[%a12]20
80002192:	40 f4       	mov.aa %a4,%a15
80002194:	6d ff ac ff 	call 800020ec <IfxCan_Node_readData>

    /* write acknowledgement index incase of FIFO */
    if (message->readFromRxFifo0)
80002198:	39 c2 1e 00 	ld.bu %d2,[%a12]30
8000219c:	df 02 32 00 	jeq %d2,0,80002200 <IfxCan_Can_readMessage+0xe6>
    {
        IfxCan_Node_setRxFifo0AcknowledgeIndex(node->node, bufferId);
800021a0:	99 d2 04 00 	ld.a %a2,[%a13]4
}


IFX_INLINE void IfxCan_Node_setRxFifo0AcknowledgeIndex(Ifx_CAN_N *node, IfxCan_RxBufferId RxBufferNumber)
{
    node->RX.F0A.B.F0AI = RxBufferNumber;
800021a4:	d9 23 28 60 	lea %a3,[%a2]424
800021a8:	19 22 28 60 	ld.w %d2,[%a2]424
800021ac:	37 82 06 20 	insert %d2,%d2,%d8,0,6
800021b0:	74 32       	st.w [%a3],%d2
    {
        IfxCan_Node_setRxFifo1AcknowledgeIndex(node->node, bufferId);
    }

    /* clear newdata flag after reading */
    IfxCan_Node_clearRxBufferNewDataFlag(node->node, bufferId);
800021b2:	02 84       	mov %d4,%d8
800021b4:	99 d4 04 00 	ld.a %a4,[%a13]4
800021b8:	6d ff ec fe 	call 80001f90 <IfxCan_Node_clearRxBufferNewDataFlag>

}
800021bc:	00 90       	ret 
            bufferId        = IfxCan_Node_getRxFifo1GetIndex(node->node);
800021be:	99 44 04 00 	ld.a %a4,[%a4]4
    return (IfxCan_RxBufferId)node->RX.F1S.B.F1GI;
800021c2:	19 48 34 60 	ld.w %d8,[%a4]436
800021c6:	37 08 66 84 	extr.u %d8,%d8,8,6
            rxBufferElement = IfxCan_Node_getRxFifo1ElementAddress(node->node, node->messageRAM.baseAddress, node->messageRAM.rxFifo1StartAddress, bufferId);
800021ca:	02 86       	mov %d6,%d8
800021cc:	b9 d5 16 00 	ld.hu %d5,[%a13]22
800021d0:	19 d4 0c 00 	ld.w %d4,[%a13]12
800021d4:	6d ff 74 ff 	call 800020bc <IfxCan_Node_getRxFifo1ElementAddress>
800021d8:	40 2f       	mov.aa %a15,%a2
800021da:	1d ff bc ff 	j 80002152 <IfxCan_Can_readMessage+0x38>
        bufferId        = (IfxCan_RxBufferId)message->bufferNumber;
800021de:	14 58       	ld.bu %d8,[%a5]
        rxBufferElement = IfxCan_Node_getRxBufferElementAddress(node->node, node->messageRAM.baseAddress, node->messageRAM.rxBuffersStartAddress, bufferId);
800021e0:	02 86       	mov %d6,%d8
800021e2:	b9 45 18 00 	ld.hu %d5,[%a4]24
800021e6:	19 44 0c 00 	ld.w %d4,[%a4]12
800021ea:	99 44 04 00 	ld.a %a4,[%a4]4
800021ee:	6d ff 17 ff 	call 8000201c <IfxCan_Node_getRxBufferElementAddress>
800021f2:	40 2f       	mov.aa %a15,%a2
800021f4:	1d ff af ff 	j 80002152 <IfxCan_Can_readMessage+0x38>
    return rxBufferElement->R0.B.ID >> ((messageIdLength != IfxCan_MessageIdLength_standard) ? 0 : 18);
800021f8:	3b 20 01 40 	mov %d4,18
800021fc:	1d ff b2 ff 	j 80002160 <IfxCan_Can_readMessage+0x46>
    else if (message->readFromRxFifo1)
80002200:	39 c2 1f 00 	ld.bu %d2,[%a12]31
80002204:	df 02 d7 7f 	jeq %d2,0,800021b2 <IfxCan_Can_readMessage+0x98>
        IfxCan_Node_setRxFifo1AcknowledgeIndex(node->node, bufferId);
80002208:	99 d2 04 00 	ld.a %a2,[%a13]4
}


IFX_INLINE void IfxCan_Node_setRxFifo1AcknowledgeIndex(Ifx_CAN_N *node, IfxCan_RxBufferId RxBufferNumber)
{
    node->RX.F1A.B.F1AI = RxBufferNumber;
8000220c:	d9 23 38 60 	lea %a3,[%a2]440
80002210:	19 22 38 60 	ld.w %d2,[%a2]440
80002214:	37 82 06 20 	insert %d2,%d2,%d8,0,6
80002218:	74 32       	st.w [%a3],%d2
}
8000221a:	1d ff cc ff 	j 800021b2 <IfxCan_Can_readMessage+0x98>

8000221e <Ifx_Ssw_clearCpuEndinit>:
    return Ifx_Ssw_getSafetyWatchdogPasswordInline();
}


void Ifx_Ssw_clearCpuEndinit(Ifx_SCU_WDTCPU *watchdog, unsigned short password)
{
8000221e:	40 ae       	mov.aa %a14,%sp
    if (watchdog->CON0.B.LCK)
80002220:	54 42       	ld.w %d2,[%a4]
80002222:	6f 12 0b 00 	jz.t %d2,1,80002238 <Ifx_Ssw_clearCpuEndinit+0x1a>
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002226:	8f 24 00 30 	sh %d3,%d4,2
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000222a:	54 42       	ld.w %d2,[%a4]
8000222c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002230:	a6 32       	or %d2,%d3
80002232:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002236:	74 42       	st.w [%a4],%d2
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002238:	06 24       	sh %d4,2
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000223a:	54 42       	ld.w %d2,[%a4]
8000223c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002240:	a6 42       	or %d2,%d4
80002242:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = ((unsigned int)0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002246:	74 42       	st.w [%a4],%d2
    watchdog->CON0.U;
80002248:	54 42       	ld.w %d2,[%a4]
    Ifx_Ssw_clearCpuEndinitInline(watchdog, password);
}
8000224a:	00 90       	ret 

8000224c <Ifx_Ssw_setCpuEndinit>:


void Ifx_Ssw_setCpuEndinit(Ifx_SCU_WDTCPU *watchdog, unsigned short password)
{
8000224c:	40 ae       	mov.aa %a14,%sp
    if (watchdog->CON0.B.LCK)
8000224e:	54 42       	ld.w %d2,[%a4]
80002250:	6f 12 0b 00 	jz.t %d2,1,80002266 <Ifx_Ssw_setCpuEndinit+0x1a>
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002254:	8f 24 00 30 	sh %d3,%d4,2
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002258:	54 42       	ld.w %d2,[%a4]
8000225a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000225e:	a6 32       	or %d2,%d3
80002260:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002264:	74 42       	st.w [%a4],%d2
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002266:	06 24       	sh %d4,2
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002268:	54 42       	ld.w %d2,[%a4]
8000226a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000226e:	a6 42       	or %d2,%d4
80002270:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002274:	74 42       	st.w [%a4],%d2
    watchdog->CON0.U;
80002276:	54 42       	ld.w %d2,[%a4]
    Ifx_Ssw_setCpuEndinitInline(watchdog, password);
}
80002278:	00 90       	ret 

8000227a <Ifx_Ssw_clearSafetyEndinit>:


void Ifx_Ssw_clearSafetyEndinit(unsigned short password)
{
8000227a:	40 ae       	mov.aa %a14,%sp
    if (SCU_WDTS_CON0.B.LCK)
8000227c:	91 30 00 2f 	movh.a %a2,61443
80002280:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80002284:	54 22       	ld.w %d2,[%a2]
80002286:	6f 12 0b 00 	jz.t %d2,1,8000229c <Ifx_Ssw_clearSafetyEndinit+0x22>
                          ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000228a:	8f 24 00 30 	sh %d3,%d4,2
                          ((unsigned int)SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000228e:	54 22       	ld.w %d2,[%a2]
80002290:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
80002294:	a6 32       	or %d2,%d3
80002296:	8f 12 40 21 	or %d2,%d2,1
        SCU_WDTS_CON0.U = ((unsigned int)1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000229a:	74 22       	st.w [%a2],%d2
                      ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000229c:	06 24       	sh %d4,2
                      ((unsigned int)SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000229e:	91 30 00 2f 	movh.a %a2,61443
800022a2:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800022a6:	54 22       	ld.w %d2,[%a2]
800022a8:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
800022ac:	a6 42       	or %d2,%d4
800022ae:	8f 22 40 21 	or %d2,%d2,2
    SCU_WDTS_CON0.U = ((unsigned int)0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800022b2:	74 22       	st.w [%a2],%d2
    SCU_WDTS_CON0.U;
800022b4:	54 22       	ld.w %d2,[%a2]
    Ifx_Ssw_clearSafetyEndinitInline(password);
}
800022b6:	00 90       	ret 

800022b8 <Ifx_Ssw_setSafetyEndinit>:


void Ifx_Ssw_setSafetyEndinit(unsigned short password)
{
800022b8:	40 ae       	mov.aa %a14,%sp
    if (SCU_WDTS_CON0.B.LCK)
800022ba:	91 30 00 2f 	movh.a %a2,61443
800022be:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800022c2:	54 22       	ld.w %d2,[%a2]
800022c4:	6f 12 0b 00 	jz.t %d2,1,800022da <Ifx_Ssw_setSafetyEndinit+0x22>
                          ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
800022c8:	8f 24 00 30 	sh %d3,%d4,2
                          ((unsigned int)SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800022cc:	54 22       	ld.w %d2,[%a2]
800022ce:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
800022d2:	a6 32       	or %d2,%d3
800022d4:	8f 12 40 21 	or %d2,%d2,1
        SCU_WDTS_CON0.U = ((unsigned int)1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800022d8:	74 22       	st.w [%a2],%d2
                      ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
800022da:	06 24       	sh %d4,2
                      ((unsigned int)SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800022dc:	91 30 00 2f 	movh.a %a2,61443
800022e0:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800022e4:	54 22       	ld.w %d2,[%a2]
800022e6:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
800022ea:	a6 42       	or %d2,%d4
800022ec:	8f 32 40 21 	or %d2,%d2,3
    SCU_WDTS_CON0.U = ((unsigned int)1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800022f0:	74 22       	st.w [%a2],%d2
    SCU_WDTS_CON0.U;
800022f2:	54 22       	ld.w %d2,[%a2]
    Ifx_Ssw_setSafetyEndinitInline(password);
}
800022f4:	00 90       	ret 

800022f6 <Ifx_Ssw_serviceCpuWatchdog>:


void Ifx_Ssw_serviceCpuWatchdog(Ifx_SCU_WDTCPU *watchdog, unsigned short password)
{
800022f6:	40 ae       	mov.aa %a14,%sp
    if (watchdog->CON0.B.LCK)
800022f8:	54 42       	ld.w %d2,[%a4]
800022fa:	6f 12 0b 00 	jz.t %d2,1,80002310 <Ifx_Ssw_serviceCpuWatchdog+0x1a>
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800022fe:	8f 24 00 30 	sh %d3,%d4,2
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002302:	54 42       	ld.w %d2,[%a4]
80002304:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002308:	a6 32       	or %d2,%d3
8000230a:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000230e:	74 42       	st.w [%a4],%d2
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002310:	06 24       	sh %d4,2
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002312:	54 42       	ld.w %d2,[%a4]
80002314:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002318:	a6 42       	or %d2,%d4
8000231a:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000231e:	74 42       	st.w [%a4],%d2
    watchdog->CON0.U;
80002320:	54 42       	ld.w %d2,[%a4]
    Ifx_Ssw_setCpuEndinitInline(watchdog, password);
}
80002322:	00 90       	ret 

80002324 <Ifx_Ssw_serviceSafetyWatchdog>:


void Ifx_Ssw_serviceSafetyWatchdog(unsigned short password)
{
80002324:	40 ae       	mov.aa %a14,%sp
    if (SCU_WDTS_CON0.B.LCK)
80002326:	91 30 00 2f 	movh.a %a2,61443
8000232a:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000232e:	54 22       	ld.w %d2,[%a2]
80002330:	6f 12 0b 00 	jz.t %d2,1,80002346 <Ifx_Ssw_serviceSafetyWatchdog+0x22>
                          ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
80002334:	8f 24 00 30 	sh %d3,%d4,2
                          ((unsigned int)SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80002338:	54 22       	ld.w %d2,[%a2]
8000233a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000233e:	a6 32       	or %d2,%d3
80002340:	8f 12 40 21 	or %d2,%d2,1
        SCU_WDTS_CON0.U = ((unsigned int)1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80002344:	74 22       	st.w [%a2],%d2
                      ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
80002346:	06 24       	sh %d4,2
                      ((unsigned int)SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80002348:	91 30 00 2f 	movh.a %a2,61443
8000234c:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80002350:	54 22       	ld.w %d2,[%a2]
80002352:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
80002356:	a6 42       	or %d2,%d4
80002358:	8f 32 40 21 	or %d2,%d2,3
    SCU_WDTS_CON0.U = ((unsigned int)1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000235c:	74 22       	st.w [%a2],%d2
    SCU_WDTS_CON0.U;
8000235e:	54 22       	ld.w %d2,[%a2]
    Ifx_Ssw_setSafetyEndinitInline(password);
}
80002360:	00 90       	ret 

80002362 <Ifx_Ssw_disableCpuWatchdog>:


void Ifx_Ssw_disableCpuWatchdog(Ifx_SCU_WDTCPU *watchdog, unsigned short password)
{
80002362:	40 ae       	mov.aa %a14,%sp
80002364:	37 04 70 80 	extr.u %d8,%d4,0,16
    /* Select CPU Watchdog based on Core Id */
    unsigned int    cpuIndex;
    cpuIndex = Ifx_Ssw_MFCR(CPU_CORE_ID);
80002368:	4d c0 e1 2f 	mfcr %d2,$core_id
    cpuIndex = (unsigned int)((unsigned int)cpuIndex >> IFX_CPU_CORE_ID_CORE_ID_OFF) & IFX_CPU_CORE_ID_CORE_ID_MSK;
8000236c:	8f 72 00 21 	and %d2,%d2,7
    __asm__ volatile ("min.u %0, %1, %2" : "=d" (res) : "d" (a), "d" (b));
80002370:	82 53       	mov %d3,5
80002372:	0b 32 90 21 	min.u %d2,%d2,%d3
    cpuIndex = Ifx_Ssw_MINU(cpuIndex, 5);
    Ifx_SCU_WDTCPU *wdt = &MODULE_SCU.WDTCPU[cpuIndex];
80002376:	7b 30 00 3f 	movh %d3,61443
8000237a:	1b c3 24 36 	addi %d3,%d3,25164
8000237e:	13 c2 20 23 	madd %d2,%d3,%d2,12
80002382:	60 2c       	mov.a %a12,%d2

    Ifx_Ssw_clearCpuEndinit(wdt, password);
80002384:	02 84       	mov %d4,%d8
80002386:	60 24       	mov.a %a4,%d2
80002388:	6d ff 4b ff 	call 8000221e <Ifx_Ssw_clearCpuEndinit>
    wdt->CON1.B.DR = 1U;         /* Set DR bit in Config_1 register */
8000238c:	d9 c2 04 00 	lea %a2,[%a12]4
80002390:	19 c2 04 00 	ld.w %d2,[%a12]4
80002394:	b7 12 81 21 	insert %d2,%d2,1,3,1
80002398:	74 22       	st.w [%a2],%d2
    Ifx_Ssw_setCpuEndinit(wdt, password);
8000239a:	02 84       	mov %d4,%d8
8000239c:	40 c4       	mov.aa %a4,%a12
8000239e:	6d ff 57 ff 	call 8000224c <Ifx_Ssw_setCpuEndinit>
}
800023a2:	00 90       	ret 

800023a4 <Ifx_Ssw_enableCpuWatchdog>:


void Ifx_Ssw_enableCpuWatchdog(Ifx_SCU_WDTCPU *watchdog, unsigned short password)
{
800023a4:	40 ae       	mov.aa %a14,%sp
800023a6:	37 04 70 80 	extr.u %d8,%d4,0,16
    /* Select CPU Watchdog based on Core Id */
    unsigned int    cpuIndex;
    cpuIndex = Ifx_Ssw_MFCR(CPU_CORE_ID);
800023aa:	4d c0 e1 2f 	mfcr %d2,$core_id
    cpuIndex = (unsigned int)((unsigned int)cpuIndex >> IFX_CPU_CORE_ID_CORE_ID_OFF) & IFX_CPU_CORE_ID_CORE_ID_MSK;
800023ae:	8f 72 00 21 	and %d2,%d2,7
800023b2:	82 53       	mov %d3,5
800023b4:	0b 32 90 21 	min.u %d2,%d2,%d3
    cpuIndex = Ifx_Ssw_MINU(cpuIndex, 5);
    Ifx_SCU_WDTCPU *wdt = &MODULE_SCU.WDTCPU[cpuIndex];
800023b8:	7b 30 00 3f 	movh %d3,61443
800023bc:	1b c3 24 36 	addi %d3,%d3,25164
800023c0:	13 c2 20 23 	madd %d2,%d3,%d2,12
800023c4:	60 2c       	mov.a %a12,%d2

    Ifx_Ssw_clearCpuEndinit(wdt, password);
800023c6:	02 84       	mov %d4,%d8
800023c8:	60 24       	mov.a %a4,%d2
800023ca:	6d ff 2a ff 	call 8000221e <Ifx_Ssw_clearCpuEndinit>
    wdt->CON1.B.DR = 0U;         /* Clear DR bit in Config_1 register */
800023ce:	d9 c2 04 00 	lea %a2,[%a12]4
800023d2:	19 c2 04 00 	ld.w %d2,[%a12]4
800023d6:	8f 82 c0 21 	andn %d2,%d2,8
800023da:	74 22       	st.w [%a2],%d2
    Ifx_Ssw_setCpuEndinit(wdt, password);
800023dc:	02 84       	mov %d4,%d8
800023de:	40 c4       	mov.aa %a4,%a12
800023e0:	6d ff 36 ff 	call 8000224c <Ifx_Ssw_setCpuEndinit>
}
800023e4:	00 90       	ret 

800023e6 <Ifx_Ssw_disableSafetyWatchdog>:


void Ifx_Ssw_disableSafetyWatchdog(unsigned short password)
{
800023e6:	40 ae       	mov.aa %a14,%sp
800023e8:	37 04 70 80 	extr.u %d8,%d4,0,16
    Ifx_Ssw_clearSafetyEndinit(password);
800023ec:	02 84       	mov %d4,%d8
800023ee:	6d ff 46 ff 	call 8000227a <Ifx_Ssw_clearSafetyEndinit>
    SCU_WDTS_CON1.B.DR = 1U;     /* Set DR bit in Config_1 register */
800023f2:	91 30 00 2f 	movh.a %a2,61443
800023f6:	d9 22 2c a6 	lea %a2,[%a2]25260 <f00362ac <bmhd_3_copy+0x40c34cac>>
800023fa:	54 22       	ld.w %d2,[%a2]
800023fc:	b7 12 81 21 	insert %d2,%d2,1,3,1
80002400:	74 22       	st.w [%a2],%d2
    Ifx_Ssw_setSafetyEndinit(password);
80002402:	02 84       	mov %d4,%d8
80002404:	6d ff 5a ff 	call 800022b8 <Ifx_Ssw_setSafetyEndinit>
}
80002408:	00 90       	ret 

8000240a <Ifx_Ssw_enableSafetyWatchdog>:


void Ifx_Ssw_enableSafetyWatchdog(unsigned short password)
{
8000240a:	40 ae       	mov.aa %a14,%sp
8000240c:	37 04 70 80 	extr.u %d8,%d4,0,16
    Ifx_Ssw_clearSafetyEndinit(password);
80002410:	02 84       	mov %d4,%d8
80002412:	6d ff 34 ff 	call 8000227a <Ifx_Ssw_clearSafetyEndinit>
    SCU_WDTS_CON1.B.DR = 0U;     /* Clear DR bit in Config_1 register */
80002416:	91 30 00 2f 	movh.a %a2,61443
8000241a:	d9 22 2c a6 	lea %a2,[%a2]25260 <f00362ac <bmhd_3_copy+0x40c34cac>>
8000241e:	54 22       	ld.w %d2,[%a2]
80002420:	8f 82 c0 21 	andn %d2,%d2,8
80002424:	74 22       	st.w [%a2],%d2
    Ifx_Ssw_setSafetyEndinit(password);
80002426:	02 84       	mov %d4,%d8
80002428:	6d ff 48 ff 	call 800022b8 <Ifx_Ssw_setSafetyEndinit>
}
8000242c:	00 90       	ret 

8000242e <Ifx_Ssw_startCore>:


void Ifx_Ssw_startCore(Ifx_CPU *cpu, unsigned int programCounter)
{
8000242e:	40 ae       	mov.aa %a14,%sp
    /* Set the PC */
    cpu->PC.B.PC = (unsigned int)programCounter >> 1U;
80002430:	7b 20 00 20 	movh %d2,2
80002434:	1b 82 e0 2f 	addi %d2,%d2,-504
80002438:	01 42 00 26 	addsc.a %a2,%a4,%d2,0
8000243c:	54 22       	ld.w %d2,[%a2]
8000243e:	37 24 01 20 	insert %d2,%d4,%d2,0,1
80002442:	74 22       	st.w [%a2],%d2

    /* release boot halt mode if required */
    Ifx_CPU_SYSCON syscon;
    syscon = cpu->SYSCON;
80002444:	7b 20 00 20 	movh %d2,2
80002448:	1b 42 e1 2f 	addi %d2,%d2,-492
8000244c:	01 42 00 26 	addsc.a %a2,%a4,%d2,0
80002450:	54 22       	ld.w %d2,[%a2]

    if (syscon.B.BHALT)
80002452:	ef 82 0b 00 	jz.t %d2,24,80002468 <Ifx_Ssw_startCore+0x3a>
    {
        syscon.B.BHALT = 0U;
80002456:	b7 02 01 2c 	insert %d2,%d2,0,24,1
        cpu->SYSCON    = syscon;
8000245a:	7b 20 00 40 	movh %d4,2
8000245e:	1b 44 e1 4f 	addi %d4,%d4,-492
80002462:	01 44 00 26 	addsc.a %a2,%a4,%d4,0
80002466:	74 22       	st.w [%a2],%d2
    }

}
80002468:	00 90       	ret 

8000246a <Ifx_Ssw_getStmFrequency>:
    Ifx_Ssw_setCpuEndinit(wdt, cpuWdtPw);
}


float Ifx_Ssw_getStmFrequency(void)
{
8000246a:	40 ae       	mov.aa %a14,%sp
    float        oscFreq    = IFX_CFG_SSW_XTAL_FREQUENCY;
    float        sourcefreq = IFX_CFG_SSW_EVR_OSC_FREQUENCY;
    unsigned int insel      = SCU_SYSPLLCON0.B.INSEL;
8000246c:	91 30 00 2f 	movh.a %a2,61443
80002470:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80002474:	54 22       	ld.w %d2,[%a2]
80002476:	8f 22 1e 20 	sh %d2,%d2,-30

    if (insel == 2U)
8000247a:	df 22 40 00 	jeq %d2,2,800024fa <Ifx_Ssw_getStmFrequency+0x90>
    {
        oscFreq = IFX_CFG_SSW_SYSCLK_PIN_FREQUENCY;
    }
    else if (insel == 1U)
8000247e:	df 12 38 00 	jeq %d2,1,800024ee <Ifx_Ssw_getStmFrequency+0x84>
    {
        oscFreq = IFX_CFG_SSW_XTAL_FREQUENCY;
    }
    else
    {
        oscFreq = IFX_CFG_SSW_EVR_OSC_FREQUENCY;
80002482:	7b f0 cb 34 	movh %d3,19647
80002486:	1b 03 c2 3b 	addi %d3,%d3,-17376
    }

    if (SCU_CCUCON0.B.CLKSEL != 0U)
8000248a:	91 30 00 2f 	movh.a %a2,61443
8000248e:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
80002492:	54 22       	ld.w %d2,[%a2]
80002494:	37 02 62 2e 	extr.u %d2,%d2,28,2
80002498:	df 02 37 00 	jeq %d2,0,80002506 <Ifx_Ssw_getStmFrequency+0x9c>
    {
        sourcefreq = (oscFreq * (SCU_SYSPLLCON0.B.NDIV + 1U)) /
8000249c:	91 30 00 2f 	movh.a %a2,61443
800024a0:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
800024a4:	54 22       	ld.w %d2,[%a2]
800024a6:	37 02 e7 24 	extr.u %d2,%d2,9,7
800024aa:	c2 12       	add %d2,1
800024ac:	4b 02 61 21 	utof %d2,%d2
800024b0:	4b 32 41 30 	mul.f %d3,%d2,%d3
                     ((SCU_SYSPLLCON0.B.PDIV + 1U) * (SCU_SYSPLLCON1.B.K2DIV + 1U));
800024b4:	54 24       	ld.w %d4,[%a2]
800024b6:	37 04 63 4c 	extr.u %d4,%d4,24,3
800024ba:	91 30 00 2f 	movh.a %a2,61443
800024be:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <bmhd_3_copy+0x40c34a1c>>
800024c2:	54 22       	ld.w %d2,[%a2]
800024c4:	8f 72 00 21 	and %d2,%d2,7
800024c8:	c2 12       	add %d2,1
800024ca:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
        sourcefreq = (oscFreq * (SCU_SYSPLLCON0.B.NDIV + 1U)) /
800024ce:	4b 02 61 21 	utof %d2,%d2
800024d2:	4b 23 51 40 	div.f %d4,%d3,%d2
    }

    return sourcefreq / SCU_CCUCON0.B.STMDIV;
800024d6:	91 30 00 2f 	movh.a %a2,61443
800024da:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
800024de:	54 22       	ld.w %d2,[%a2]
800024e0:	8f f2 00 21 	and %d2,%d2,15
800024e4:	4b 02 41 21 	itof %d2,%d2
}
800024e8:	4b 24 51 20 	div.f %d2,%d4,%d2
800024ec:	00 90       	ret 
        oscFreq = IFX_CFG_SSW_XTAL_FREQUENCY;
800024ee:	7b 90 b9 34 	movh %d3,19353
800024f2:	1b 03 68 39 	addi %d3,%d3,-27008
800024f6:	1d ff ca ff 	j 8000248a <Ifx_Ssw_getStmFrequency+0x20>
        oscFreq = IFX_CFG_SSW_SYSCLK_PIN_FREQUENCY;
800024fa:	7b 90 b9 34 	movh %d3,19353
800024fe:	1b 03 68 39 	addi %d3,%d3,-27008
80002502:	1d ff c4 ff 	j 8000248a <Ifx_Ssw_getStmFrequency+0x20>
    float        sourcefreq = IFX_CFG_SSW_EVR_OSC_FREQUENCY;
80002506:	7b f0 cb 44 	movh %d4,19647
8000250a:	1b 04 c2 4b 	addi %d4,%d4,-17376
8000250e:	1d ff e4 ff 	j 800024d6 <Ifx_Ssw_getStmFrequency+0x6c>

80002512 <Ifx_Ssw_doCppInit>:

void Ifx_Ssw_doCppInit(void)
{
80002512:	40 ae       	mov.aa %a14,%sp
80002514:	20 08       	sub.a %sp,8
{
    Ifx_Ssw_CTablePtr pBlockDest, pBlockSrc;
    unsigned int      uiLength, uiCnt;
    unsigned int     *pTable;
    /* clear table */
    pTable = (unsigned int *)&__clear_table;
80002516:	91 00 00 28 	movh.a %a2,32768
8000251a:	d9 22 58 50 	lea %a2,[%a2]1368 <80000558 <__clear_table>>

    while (pTable)
8000251e:	1d 00 32 00 	j 80002582 <Ifx_Ssw_doCppInit+0x70>
            break;
        }

        uiCnt = uiLength / 8;

        while (uiCnt--)
80002522:	91 00 00 28 	movh.a %a2,32768
80002526:	d9 22 78 70 	lea %a2,[%a2]1528 <800005f8 <__copy_table>>
8000252a:	1d 00 7c 00 	j 80002622 <Ifx_Ssw_doCppInit+0x110>
            *pBlockDest.ullPtr++ = 0;
8000252e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80002532:	80 22       	mov.d %d2,%a2
80002534:	1b 82 00 20 	addi %d2,%d2,8
80002538:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000253c:	d2 02       	mov %e2,0
8000253e:	89 22 40 09 	st.d [%a2],%e2
        while (uiCnt--)
80002542:	02 52       	mov %d2,%d5
80002544:	1b f2 ff 5f 	addi %d5,%d2,-1
80002548:	df 02 f3 ff 	jne %d2,0,8000252e <Ifx_Ssw_doCppInit+0x1c>
        if (uiLength & 0x4)
8000254c:	6f 24 0a 00 	jz.t %d4,2,80002560 <Ifx_Ssw_doCppInit+0x4e>
            *pBlockDest.uiPtr++ = 0;
80002550:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80002554:	80 22       	mov.d %d2,%a2
80002556:	c2 42       	add %d2,4
80002558:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000255c:	82 02       	mov %d2,0
8000255e:	74 22       	st.w [%a2],%d2
        if (uiLength & 0x2)
80002560:	6f 14 0a 00 	jz.t %d4,1,80002574 <Ifx_Ssw_doCppInit+0x62>
            *pBlockDest.usPtr++ = 0;
80002564:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80002568:	80 22       	mov.d %d2,%a2
8000256a:	c2 22       	add %d2,2
8000256c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80002570:	82 02       	mov %d2,0
80002572:	b4 22       	st.h [%a2],%d2
        if (uiLength & 0x1)
80002574:	6f 04 06 00 	jz.t %d4,0,80002580 <Ifx_Ssw_doCppInit+0x6e>
            *pBlockDest.ucPtr = 0;
80002578:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000257c:	82 02       	mov %d2,0
8000257e:	34 22       	st.b [%a2],%d2
        while (uiCnt--)
80002580:	40 32       	mov.aa %a2,%a3
    while (pTable)
80002582:	bd 02 d0 7f 	jz.a %a2,80002522 <Ifx_Ssw_doCppInit+0x10>
        pBlockDest.uiPtr = (unsigned int *)*pTable++;
80002586:	d9 23 08 00 	lea %a3,[%a2]8
8000258a:	54 22       	ld.w %d2,[%a2]
8000258c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        uiLength         = *pTable++;
80002590:	19 24 04 00 	ld.w %d4,[%a2]4
        if (uiLength == 0xFFFFFFFF)
80002594:	df f4 c7 7f 	jeq %d4,-1,80002522 <Ifx_Ssw_doCppInit+0x10>
        uiCnt = uiLength / 8;
80002598:	8f d4 1f 20 	sh %d2,%d4,-3
        while (uiCnt--)
8000259c:	1d ff d4 ff 	j 80002544 <Ifx_Ssw_doCppInit+0x32>
        {
            *pBlockDest.ullPtr++ = *pBlockSrc.ullPtr++;
800025a0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800025a4:	80 22       	mov.d %d2,%a2
800025a6:	1b 82 00 20 	addi %d2,%d2,8
800025aa:	59 e2 fc ff 	st.w [%a14]-4,%d2
800025ae:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
800025b2:	80 32       	mov.d %d2,%a3
800025b4:	1b 82 00 20 	addi %d2,%d2,8
800025b8:	59 e2 f8 ff 	st.w [%a14]-8,%d2
800025bc:	09 26 40 09 	ld.d %e6,[%a2]
800025c0:	89 36 40 09 	st.d [%a3],%e6
        while (uiCnt--)
800025c4:	02 42       	mov %d2,%d4
800025c6:	1b f2 ff 4f 	addi %d4,%d2,-1
800025ca:	df 02 eb ff 	jne %d2,0,800025a0 <Ifx_Ssw_doCppInit+0x8e>
        }

        if (uiLength & 0x4)
800025ce:	6f 23 10 00 	jz.t %d3,2,800025ee <Ifx_Ssw_doCppInit+0xdc>
        {
            *pBlockDest.uiPtr++ = *pBlockSrc.uiPtr++;
800025d2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800025d6:	80 22       	mov.d %d2,%a2
800025d8:	c2 42       	add %d2,4
800025da:	59 e2 fc ff 	st.w [%a14]-4,%d2
800025de:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
800025e2:	80 32       	mov.d %d2,%a3
800025e4:	c2 42       	add %d2,4
800025e6:	59 e2 f8 ff 	st.w [%a14]-8,%d2
800025ea:	54 22       	ld.w %d2,[%a2]
800025ec:	74 32       	st.w [%a3],%d2
        }

        if (uiLength & 0x2)
800025ee:	6f 13 11 00 	jz.t %d3,1,80002610 <Ifx_Ssw_doCppInit+0xfe>
        {
            *pBlockDest.usPtr++ = *pBlockSrc.usPtr++;
800025f2:	99 e3 fc ff 	ld.a %a3,[%a14]-4
800025f6:	80 32       	mov.d %d2,%a3
800025f8:	c2 22       	add %d2,2
800025fa:	59 e2 fc ff 	st.w [%a14]-4,%d2
800025fe:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80002602:	80 22       	mov.d %d2,%a2
80002604:	c2 22       	add %d2,2
80002606:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000260a:	b9 32 00 00 	ld.hu %d2,[%a3]0
8000260e:	b4 22       	st.h [%a2],%d2
        }

        if (uiLength & 0x1)
80002610:	6f 03 08 00 	jz.t %d3,0,80002620 <Ifx_Ssw_doCppInit+0x10e>
        {
            *pBlockDest.ucPtr = *pBlockSrc.ucPtr;
80002614:	99 e3 fc ff 	ld.a %a3,[%a14]-4
80002618:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000261c:	14 32       	ld.bu %d2,[%a3]
8000261e:	34 22       	st.b [%a2],%d2
        while (uiCnt--)
80002620:	60 52       	mov.a %a2,%d5
    while (pTable)
80002622:	bd 02 14 00 	jz.a %a2,8000264a <Ifx_Ssw_doCppInit+0x138>
        pBlockSrc.uiPtr  = (unsigned int *)*pTable++;
80002626:	54 22       	ld.w %d2,[%a2]
80002628:	59 e2 fc ff 	st.w [%a14]-4,%d2
        pBlockDest.uiPtr = (unsigned int *)*pTable++;
8000262c:	19 22 04 00 	ld.w %d2,[%a2]4
80002630:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        uiLength         = *pTable++;
80002634:	80 22       	mov.d %d2,%a2
80002636:	1b c2 00 50 	addi %d5,%d2,12
8000263a:	19 23 08 00 	ld.w %d3,[%a2]8
        if (uiLength == 0xFFFFFFFF)
8000263e:	df f3 06 00 	jeq %d3,-1,8000264a <Ifx_Ssw_doCppInit+0x138>
        uiCnt = uiLength / 8;
80002642:	8f d3 1f 20 	sh %d2,%d3,-3
        while (uiCnt--)
80002646:	1d ff c0 ff 	j 800025c6 <Ifx_Ssw_doCppInit+0xb4>
	#elif defined(__HIGHTEC__) && !defined(__clang__)
		extern void _init(void); /* cpp initialization */
		_init();
	#elif defined(__GNUC__) && !defined(__HIGHTEC__)
		extern void _init(void); /* cpp initialization */
		_init();
8000264a:	6d ff 57 f2 	call 80000af8 <_init>
	#elif defined(__ghs__)
		extern void _main(void); /* cpp initialization */
		_main();
	#endif
}
8000264e:	00 90       	ret 

80002650 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
80002650:	40 ae       	mov.aa %a14,%sp
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
80002652:	91 00 00 47 	movh.a %a4,28672
80002656:	d9 43 20 00 	lea %a3,[%a4]32 <70000020 <ucHeap>>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
8000265a:	91 00 00 27 	movh.a %a2,28672
8000265e:	d9 25 18 00 	lea %a5,[%a2]24 <70000018 <xStart>>
80002662:	b5 23 18 00 	st.a [%a2]24 <70000018 <xStart>>,%a3
	xStart.xBlockSize = ( size_t ) 0;
80002666:	82 02       	mov %d2,0
80002668:	59 52 04 00 	st.w [%a5]4,%d2

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
8000266c:	bb 80 ff 3f 	mov.u %d3,65528
80002670:	80 34       	mov.d %d4,%a3
80002672:	42 43       	add %d3,%d4
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
80002674:	8f 33 c0 31 	andn %d3,%d3,3
80002678:	60 32       	mov.a %a2,%d3
	pxEnd = ( void * ) uxAddress;
8000267a:	91 00 00 57 	movh.a %a5,28672
8000267e:	59 53 14 00 	st.w [%a5]20 <70000014 <pxEnd>>,%d3
	pxEnd->xBlockSize = 0;
80002682:	59 22 04 00 	st.w [%a2]4 <70000014 <pxEnd>>,%d2
	pxEnd->pxNextFreeBlock = NULL;
80002686:	74 22       	st.w [%a2],%d2

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
80002688:	01 32 20 50 	sub.a %a5,%a2,%a3
8000268c:	b5 35 04 00 	st.a [%a3]4,%a5
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
80002690:	59 43 20 00 	st.w [%a4]32 <70000020 <ucHeap>>,%d3

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
80002694:	91 00 00 27 	movh.a %a2,28672
80002698:	b5 25 0c 00 	st.a [%a2]12 <7000000c <xMinimumEverFreeBytesRemaining>>,%a5
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
8000269c:	91 00 00 27 	movh.a %a2,28672
800026a0:	b5 25 10 00 	st.a [%a2]16 <70000010 <xFreeBytesRemaining>>,%a5

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
800026a4:	91 00 00 27 	movh.a %a2,28672
800026a8:	7b 00 00 28 	movh %d2,32768
800026ac:	59 22 08 00 	st.w [%a2]8 <70000008 <xBlockAllocatedBit>>,%d2
}
800026b0:	00 90       	ret 

800026b2 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
800026b2:	40 ae       	mov.aa %a14,%sp
800026b4:	80 42       	mov.d %d2,%a4
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
800026b6:	91 00 00 27 	movh.a %a2,28672
800026ba:	d9 22 18 00 	lea %a2,[%a2]24 <70000018 <xStart>>
800026be:	40 23       	mov.aa %a3,%a2
800026c0:	d4 22       	ld.a %a2,[%a2]
800026c2:	80 23       	mov.d %d3,%a2
800026c4:	3f 23 fd ff 	jlt.u %d3,%d2,800026be <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
800026c8:	19 34 04 00 	ld.w %d4,[%a3]4 <f0030004 <bmhd_3_copy+0x40c2ea04>>
800026cc:	80 33       	mov.d %d3,%a3
800026ce:	42 43       	add %d3,%d4
800026d0:	5f 23 10 00 	jeq %d3,%d2,800026f0 <prvInsertBlockIntoFreeList+0x3e>
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
800026d4:	60 24       	mov.a %a4,%d2
800026d6:	19 44 04 00 	ld.w %d4,[%a4]4
800026da:	0b 42 00 30 	add %d3,%d2,%d4
800026de:	80 25       	mov.d %d5,%a2
800026e0:	5f 35 11 00 	jeq %d5,%d3,80002702 <prvInsertBlockIntoFreeList+0x50>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
800026e4:	f4 42       	st.a [%a4],%a2

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
800026e6:	80 33       	mov.d %d3,%a3
800026e8:	5f 32 03 00 	jeq %d2,%d3,800026ee <prvInsertBlockIntoFreeList+0x3c>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
800026ec:	74 32       	st.w [%a3],%d2
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
800026ee:	00 90       	ret 
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
800026f0:	60 24       	mov.a %a4,%d2
800026f2:	19 42 04 00 	ld.w %d2,[%a4]4
800026f6:	42 42       	add %d2,%d4
800026f8:	59 32 04 00 	st.w [%a3]4,%d2
		pxBlockToInsert = pxIterator;
800026fc:	80 32       	mov.d %d2,%a3
800026fe:	1d ff eb ff 	j 800026d4 <prvInsertBlockIntoFreeList+0x22>
		if( pxIterator->pxNextFreeBlock != pxEnd )
80002702:	91 00 00 47 	movh.a %a4,28672
80002706:	19 43 14 00 	ld.w %d3,[%a4]20 <70000014 <pxEnd>>
8000270a:	5f 35 0e 00 	jeq %d5,%d3,80002726 <prvInsertBlockIntoFreeList+0x74>
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
8000270e:	19 23 04 00 	ld.w %d3,[%a2]4
80002712:	42 43       	add %d3,%d4
80002714:	60 22       	mov.a %a2,%d2
80002716:	59 23 04 00 	st.w [%a2]4,%d3
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
8000271a:	d4 32       	ld.a %a2,[%a3]
8000271c:	60 24       	mov.a %a4,%d2
8000271e:	54 23       	ld.w %d3,[%a2]
80002720:	74 43       	st.w [%a4],%d3
80002722:	1d ff e2 ff 	j 800026e6 <prvInsertBlockIntoFreeList+0x34>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
80002726:	60 22       	mov.a %a2,%d2
80002728:	74 23       	st.w [%a2],%d3
8000272a:	1d ff de ff 	j 800026e6 <prvInsertBlockIntoFreeList+0x34>

8000272e <pvPortMalloc>:
{
8000272e:	40 ae       	mov.aa %a14,%sp
80002730:	02 48       	mov %d8,%d4
	vTaskSuspendAll();
80002732:	6d 00 1a 08 	call 80003766 <vTaskSuspendAll>
		if( pxEnd == NULL )
80002736:	91 00 00 27 	movh.a %a2,28672
8000273a:	19 22 14 00 	ld.w %d2,[%a2]20 <70000014 <pxEnd>>
8000273e:	df 02 24 00 	jeq %d2,0,80002786 <pvPortMalloc+0x58>
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
80002742:	91 00 00 27 	movh.a %a2,28672
80002746:	19 22 08 00 	ld.w %d2,[%a2]8 <70000008 <xBlockAllocatedBit>>
8000274a:	26 82       	and %d2,%d8
8000274c:	df 02 7a 80 	jne %d2,0,80002840 <pvPortMalloc+0x112>
			if( xWantedSize > 0 )
80002750:	df 08 0b 00 	jeq %d8,0,80002766 <pvPortMalloc+0x38>
				xWantedSize += xHeapStructSize;
80002754:	1b 88 00 80 	addi %d8,%d8,8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
80002758:	8f 38 00 21 	and %d2,%d8,3
8000275c:	df 02 05 00 	jeq %d2,0,80002766 <pvPortMalloc+0x38>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
80002760:	8f 38 c0 81 	andn %d8,%d8,3
80002764:	c2 48       	add %d8,4
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
80002766:	df 08 70 00 	jeq %d8,0,80002846 <pvPortMalloc+0x118>
8000276a:	91 00 00 27 	movh.a %a2,28672
8000276e:	19 22 10 00 	ld.w %d2,[%a2]16 <70000010 <xFreeBytesRemaining>>
80002772:	3f 82 82 80 	jlt.u %d2,%d8,80002876 <pvPortMalloc+0x148>
				pxBlock = xStart.pxNextFreeBlock;
80002776:	91 00 00 27 	movh.a %a2,28672
8000277a:	99 2c 18 00 	ld.a %a12,[%a2]24 <70000018 <xStart>>
				pxPreviousBlock = &xStart;
8000277e:	d9 22 18 00 	lea %a2,[%a2]24 <70000018 <xStart>>
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
80002782:	1d 00 08 00 	j 80002792 <pvPortMalloc+0x64>
			prvHeapInit();
80002786:	6d ff 65 ff 	call 80002650 <prvHeapInit>
8000278a:	1d ff dc ff 	j 80002742 <pvPortMalloc+0x14>
					pxPreviousBlock = pxBlock;
8000278e:	40 c2       	mov.aa %a2,%a12
					pxBlock = pxBlock->pxNextFreeBlock;
80002790:	60 2c       	mov.a %a12,%d2
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
80002792:	19 c2 04 00 	ld.w %d2,[%a12]4
80002796:	7f 82 05 80 	jge.u %d2,%d8,800027a0 <pvPortMalloc+0x72>
8000279a:	54 c2       	ld.w %d2,[%a12]
8000279c:	df 02 f9 ff 	jne %d2,0,8000278e <pvPortMalloc+0x60>
				if( pxBlock != pxEnd )
800027a0:	91 00 00 37 	movh.a %a3,28672
800027a4:	19 32 14 00 	ld.w %d2,[%a3]20 <70000014 <pxEnd>>
800027a8:	80 c3       	mov.d %d3,%a12
800027aa:	5f 32 69 00 	jeq %d2,%d3,8000287c <pvPortMalloc+0x14e>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
800027ae:	54 22       	ld.w %d2,[%a2]
800027b0:	1b 82 00 90 	addi %d9,%d2,8
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
800027b4:	54 c2       	ld.w %d2,[%a12]
800027b6:	74 22       	st.w [%a2],%d2
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
800027b8:	19 c2 04 00 	ld.w %d2,[%a12]4
800027bc:	0b 82 80 30 	sub %d3,%d2,%d8
800027c0:	8b 13 61 22 	lt.u %d2,%d3,17
800027c4:	df 02 21 80 	jne %d2,0,80002806 <pvPortMalloc+0xd8>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
800027c8:	80 c2       	mov.d %d2,%a12
800027ca:	42 82       	add %d2,%d8
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
800027cc:	8f 32 00 41 	and %d4,%d2,3
800027d0:	df 04 13 00 	jeq %d4,0,800027f6 <pvPortMalloc+0xc8>
 **********************************************************************/

static __inline__ __attribute__((__always_inline__))
void _disable (void)
{
  __asm__ volatile ("disable" ::: "memory");
800027d4:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
800027d8:	4d c0 e2 2f 	mfcr %d2,$icr
800027dc:	8f f2 cf 21 	andn %d2,%d2,255
800027e0:	8f 02 44 21 	or %d2,%d2,64
800027e4:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
800027e8:	0d 00 c0 04 	isync 
800027ec:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
800027f0:	00 a0       	debug 
800027f2:	1d 00 00 00 	j 800027f2 <pvPortMalloc+0xc4>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
800027f6:	60 22       	mov.a %a2,%d2
800027f8:	59 23 04 00 	st.w [%a2]4,%d3
						pxBlock->xBlockSize = xWantedSize;
800027fc:	59 c8 04 00 	st.w [%a12]4,%d8
						prvInsertBlockIntoFreeList( pxNewBlockLink );
80002800:	60 24       	mov.a %a4,%d2
80002802:	6d ff 58 ff 	call 800026b2 <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
80002806:	19 c3 04 00 	ld.w %d3,[%a12]4
8000280a:	91 00 00 27 	movh.a %a2,28672
8000280e:	d9 23 10 00 	lea %a3,[%a2]16 <70000010 <xFreeBytesRemaining>>
80002812:	54 32       	ld.w %d2,[%a3]
80002814:	a2 32       	sub %d2,%d3
80002816:	59 22 10 00 	st.w [%a2]16 <70000010 <xFreeBytesRemaining>>,%d2
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
8000281a:	91 00 00 27 	movh.a %a2,28672
8000281e:	19 24 0c 00 	ld.w %d4,[%a2]12 <7000000c <xMinimumEverFreeBytesRemaining>>
80002822:	7f 42 04 80 	jge.u %d2,%d4,8000282a <pvPortMalloc+0xfc>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
80002826:	59 22 0c 00 	st.w [%a2]12 <7000000c <xMinimumEverFreeBytesRemaining>>,%d2
					pxBlock->xBlockSize |= xBlockAllocatedBit;
8000282a:	91 00 00 27 	movh.a %a2,28672
8000282e:	19 22 08 00 	ld.w %d2,[%a2]8 <70000008 <xBlockAllocatedBit>>
80002832:	a6 32       	or %d2,%d3
80002834:	59 c2 04 00 	st.w [%a12]4,%d2
					pxBlock->pxNextFreeBlock = NULL;
80002838:	82 02       	mov %d2,0
8000283a:	74 c2       	st.w [%a12],%d2
8000283c:	1d 00 06 00 	j 80002848 <pvPortMalloc+0x11a>
void *pvReturn = NULL;
80002840:	82 09       	mov %d9,0
80002842:	1d 00 03 00 	j 80002848 <pvPortMalloc+0x11a>
80002846:	82 09       	mov %d9,0
	( void ) xTaskResumeAll();
80002848:	6d 00 94 0b 	call 80003f70 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
8000284c:	8f 39 00 21 	and %d2,%d9,3
80002850:	df 02 19 00 	jeq %d2,0,80002882 <pvPortMalloc+0x154>
  __asm__ volatile ("disable" ::: "memory");
80002854:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80002858:	4d c0 e2 2f 	mfcr %d2,$icr
8000285c:	8f f2 cf 21 	andn %d2,%d2,255
80002860:	8f 02 44 21 	or %d2,%d2,64
80002864:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
80002868:	0d 00 c0 04 	isync 
8000286c:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80002870:	00 a0       	debug 
80002872:	1d 00 00 00 	j 80002872 <pvPortMalloc+0x144>
void *pvReturn = NULL;
80002876:	82 09       	mov %d9,0
80002878:	1d ff e8 ff 	j 80002848 <pvPortMalloc+0x11a>
8000287c:	82 09       	mov %d9,0
8000287e:	1d ff e5 ff 	j 80002848 <pvPortMalloc+0x11a>
}
80002882:	60 92       	mov.a %a2,%d9
80002884:	00 90       	ret 

80002886 <vPortFree>:
{
80002886:	40 ae       	mov.aa %a14,%sp
80002888:	40 4c       	mov.aa %a12,%a4
	if( pv != NULL )
8000288a:	bd 04 4a 00 	jz.a %a4,8000291e <vPortFree+0x98>
		puc -= xHeapStructSize;
8000288e:	80 42       	mov.d %d2,%a4
80002890:	1b 82 ff 8f 	addi %d8,%d2,-8
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
80002894:	19 44 fc ff 	ld.w %d4,[%a4]-4
80002898:	91 00 00 27 	movh.a %a2,28672
8000289c:	19 22 08 00 	ld.w %d2,[%a2]8 <70000008 <xBlockAllocatedBit>>
800028a0:	0f 24 80 30 	and %d3,%d4,%d2
800028a4:	df 03 13 80 	jne %d3,0,800028ca <vPortFree+0x44>
  __asm__ volatile ("disable" ::: "memory");
800028a8:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
800028ac:	4d c0 e2 2f 	mfcr %d2,$icr
800028b0:	8f f2 cf 21 	andn %d2,%d2,255
800028b4:	8f 02 44 21 	or %d2,%d2,64
800028b8:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
800028bc:	0d 00 c0 04 	isync 
800028c0:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
800028c4:	00 a0       	debug 
800028c6:	1d 00 00 00 	j 800028c6 <vPortFree+0x40>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
800028ca:	19 43 f8 ff 	ld.w %d3,[%a4]-8
800028ce:	df 03 13 00 	jeq %d3,0,800028f4 <vPortFree+0x6e>
  __asm__ volatile ("disable" ::: "memory");
800028d2:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
800028d6:	4d c0 e2 2f 	mfcr %d2,$icr
800028da:	8f f2 cf 21 	andn %d2,%d2,255
800028de:	8f 02 44 21 	or %d2,%d2,64
800028e2:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
800028e6:	0d 00 c0 04 	isync 
800028ea:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
800028ee:	00 a0       	debug 
800028f0:	1d 00 00 00 	j 800028f0 <vPortFree+0x6a>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
800028f4:	0f 24 e0 20 	andn %d2,%d4,%d2
800028f8:	59 42 fc ff 	st.w [%a4]-4,%d2
				vTaskSuspendAll();
800028fc:	6d 00 35 07 	call 80003766 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
80002900:	19 c2 fc ff 	ld.w %d2,[%a12]-4
80002904:	91 00 00 27 	movh.a %a2,28672
80002908:	d9 23 10 00 	lea %a3,[%a2]16 <70000010 <xFreeBytesRemaining>>
8000290c:	54 33       	ld.w %d3,[%a3]
8000290e:	42 32       	add %d2,%d3
80002910:	59 22 10 00 	st.w [%a2]16 <70000010 <xFreeBytesRemaining>>,%d2
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
80002914:	60 84       	mov.a %a4,%d8
80002916:	6d ff ce fe 	call 800026b2 <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
8000291a:	6d 00 2b 0b 	call 80003f70 <xTaskResumeAll>
}
8000291e:	00 90       	ret 

80002920 <prvSetupTimerInterrupt>:
	/* Will not get here. */
	return 0;
}
/*-----------------------------------------------------------*/
static void prvSetupTimerInterrupt( void )
{
80002920:	40 ae       	mov.aa %a14,%sp
80002922:	20 20       	sub.a %sp,32
    IfxStm_CompareConfig stmCompareConfig;                                  /* STM Configuration declaration                */
    IfxStm_initCompareConfig(&stmCompareConfig);                            /* Initialize a default configuration for STM   */
80002924:	d9 e4 e4 ff 	lea %a4,[%a14]-28
80002928:	6d ff 51 f2 	call 80000dca <IfxStm_initCompareConfig>

    stmCompareConfig.triggerPriority     = configKERNEL_INTERRUPT_PRIORITY;            /* Priority of the interrupt generated by STM   */
8000292c:	82 22       	mov %d2,2
8000292e:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
    stmCompareConfig.comparatorInterrupt = IfxStm_ComparatorInterrupt_ir0;  /* Select the request source 0                  */
80002932:	82 02       	mov %d2,0
80002934:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    stmCompareConfig.ticks               = configTICK_RATE_HZ;   /* First interrupt shall occur after 10 ms      */
80002938:	3b 80 3e 30 	mov %d3,1000
8000293c:	59 e3 f4 ff 	st.w [%a14]-12,%d3
    stmCompareConfig.typeOfService       = IfxSrc_Tos_cpu0;                 /* CPU0 serves the interrupts                   */
80002940:	59 e2 fc ff 	st.w [%a14]-4,%d2

    IfxStm_initCompare(&MODULE_STM0, &stmCompareConfig);                    /* Initialize the Compare functionality         */
80002944:	d9 e5 e4 ff 	lea %a5,[%a14]-28
80002948:	c5 f4 00 01 	lea %a4,f0001000 <bmhd_3_copy+0x40bffa00>
8000294c:	6d ff 96 f1 	call 80000c78 <IfxStm_initCompare>
}
80002950:	00 90       	ret 

80002952 <prvInterruptYield>:
{
    prvInterruptYield();
}

__attribute__((noinline)) static void prvInterruptYield(void)
{
80002952:	40 ae       	mov.aa %a14,%sp
//	pxCurrentTCB->pxTopOfStack into PCXI (effectively changing the call stack).
//	In the Interrupt handler post-amble, RSLCX will restore the lower context
//	of the task. RFE will restore the upper context of the task, jump to the
//	return address and restore the previous state of interrupts being
//	enabled/disabled. */
	__disable();
80002954:	0d 00 40 03 	disable 
    __asm__ volatile ("dsync" : : : "memory");
80002958:	0d 00 80 04 	dsync 
	__dsync();
	xUpperCSA = __mfcr( CPU_PCXI );
8000295c:	4d 00 e0 2f 	mfcr %d2,$pcxi
	pxUpperCSA = portCSA_TO_ADDRESS( xUpperCSA );
80002960:	8f c2 00 30 	sh %d3,%d2,12
80002964:	b7 03 1c 30 	insert %d3,%d3,0,0,28
80002968:	06 62       	sh %d2,6
8000296a:	7b 00 04 40 	movh %d4,64
8000296e:	1b 04 fc 4f 	addi %d4,%d4,-64
80002972:	26 42       	and %d2,%d4
80002974:	a6 32       	or %d2,%d3
80002976:	60 2c       	mov.a %a12,%d2
	*pxCurrentTCB = pxUpperCSA[ 0 ];
80002978:	91 10 00 d7 	movh.a %a13,28673
8000297c:	99 d2 34 40 	ld.a %a2,[%a13]308 <70010134 <pxCurrentTCB>>
80002980:	54 c2       	ld.w %d2,[%a12]
80002982:	74 22       	st.w [%a2],%d2
	vTaskSwitchContext();
80002984:	6d 00 be 07 	call 80003900 <vTaskSwitchContext>
	pxUpperCSA[ 0 ] = *pxCurrentTCB;
80002988:	99 dd 34 40 	ld.a %a13,[%a13]308 <70010134 <pxCurrentTCB>>
8000298c:	54 d2       	ld.w %d2,[%a13]
8000298e:	74 c2       	st.w [%a12],%d2
	GPSR[CPU_ID]->B.SETR = 0;
80002990:	4d c0 e1 2f 	mfcr %d2,$core_id
80002994:	8f f2 00 21 	and %d2,%d2,15
80002998:	06 22       	sh %d2,2
8000299a:	91 00 00 28 	movh.a %a2,32768
8000299e:	d9 22 48 50 	lea %a2,[%a2]1352 <80000548 <GPSR>>
800029a2:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800029a6:	d4 22       	ld.a %a2,[%a2]
800029a8:	54 22       	ld.w %d2,[%a2]
800029aa:	b7 02 01 2d 	insert %d2,%d2,0,26,1
800029ae:	74 22       	st.w [%a2],%d2
    __asm__ volatile ("isync" : : : "memory");
800029b0:	0d 00 c0 04 	isync 
	__isync();
}
800029b4:	00 90       	ret 

800029b6 <pxPortInitialiseStack>:
{
800029b6:	40 ae       	mov.aa %a14,%sp
800029b8:	80 4a       	mov.d %d10,%a4
800029ba:	80 58       	mov.d %d8,%a5
800029bc:	80 69       	mov.d %d9,%a6
	portENTER_CRITICAL();
800029be:	6d 00 a1 09 	call 80003d00 <vTaskEnterCritical>
    __asm__ volatile ("dsync" : : : "memory");
800029c2:	0d 00 80 04 	dsync 
		pulLowerCSA = portCSA_TO_ADDRESS( __mfcr(CPU_FCX) );
800029c6:	4d 80 e3 2f 	mfcr %d2,$fcx
800029ca:	8f c2 00 20 	sh %d2,%d2,12
800029ce:	b7 02 1c 30 	insert %d3,%d2,0,0,28
800029d2:	4d 80 e3 2f 	mfcr %d2,$fcx
800029d6:	06 62       	sh %d2,6
800029d8:	7b 00 04 40 	movh %d4,64
800029dc:	1b 04 fc 4f 	addi %d4,%d4,-64
800029e0:	26 42       	and %d2,%d4
800029e2:	a6 32       	or %d2,%d3
800029e4:	60 2c       	mov.a %a12,%d2
		if( NULL != pulLowerCSA )
800029e6:	bd 0c 57 00 	jz.a %a12,80002a94 <pxPortInitialiseStack+0xde>
			pulUpperCSA = portCSA_TO_ADDRESS( pulLowerCSA[ 0 ] );
800029ea:	54 c4       	ld.w %d4,[%a12]
800029ec:	8f c4 00 30 	sh %d3,%d4,12
800029f0:	b7 03 1c 30 	insert %d3,%d3,0,0,28
800029f4:	8f 64 00 20 	sh %d2,%d4,6
800029f8:	7b 00 04 40 	movh %d4,64
800029fc:	1b 04 fc 4f 	addi %d4,%d4,-64
80002a00:	26 42       	and %d2,%d4
80002a02:	a6 32       	or %d2,%d3
80002a04:	60 2d       	mov.a %a13,%d2
		if( ( NULL != pulLowerCSA ) && ( NULL != pulUpperCSA ) )
80002a06:	01 0c 90 34 	nez.a %d3,%a12
80002a0a:	01 0d 90 24 	nez.a %d2,%a13
80002a0e:	26 32       	and %d2,%d3
80002a10:	df 02 45 00 	jeq %d2,0,80002a9a <pxPortInitialiseStack+0xe4>
			__disable();
80002a14:	0d 00 40 03 	disable 
80002a18:	0d 00 80 04 	dsync 
			__mtcr( CPU_FCX, pulUpperCSA[ 0 ] );
80002a1c:	54 d2       	ld.w %d2,[%a13]
80002a1e:	cd 82 e3 0f 	mtcr $fcx,%d2
    __asm__ volatile ("isync" : : : "memory");
80002a22:	0d 00 c0 04 	isync 
			__enable();
80002a26:	0d 00 00 03 	enable 
	portEXIT_CRITICAL();
80002a2a:	6d 00 8d 09 	call 80003d44 <vTaskExitCritical>
	memset( pulUpperCSA, 0, portNUM_WORDS_IN_CSA * sizeof( uint32_t ) );
80002a2e:	40 d3       	mov.aa %a3,%a13
80002a30:	82 02       	mov %d2,0
80002a32:	c5 02 3f 00 	lea %a2,3f <__TRICORE_DERIVATE_MEMORY_MAP__-0x341>
80002a36:	24 32       	st.b [%a3+],%d2
80002a38:	fd 20 ff 7f 	loop %a2,80002a36 <pxPortInitialiseStack+0x80>
	pulUpperCSA[ 2 ] = ( uint32_t )pxTopOfStack;		/* A10;	Stack Return aka Stack Pointer */
80002a3c:	59 da 08 00 	st.w [%a13]8,%d10
	pulUpperCSA[ 1 ] = portSYSTEM_PROGRAM_STATUS_WORD;		/* PSW	*/
80002a40:	3b f0 8f 20 	mov %d2,2303
80002a44:	59 d2 04 00 	st.w [%a13]4,%d2
	memset( pulLowerCSA, 0, portNUM_WORDS_IN_CSA * sizeof( uint32_t ) );
80002a48:	40 c3       	mov.aa %a3,%a12
80002a4a:	82 02       	mov %d2,0
80002a4c:	c5 02 3f 00 	lea %a2,3f <__TRICORE_DERIVATE_MEMORY_MAP__-0x341>
80002a50:	24 32       	st.b [%a3+],%d2
80002a52:	fd 20 ff 7f 	loop %a2,80002a50 <pxPortInitialiseStack+0x9a>
	pulLowerCSA[ 8 ] = ( uint32_t ) pvParameters;		/* A4;	Address Type Parameter Register	*/
80002a56:	59 c9 20 00 	st.w [%a12]32,%d9
	pulLowerCSA[ 1 ] = ( uint32_t ) pxCode;			/* A11;	Return Address aka RA */
80002a5a:	59 c8 04 00 	st.w [%a12]4,%d8
	pulLowerCSA[ 0 ] = ( portINITIAL_PCXI_UPPER_CONTEXT_WORD | ( uint32_t ) portADDRESS_TO_CSA( pulUpperCSA ) );
80002a5e:	80 d2       	mov.d %d2,%a13
80002a60:	8f 42 1f 50 	sh %d5,%d2,-12
80002a64:	7b f0 00 30 	movh %d3,15
80002a68:	26 35       	and %d5,%d3
80002a6a:	8f a2 1f 40 	sh %d4,%d2,-6
80002a6e:	bb f0 ff 2f 	mov.u %d2,65535
80002a72:	26 24       	and %d4,%d2
80002a74:	a6 54       	or %d4,%d5
80002a76:	b7 f4 02 4a 	insert %d4,%d4,15,20,2
80002a7a:	74 c4       	st.w [%a12],%d4
	pxTopOfStack = (uint32_t * ) portADDRESS_TO_CSA( pulLowerCSA );
80002a7c:	80 c4       	mov.d %d4,%a12
80002a7e:	8f 44 1f 40 	sh %d4,%d4,-12
80002a82:	26 43       	and %d3,%d4
80002a84:	80 c4       	mov.d %d4,%a12
80002a86:	06 a4       	sh %d4,-6
80002a88:	26 42       	and %d2,%d4
80002a8a:	a6 32       	or %d2,%d3
80002a8c:	60 22       	mov.a %a2,%d2
    __asm__ volatile ("dsync" : : : "memory");
80002a8e:	0d 00 80 04 	dsync 
}
80002a92:	00 90       	ret 
uint32_t *pulUpperCSA = NULL;
80002a94:	a0 0d       	mov.a %a13,0
80002a96:	1d ff b8 ff 	j 80002a06 <pxPortInitialiseStack+0x50>
    __asm__ volatile ("svlcx" : : : "memory");
80002a9a:	0d 00 00 02 	svlcx 
}
80002a9e:	1d ff c6 ff 	j 80002a2a <pxPortInitialiseStack+0x74>

80002aa2 <xPortStartScheduler>:
{
80002aa2:	40 ae       	mov.aa %a14,%sp
	prvSetupTimerInterrupt();
80002aa4:	6d ff 3e ff 	call 80002920 <prvSetupTimerInterrupt>
	IfxSrc_init(GPSR[CPU_ID], (IfxSrc_Tos)CPU_ID, configKERNEL_YIELD_PRIORITY);
80002aa8:	4d c0 e1 2f 	mfcr %d2,$core_id
80002aac:	8f f2 00 21 	and %d2,%d2,15
80002ab0:	91 00 00 38 	movh.a %a3,32768
80002ab4:	d9 33 48 50 	lea %a3,[%a3]1352 <80000548 <GPSR>>
80002ab8:	06 22       	sh %d2,2
80002aba:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
80002abe:	d4 22       	ld.a %a2,[%a2]
80002ac0:	4d c0 e1 3f 	mfcr %d3,$core_id
    src->B.SRPN = priority;
80002ac4:	54 22       	ld.w %d2,[%a2]
80002ac6:	b7 12 08 20 	insert %d2,%d2,1,0,8
80002aca:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80002acc:	54 22       	ld.w %d2,[%a2]
80002ace:	37 32 83 25 	insert %d2,%d2,%d3,11,3
80002ad2:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
80002ad4:	54 22       	ld.w %d2,[%a2]
80002ad6:	b7 12 81 2c 	insert %d2,%d2,1,25,1
80002ada:	74 22       	st.w [%a2],%d2
	IfxSrc_enable(GPSR[CPU_ID]);
80002adc:	4d c0 e1 2f 	mfcr %d2,$core_id
80002ae0:	8f f2 00 21 	and %d2,%d2,15
80002ae4:	06 22       	sh %d2,2
80002ae6:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
80002aea:	d4 32       	ld.a %a2,[%a3]
    src->B.SRE = 1;
80002aec:	54 22       	ld.w %d2,[%a2]
80002aee:	b7 12 01 25 	insert %d2,%d2,1,10,1
80002af2:	74 22       	st.w [%a2],%d2
	__disable();
80002af4:	0d 00 40 03 	disable 
	__mtcr( CPU_SYSCON, portINITIAL_SYSCON );
80002af8:	82 02       	mov %d2,0
80002afa:	cd 42 e1 0f 	mtcr $syscon,%d2
    __asm__ volatile ("isync" : : : "memory");
80002afe:	0d 00 c0 04 	isync 
	ulMFCR = __mfcr(CPU_PSW);
80002b02:	4d 40 e0 2f 	mfcr %d2,$psw
	ulMFCR &= portRESTORE_PSW_MASK;
80002b06:	8f f2 cf 21 	andn %d2,%d2,255
    __asm__ volatile ("dsync" : : : "memory");
80002b0a:	0d 00 80 04 	dsync 
	__mtcr(CPU_PSW, ulMFCR);
80002b0e:	cd 42 e0 0f 	mtcr $psw,%d2
    __asm__ volatile ("isync" : : : "memory");
80002b12:	0d 00 c0 04 	isync 
	pulLowerCSA = portCSA_TO_ADDRESS((*pxCurrentTCB));
80002b16:	91 10 00 27 	movh.a %a2,28673
80002b1a:	99 23 34 40 	ld.a %a3,[%a2]308 <70010134 <pxCurrentTCB>>
80002b1e:	54 32       	ld.w %d2,[%a3]
80002b20:	54 32       	ld.w %d2,[%a3]
    __asm__ volatile ("dsync" : : : "memory");
80002b22:	0d 00 80 04 	dsync 
	__mtcr(CPU_PCXI, *pxCurrentTCB);
80002b26:	99 22 34 40 	ld.a %a2,[%a2]308 <70010134 <pxCurrentTCB>>
80002b2a:	54 22       	ld.w %d2,[%a2]
80002b2c:	cd 02 e0 0f 	mtcr $pcxi,%d2
    __asm__ volatile ("isync" : : : "memory");
80002b30:	0d 00 c0 04 	isync 
    __asm__ volatile ("nop" : : : "memory");
80002b34:	00 00       	nop 
    __asm__ volatile ("rslcx" : : : "memory");
80002b36:	0d 00 40 02 	rslcx 
    __asm__ volatile ("nop" : : : "memory");
80002b3a:	00 00       	nop 
	__asm volatile("rfe");
80002b3c:	00 80       	rfe 
}
80002b3e:	82 02       	mov %d2,0
80002b40:	00 90       	ret 

80002b42 <vPortReclaimCSA>:
{
80002b42:	40 ae       	mov.aa %a14,%sp
	pxHeadCSA = ( *pxTCB ) & portCSA_FCX_MASK;
80002b44:	54 42       	ld.w %d2,[%a4]
80002b46:	b7 02 0c 6a 	insert %d6,%d2,0,20,12
	pulNextCSA = portCSA_TO_ADDRESS( pxTailCSA );
80002b4a:	8f c2 00 20 	sh %d2,%d2,12
80002b4e:	b7 02 1c 30 	insert %d3,%d2,0,0,28
80002b52:	8f 66 00 20 	sh %d2,%d6,6
80002b56:	7b 00 04 40 	movh %d4,64
80002b5a:	1b 04 fc 4f 	addi %d4,%d4,-64
80002b5e:	26 42       	and %d2,%d4
80002b60:	a6 32       	or %d2,%d3
80002b62:	60 22       	mov.a %a2,%d2
	pxTailCSA = pxHeadCSA;
80002b64:	02 63       	mov %d3,%d6
	while( 0UL != ( pulNextCSA[ 0 ] & portCSA_FCX_MASK ) )
80002b66:	1d 00 11 00 	j 80002b88 <vPortReclaimCSA+0x46>
		pulNextCSA[ 0 ] = pulNextCSA[ 0 ] & portCSA_FCX_MASK;
80002b6a:	74 22       	st.w [%a2],%d2
		pulNextCSA = portCSA_TO_ADDRESS( pxTailCSA );
80002b6c:	8f c2 00 40 	sh %d4,%d2,12
80002b70:	b7 04 1c 40 	insert %d4,%d4,0,0,28
80002b74:	8f 62 00 30 	sh %d3,%d2,6
80002b78:	7b 00 04 50 	movh %d5,64
80002b7c:	1b 05 fc 5f 	addi %d5,%d5,-64
80002b80:	26 53       	and %d3,%d5
80002b82:	a6 43       	or %d3,%d4
80002b84:	60 32       	mov.a %a2,%d3
		pxTailCSA = pulNextCSA[ 0 ];
80002b86:	02 23       	mov %d3,%d2
	while( 0UL != ( pulNextCSA[ 0 ] & portCSA_FCX_MASK ) )
80002b88:	54 22       	ld.w %d2,[%a2]
80002b8a:	b7 02 0c 2a 	insert %d2,%d2,0,20,12
80002b8e:	df 02 ee ff 	jne %d2,0,80002b6a <vPortReclaimCSA+0x28>
	__disable();
80002b92:	0d 00 40 03 	disable 
    __asm__ volatile ("dsync" : : : "memory");
80002b96:	0d 00 80 04 	dsync 
		pxFreeCSA = __mfcr( CPU_FCX );
80002b9a:	4d 80 e3 5f 	mfcr %d5,$fcx
		portCSA_TO_ADDRESS( pxTailCSA )[ 0 ] = pxFreeCSA;
80002b9e:	8f c3 00 40 	sh %d4,%d3,12
80002ba2:	b7 04 1c 40 	insert %d4,%d4,0,0,28
80002ba6:	8f 63 00 20 	sh %d2,%d3,6
80002baa:	7b 00 04 30 	movh %d3,64
80002bae:	1b 03 fc 3f 	addi %d3,%d3,-64
80002bb2:	26 32       	and %d2,%d3
80002bb4:	a6 42       	or %d2,%d4
80002bb6:	60 22       	mov.a %a2,%d2
80002bb8:	74 25       	st.w [%a2],%d5
80002bba:	0d 00 80 04 	dsync 
		__mtcr( CPU_FCX, pxHeadCSA );
80002bbe:	cd 86 e3 0f 	mtcr $fcx,%d6
    __asm__ volatile ("isync" : : : "memory");
80002bc2:	0d 00 c0 04 	isync 
	__enable();
80002bc6:	0d 00 00 03 	enable 
}
80002bca:	00 90       	ret 

80002bcc <KERNEL_YIELD>:
{
80002bcc:	40 ae       	mov.aa %a14,%sp
    prvInterruptYield();
80002bce:	6d ff c2 fe 	call 80002952 <prvInterruptYield>
}
80002bd2:	0d 00 40 02 	rslcx 
80002bd6:	00 80       	rfe 

80002bd8 <uxPortSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t uxPortSetInterruptMaskFromISR( void )
{
80002bd8:	40 ae       	mov.aa %a14,%sp
uint32_t uxReturn = 0UL;

	__disable();
80002bda:	0d 00 40 03 	disable 
	uxReturn = __mfcr( CPU_ICR );
80002bde:	4d c0 e2 2f 	mfcr %d2,$icr
	__mtcr( CPU_ICR, ( ( uxReturn & ~portCCPN_MASK ) | configMAX_SYSCALL_INTERRUPT_PRIORITY ) );
80002be2:	8f f2 cf 31 	andn %d3,%d2,255
80002be6:	8f 03 44 31 	or %d3,%d3,64
80002bea:	cd c3 e2 0f 	mtcr $icr,%d3
80002bee:	0d 00 c0 04 	isync 
	__isync();
	__enable();
80002bf2:	0d 00 00 03 	enable 

	/* Return just the interrupt mask bits. */
	return ( uxReturn & portCCPN_MASK );
}
80002bf6:	8f f2 0f 21 	and %d2,%d2,255
80002bfa:	00 90       	ret 

80002bfc <prvSystemTickHandler>:
{
80002bfc:	40 ae       	mov.aa %a14,%sp
	ulSavedInterruptMask = portSET_INTERRUPT_MASK_FROM_ISR();
80002bfe:	6d ff ed ff 	call 80002bd8 <uxPortSetInterruptMaskFromISR>
80002c02:	02 28       	mov %d8,%d2
		lYieldRequired = xTaskIncrementTick();
80002c04:	6d 00 c0 05 	call 80003784 <xTaskIncrementTick>
  __asm__ volatile ("disable" ::: "memory");
80002c08:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80002c0c:	4d c0 e2 3f 	mfcr %d3,$icr
	portCLEAR_INTERRUPT_MASK_FROM_ISR(ulSavedInterruptMask);
80002c10:	8f f3 cf 31 	andn %d3,%d3,255
80002c14:	a6 83       	or %d3,%d8
80002c16:	cd c3 e2 0f 	mtcr $icr,%d3
80002c1a:	0d 00 c0 04 	isync 
80002c1e:	0d 00 00 03 	enable 
	if (lYieldRequired != pdFALSE)
80002c22:	df 02 03 80 	jne %d2,0,80002c28 <prvSystemTickHandler+0x2c>
}
80002c26:	00 90       	ret 
		__disable();
80002c28:	0d 00 40 03 	disable 
    __asm__ volatile ("dsync" : : : "memory");
80002c2c:	0d 00 80 04 	dsync 
		xUpperCSA = __mfcr(CPU_PCXI);
80002c30:	4d 00 e0 2f 	mfcr %d2,$pcxi
		pxUpperCSA = portCSA_TO_ADDRESS(xUpperCSA);
80002c34:	8f c2 00 30 	sh %d3,%d2,12
80002c38:	b7 03 1c 30 	insert %d3,%d3,0,0,28
80002c3c:	06 62       	sh %d2,6
80002c3e:	7b 00 04 40 	movh %d4,64
80002c42:	1b 04 fc 4f 	addi %d4,%d4,-64
80002c46:	26 42       	and %d2,%d4
80002c48:	a6 32       	or %d2,%d3
80002c4a:	60 2c       	mov.a %a12,%d2
		*pxCurrentTCB = pxUpperCSA[0];
80002c4c:	91 10 00 d7 	movh.a %a13,28673
80002c50:	99 d2 34 40 	ld.a %a2,[%a13]308 <70010134 <pxCurrentTCB>>
80002c54:	54 c2       	ld.w %d2,[%a12]
80002c56:	74 22       	st.w [%a2],%d2
		vTaskSwitchContext();
80002c58:	6d 00 54 06 	call 80003900 <vTaskSwitchContext>
		pxUpperCSA[0] = *pxCurrentTCB;
80002c5c:	99 dd 34 40 	ld.a %a13,[%a13]308 <70010134 <pxCurrentTCB>>
80002c60:	54 d2       	ld.w %d2,[%a13]
80002c62:	74 c2       	st.w [%a12],%d2
		GPSR[CPU_ID]->B.SETR = 0;
80002c64:	4d c0 e1 2f 	mfcr %d2,$core_id
80002c68:	8f f2 00 21 	and %d2,%d2,15
80002c6c:	06 22       	sh %d2,2
80002c6e:	91 00 00 28 	movh.a %a2,32768
80002c72:	d9 22 48 50 	lea %a2,[%a2]1352 <80000548 <GPSR>>
80002c76:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80002c7a:	d4 22       	ld.a %a2,[%a2]
80002c7c:	54 22       	ld.w %d2,[%a2]
80002c7e:	b7 02 01 2d 	insert %d2,%d2,0,26,1
80002c82:	74 22       	st.w [%a2],%d2
    __asm__ volatile ("isync" : : : "memory");
80002c84:	0d 00 c0 04 	isync 
}
80002c88:	1d ff cf ff 	j 80002c26 <prvSystemTickHandler+0x2a>

80002c8c <KERNEL_INTERRUPT>:
{
80002c8c:	40 ae       	mov.aa %a14,%sp
}


IFX_INLINE void IfxStm_increaseCompare(Ifx_STM *stm, IfxStm_Comparator comparator, uint32 ticks)
{
    stm->CMP[comparator].B.CMPVAL = stm->CMP[comparator].B.CMPVAL + ticks;
80002c8e:	c5 f2 00 01 	lea %a2,f0001000 <bmhd_3_copy+0x40bffa00>
80002c92:	d9 23 30 00 	lea %a3,[%a2]48
80002c96:	19 22 30 00 	ld.w %d2,[%a2]48
80002c9a:	1b 82 3e 20 	addi %d2,%d2,1000
80002c9e:	74 32       	st.w [%a3],%d2
	prvSystemTickHandler();
80002ca0:	6d ff ae ff 	call 80002bfc <prvSystemTickHandler>
}
80002ca4:	0d 00 40 02 	rslcx 
80002ca8:	00 80       	rfe 

80002caa <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
80002caa:	40 ae       	mov.aa %a14,%sp
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80002cac:	80 42       	mov.d %d2,%a4
80002cae:	1b 82 00 20 	addi %d2,%d2,8
80002cb2:	59 42 04 00 	st.w [%a4]4,%d2

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80002cb6:	82 f3       	mov %d3,-1
80002cb8:	60 22       	mov.a %a2,%d2
80002cba:	74 23       	st.w [%a2],%d3

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80002cbc:	59 42 0c 00 	st.w [%a4]12,%d2
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80002cc0:	59 42 10 00 	st.w [%a4]16,%d2

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
80002cc4:	82 02       	mov %d2,0
80002cc6:	74 42       	st.w [%a4],%d2

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
80002cc8:	00 90       	ret 

80002cca <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
80002cca:	40 ae       	mov.aa %a14,%sp
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80002ccc:	82 02       	mov %d2,0
80002cce:	59 42 10 00 	st.w [%a4]16,%d2

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
80002cd2:	00 90       	ret 

80002cd4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
80002cd4:	40 ae       	mov.aa %a14,%sp
ListItem_t * const pxIndex = pxList->pxIndex;
80002cd6:	99 42 04 00 	ld.a %a2,[%a4]4
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
80002cda:	b5 52 04 00 	st.a [%a5]4,%a2
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
80002cde:	99 23 08 00 	ld.a %a3,[%a2]8
80002ce2:	b5 53 08 00 	st.a [%a5]8,%a3

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
80002ce6:	b5 35 04 00 	st.a [%a3]4,%a5
	pxIndex->pxPrevious = pxNewListItem;
80002cea:	b5 25 08 00 	st.a [%a2]8,%a5

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80002cee:	b5 54 10 00 	st.a [%a5]16,%a4

	( pxList->uxNumberOfItems )++;
80002cf2:	54 42       	ld.w %d2,[%a4]
80002cf4:	c2 12       	add %d2,1
80002cf6:	74 42       	st.w [%a4],%d2
}
80002cf8:	00 90       	ret 

80002cfa <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
80002cfa:	40 ae       	mov.aa %a14,%sp
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
80002cfc:	54 52       	ld.w %d2,[%a5]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80002cfe:	df f2 1a 00 	jeq %d2,-1,80002d32 <vListInsert+0x38>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80002d02:	d9 42 08 00 	lea %a2,[%a4]8
80002d06:	40 23       	mov.aa %a3,%a2
80002d08:	b0 42       	add.a %a2,4
80002d0a:	d4 22       	ld.a %a2,[%a2]
80002d0c:	54 23       	ld.w %d3,[%a2]
80002d0e:	7f 32 fc ff 	jge.u %d2,%d3,80002d06 <vListInsert+0xc>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80002d12:	99 32 04 00 	ld.a %a2,[%a3]4
80002d16:	b5 52 04 00 	st.a [%a5]4,%a2
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
80002d1a:	b5 25 08 00 	st.a [%a2]8,%a5
	pxNewListItem->pxPrevious = pxIterator;
80002d1e:	b5 53 08 00 	st.a [%a5]8,%a3
	pxIterator->pxNext = pxNewListItem;
80002d22:	b5 35 04 00 	st.a [%a3]4,%a5

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80002d26:	b5 54 10 00 	st.a [%a5]16,%a4

	( pxList->uxNumberOfItems )++;
80002d2a:	54 42       	ld.w %d2,[%a4]
80002d2c:	c2 12       	add %d2,1
80002d2e:	74 42       	st.w [%a4],%d2
}
80002d30:	00 90       	ret 
		pxIterator = pxList->xListEnd.pxPrevious;
80002d32:	99 43 10 00 	ld.a %a3,[%a4]16
80002d36:	1d ff ee ff 	j 80002d12 <vListInsert+0x18>

80002d3a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
80002d3a:	40 ae       	mov.aa %a14,%sp
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
80002d3c:	99 42 10 00 	ld.a %a2,[%a4]16

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80002d40:	99 45 04 00 	ld.a %a5,[%a4]4
80002d44:	99 43 08 00 	ld.a %a3,[%a4]8
80002d48:	b5 53 08 00 	st.a [%a5]8,%a3
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80002d4c:	19 42 04 00 	ld.w %d2,[%a4]4
80002d50:	59 32 04 00 	st.w [%a3]4,%d2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80002d54:	d9 23 04 00 	lea %a3,[%a2]4
80002d58:	19 22 04 00 	ld.w %d2,[%a2]4
80002d5c:	80 43       	mov.d %d3,%a4
80002d5e:	5f 32 09 00 	jeq %d2,%d3,80002d70 <uxListRemove+0x36>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
80002d62:	82 02       	mov %d2,0
80002d64:	59 42 10 00 	st.w [%a4]16,%d2
	( pxList->uxNumberOfItems )--;
80002d68:	54 22       	ld.w %d2,[%a2]
80002d6a:	c2 f2       	add %d2,-1
80002d6c:	74 22       	st.w [%a2],%d2

	return pxList->uxNumberOfItems;
}
80002d6e:	00 90       	ret 
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80002d70:	19 42 08 00 	ld.w %d2,[%a4]8
80002d74:	74 32       	st.w [%a3],%d2
80002d76:	1d ff f6 ff 	j 80002d62 <uxListRemove+0x28>

80002d7a <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
80002d7a:	40 ae       	mov.aa %a14,%sp
80002d7c:	40 4c       	mov.aa %a12,%a4
BaseType_t xReturn;

	taskENTER_CRITICAL();
80002d7e:	6d 00 c1 07 	call 80003d00 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
80002d82:	19 c3 38 00 	ld.w %d3,[%a12]56
80002d86:	19 c2 3c 00 	ld.w %d2,[%a12]60
80002d8a:	5f 23 07 00 	jeq %d3,%d2,80002d98 <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
		}
		else
		{
			xReturn = pdFALSE;
80002d8e:	82 08       	mov %d8,0
		}
	}
	taskEXIT_CRITICAL();
80002d90:	6d 00 da 07 	call 80003d44 <vTaskExitCritical>

	return xReturn;
}
80002d94:	02 82       	mov %d2,%d8
80002d96:	00 90       	ret 
			xReturn = pdTRUE;
80002d98:	82 18       	mov %d8,1
80002d9a:	1d ff fb ff 	j 80002d90 <prvIsQueueFull+0x16>

80002d9e <prvIsQueueEmpty>:
{
80002d9e:	40 ae       	mov.aa %a14,%sp
80002da0:	40 4c       	mov.aa %a12,%a4
	taskENTER_CRITICAL();
80002da2:	6d 00 af 07 	call 80003d00 <vTaskEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
80002da6:	19 c2 38 00 	ld.w %d2,[%a12]56
80002daa:	df 02 07 80 	jne %d2,0,80002db8 <prvIsQueueEmpty+0x1a>
			xReturn = pdTRUE;
80002dae:	82 18       	mov %d8,1
	taskEXIT_CRITICAL();
80002db0:	6d 00 ca 07 	call 80003d44 <vTaskExitCritical>
}
80002db4:	02 82       	mov %d2,%d8
80002db6:	00 90       	ret 
			xReturn = pdFALSE;
80002db8:	82 08       	mov %d8,0
80002dba:	1d ff fb ff 	j 80002db0 <prvIsQueueEmpty+0x12>

80002dbe <prvCopyDataToQueue>:
{
80002dbe:	40 ae       	mov.aa %a14,%sp
80002dc0:	40 4c       	mov.aa %a12,%a4
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
80002dc2:	19 48 38 00 	ld.w %d8,[%a4]56
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
80002dc6:	99 42 00 10 	ld.a %a2,[%a4]64
80002dca:	bd 02 14 80 	jnz.a %a2,80002df2 <prvCopyDataToQueue+0x34>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80002dce:	54 42       	ld.w %d2,[%a4]
80002dd0:	df 02 08 00 	jeq %d2,0,80002de0 <prvCopyDataToQueue+0x22>
BaseType_t xReturn = pdFALSE;
80002dd4:	82 02       	mov %d2,0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
80002dd6:	1b 18 00 30 	addi %d3,%d8,1
80002dda:	59 c3 38 00 	st.w [%a12]56,%d3
}
80002dde:	00 90       	ret 
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80002de0:	99 44 04 00 	ld.a %a4,[%a4]4
80002de4:	6d 00 29 07 	call 80003c36 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
80002de8:	82 03       	mov %d3,0
80002dea:	59 c3 04 00 	st.w [%a12]4,%d3
80002dee:	1d ff f4 ff 	j 80002dd6 <prvCopyDataToQueue+0x18>
	else if( xPosition == queueSEND_TO_BACK )
80002df2:	df 04 1a 80 	jne %d4,0,80002e26 <prvCopyDataToQueue+0x68>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
80002df6:	d9 43 08 00 	lea %a3,[%a4]8
80002dfa:	99 44 08 00 	ld.a %a4,[%a4]8
80002dfe:	1d 00 04 00 	j 80002e06 <prvCopyDataToQueue+0x48>
80002e02:	04 52       	ld.bu %d2,[%a5+]
80002e04:	24 42       	st.b [%a4+],%d2
80002e06:	fd 20 fe 7f 	loop %a2,80002e02 <prvCopyDataToQueue+0x44>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80002e0a:	54 32       	ld.w %d2,[%a3]
80002e0c:	19 c3 00 10 	ld.w %d3,[%a12]64
80002e10:	42 32       	add %d2,%d3
80002e12:	74 32       	st.w [%a3],%d2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80002e14:	19 c3 04 00 	ld.w %d3,[%a12]4
80002e18:	3f 32 2b 80 	jlt.u %d2,%d3,80002e6e <prvCopyDataToQueue+0xb0>
			pxQueue->pcWriteTo = pxQueue->pcHead;
80002e1c:	54 c2       	ld.w %d2,[%a12]
80002e1e:	74 32       	st.w [%a3],%d2
BaseType_t xReturn = pdFALSE;
80002e20:	02 42       	mov %d2,%d4
80002e22:	1d ff da ff 	j 80002dd6 <prvCopyDataToQueue+0x18>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80002e26:	d9 43 0c 00 	lea %a3,[%a4]12
80002e2a:	99 44 0c 00 	ld.a %a4,[%a4]12
80002e2e:	1d 00 04 00 	j 80002e36 <prvCopyDataToQueue+0x78>
80002e32:	04 52       	ld.bu %d2,[%a5+]
80002e34:	24 42       	st.b [%a4+],%d2
80002e36:	fd 20 fe 7f 	loop %a2,80002e32 <prvCopyDataToQueue+0x74>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
80002e3a:	19 c2 00 10 	ld.w %d2,[%a12]64
80002e3e:	8b 02 00 31 	rsub %d3,%d2,0
80002e42:	54 35       	ld.w %d5,[%a3]
80002e44:	0b 25 80 20 	sub %d2,%d5,%d2
80002e48:	74 32       	st.w [%a3],%d2
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80002e4a:	54 c5       	ld.w %d5,[%a12]
80002e4c:	7f 52 06 80 	jge.u %d2,%d5,80002e58 <prvCopyDataToQueue+0x9a>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80002e50:	19 c2 04 00 	ld.w %d2,[%a12]4
80002e54:	42 32       	add %d2,%d3
80002e56:	74 32       	st.w [%a3],%d2
		if( xPosition == queueOVERWRITE )
80002e58:	df 24 05 00 	jeq %d4,2,80002e62 <prvCopyDataToQueue+0xa4>
BaseType_t xReturn = pdFALSE;
80002e5c:	82 02       	mov %d2,0
80002e5e:	1d ff bc ff 	j 80002dd6 <prvCopyDataToQueue+0x18>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
80002e62:	df 08 09 00 	jeq %d8,0,80002e74 <prvCopyDataToQueue+0xb6>
				--uxMessagesWaiting;
80002e66:	c2 f8       	add %d8,-1
BaseType_t xReturn = pdFALSE;
80002e68:	82 02       	mov %d2,0
80002e6a:	1d ff b6 ff 	j 80002dd6 <prvCopyDataToQueue+0x18>
80002e6e:	02 42       	mov %d2,%d4
80002e70:	1d ff b3 ff 	j 80002dd6 <prvCopyDataToQueue+0x18>
80002e74:	82 02       	mov %d2,0
80002e76:	1d ff b0 ff 	j 80002dd6 <prvCopyDataToQueue+0x18>

80002e7a <prvCopyDataFromQueue>:
{
80002e7a:	40 ae       	mov.aa %a14,%sp
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
80002e7c:	99 42 00 10 	ld.a %a2,[%a4]64
80002e80:	bd 02 18 00 	jz.a %a2,80002eb0 <prvCopyDataFromQueue+0x36>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
80002e84:	d9 43 0c 00 	lea %a3,[%a4]12
80002e88:	19 42 0c 00 	ld.w %d2,[%a4]12
80002e8c:	80 23       	mov.d %d3,%a2
80002e8e:	42 32       	add %d2,%d3
80002e90:	74 32       	st.w [%a3],%d2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
80002e92:	19 43 04 00 	ld.w %d3,[%a4]4
80002e96:	3f 32 05 80 	jlt.u %d2,%d3,80002ea0 <prvCopyDataFromQueue+0x26>
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
80002e9a:	54 42       	ld.w %d2,[%a4]
80002e9c:	59 42 0c 00 	st.w [%a4]12,%d2
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
80002ea0:	99 44 0c 00 	ld.a %a4,[%a4]12
80002ea4:	1d 00 04 00 	j 80002eac <prvCopyDataFromQueue+0x32>
80002ea8:	04 42       	ld.bu %d2,[%a4+]
80002eaa:	24 52       	st.b [%a5+],%d2
80002eac:	fd 20 fe 7f 	loop %a2,80002ea8 <prvCopyDataFromQueue+0x2e>
}
80002eb0:	00 90       	ret 

80002eb2 <prvUnlockQueue>:
{
80002eb2:	40 ae       	mov.aa %a14,%sp
80002eb4:	40 4c       	mov.aa %a12,%a4
	taskENTER_CRITICAL();
80002eb6:	6d 00 25 07 	call 80003d00 <vTaskEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
80002eba:	79 c8 05 10 	ld.b %d8,[%a12]69
		while( cTxLock > queueLOCKED_UNMODIFIED )
80002ebe:	1d 00 05 00 	j 80002ec8 <prvUnlockQueue+0x16>
			--cTxLock;
80002ec2:	c2 f8       	add %d8,-1
80002ec4:	37 08 48 80 	extr %d8,%d8,0,8
		while( cTxLock > queueLOCKED_UNMODIFIED )
80002ec8:	bf 18 11 00 	jlt %d8,1,80002eea <prvUnlockQueue+0x38>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002ecc:	d9 c2 24 00 	lea %a2,[%a12]36
80002ed0:	19 c2 24 00 	ld.w %d2,[%a12]36
80002ed4:	df 02 0b 00 	jeq %d2,0,80002eea <prvUnlockQueue+0x38>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002ed8:	40 24       	mov.aa %a4,%a2
80002eda:	6d 00 c4 05 	call 80003a62 <xTaskRemoveFromEventList>
80002ede:	df 02 f2 7f 	jeq %d2,0,80002ec2 <prvUnlockQueue+0x10>
						vTaskMissedYield();
80002ee2:	6d 00 3a 06 	call 80003b56 <vTaskMissedYield>
80002ee6:	1d ff ee ff 	j 80002ec2 <prvUnlockQueue+0x10>
		pxQueue->cTxLock = queueUNLOCKED;
80002eea:	82 f2       	mov %d2,-1
80002eec:	e9 c2 05 10 	st.b [%a12]69,%d2
	taskEXIT_CRITICAL();
80002ef0:	6d 00 2a 07 	call 80003d44 <vTaskExitCritical>
	taskENTER_CRITICAL();
80002ef4:	6d 00 06 07 	call 80003d00 <vTaskEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
80002ef8:	79 c8 04 10 	ld.b %d8,[%a12]68
		while( cRxLock > queueLOCKED_UNMODIFIED )
80002efc:	1d 00 05 00 	j 80002f06 <prvUnlockQueue+0x54>
				--cRxLock;
80002f00:	c2 f8       	add %d8,-1
80002f02:	37 08 48 80 	extr %d8,%d8,0,8
		while( cRxLock > queueLOCKED_UNMODIFIED )
80002f06:	bf 18 11 00 	jlt %d8,1,80002f28 <prvUnlockQueue+0x76>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002f0a:	d9 c2 10 00 	lea %a2,[%a12]16
80002f0e:	19 c2 10 00 	ld.w %d2,[%a12]16
80002f12:	df 02 0b 00 	jeq %d2,0,80002f28 <prvUnlockQueue+0x76>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80002f16:	40 24       	mov.aa %a4,%a2
80002f18:	6d 00 a5 05 	call 80003a62 <xTaskRemoveFromEventList>
80002f1c:	df 02 f2 7f 	jeq %d2,0,80002f00 <prvUnlockQueue+0x4e>
					vTaskMissedYield();
80002f20:	6d 00 1b 06 	call 80003b56 <vTaskMissedYield>
80002f24:	1d ff ee ff 	j 80002f00 <prvUnlockQueue+0x4e>
		pxQueue->cRxLock = queueUNLOCKED;
80002f28:	82 f2       	mov %d2,-1
80002f2a:	e9 c2 04 10 	st.b [%a12]68,%d2
	taskEXIT_CRITICAL();
80002f2e:	6d 00 0b 07 	call 80003d44 <vTaskExitCritical>
}
80002f32:	00 90       	ret 

80002f34 <xQueueGenericReset>:
{
80002f34:	40 ae       	mov.aa %a14,%sp
80002f36:	40 4c       	mov.aa %a12,%a4
80002f38:	02 48       	mov %d8,%d4
	configASSERT( pxQueue );
80002f3a:	bd 04 28 00 	jz.a %a4,80002f8a <xQueueGenericReset+0x56>
	taskENTER_CRITICAL();
80002f3e:	6d 00 e1 06 	call 80003d00 <vTaskEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80002f42:	54 c2       	ld.w %d2,[%a12]
80002f44:	19 c5 3c 00 	ld.w %d5,[%a12]60
80002f48:	19 c4 00 10 	ld.w %d4,[%a12]64
80002f4c:	03 45 0a 32 	madd %d3,%d2,%d5,%d4
80002f50:	59 c3 04 00 	st.w [%a12]4,%d3
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
80002f54:	82 03       	mov %d3,0
80002f56:	59 c3 38 00 	st.w [%a12]56,%d3
		pxQueue->pcWriteTo = pxQueue->pcHead;
80002f5a:	59 c2 08 00 	st.w [%a12]8,%d2
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
80002f5e:	c2 f5       	add %d5,-1
80002f60:	03 54 0a 22 	madd %d2,%d2,%d4,%d5
80002f64:	59 c2 0c 00 	st.w [%a12]12,%d2
		pxQueue->cRxLock = queueUNLOCKED;
80002f68:	82 f2       	mov %d2,-1
80002f6a:	e9 c2 04 10 	st.b [%a12]68,%d2
		pxQueue->cTxLock = queueUNLOCKED;
80002f6e:	e9 c2 05 10 	st.b [%a12]69,%d2
		if( xNewQueue == pdFALSE )
80002f72:	df 08 26 80 	jne %d8,0,80002fbe <xQueueGenericReset+0x8a>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002f76:	d9 c2 10 00 	lea %a2,[%a12]16
80002f7a:	19 c2 10 00 	ld.w %d2,[%a12]16
80002f7e:	df 02 17 80 	jne %d2,0,80002fac <xQueueGenericReset+0x78>
	taskEXIT_CRITICAL();
80002f82:	6d 00 e1 06 	call 80003d44 <vTaskExitCritical>
}
80002f86:	82 12       	mov %d2,1
80002f88:	00 90       	ret 
  __asm__ volatile ("disable" ::: "memory");
80002f8a:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80002f8e:	4d c0 e2 2f 	mfcr %d2,$icr
	configASSERT( pxQueue );
80002f92:	8f f2 cf 21 	andn %d2,%d2,255
80002f96:	8f 02 44 21 	or %d2,%d2,64
80002f9a:	cd c2 e2 0f 	mtcr $icr,%d2
80002f9e:	0d 00 c0 04 	isync 
80002fa2:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80002fa6:	00 a0       	debug 
80002fa8:	1d 00 00 00 	j 80002fa8 <xQueueGenericReset+0x74>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80002fac:	40 24       	mov.aa %a4,%a2
80002fae:	6d 00 5a 05 	call 80003a62 <xTaskRemoveFromEventList>
80002fb2:	df 02 e8 7f 	jeq %d2,0,80002f82 <xQueueGenericReset+0x4e>
					queueYIELD_IF_USING_PREEMPTION();
80002fb6:	ad 00 80 00 	syscall 0
80002fba:	1d ff e4 ff 	j 80002f82 <xQueueGenericReset+0x4e>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
80002fbe:	d9 c4 10 00 	lea %a4,[%a12]16
80002fc2:	6d ff 74 fe 	call 80002caa <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
80002fc6:	d9 c4 24 00 	lea %a4,[%a12]36
80002fca:	6d ff 70 fe 	call 80002caa <vListInitialise>
80002fce:	1d ff da ff 	j 80002f82 <xQueueGenericReset+0x4e>

80002fd2 <prvInitialiseNewQueue>:
{
80002fd2:	40 ae       	mov.aa %a14,%sp
80002fd4:	02 42       	mov %d2,%d4
80002fd6:	80 43       	mov.d %d3,%a4
80002fd8:	40 54       	mov.aa %a4,%a5
	if( uxItemSize == ( UBaseType_t ) 0 )
80002fda:	df 05 0b 80 	jne %d5,0,80002ff0 <prvInitialiseNewQueue+0x1e>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
80002fde:	f4 45       	st.a [%a4],%a5
	pxNewQueue->uxLength = uxQueueLength;
80002fe0:	59 42 3c 00 	st.w [%a4]60,%d2
	pxNewQueue->uxItemSize = uxItemSize;
80002fe4:	59 45 00 10 	st.w [%a4]64,%d5
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
80002fe8:	82 14       	mov %d4,1
80002fea:	6d ff a5 ff 	call 80002f34 <xQueueGenericReset>
}
80002fee:	00 90       	ret 
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
80002ff0:	74 53       	st.w [%a5],%d3
80002ff2:	1d ff f7 ff 	j 80002fe0 <prvInitialiseNewQueue+0xe>

80002ff6 <xQueueGenericCreate>:
	{
80002ff6:	40 ae       	mov.aa %a14,%sp
80002ff8:	02 48       	mov %d8,%d4
80002ffa:	02 59       	mov %d9,%d5
80002ffc:	8f f6 0f a1 	and %d10,%d6,255
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
80003000:	df 04 13 80 	jne %d4,0,80003026 <xQueueGenericCreate+0x30>
  __asm__ volatile ("disable" ::: "memory");
80003004:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80003008:	4d c0 e2 2f 	mfcr %d2,$icr
8000300c:	8f f2 cf 21 	andn %d2,%d2,255
80003010:	8f 02 44 21 	or %d2,%d2,64
80003014:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
80003018:	0d 00 c0 04 	isync 
8000301c:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80003020:	00 a0       	debug 
80003022:	1d 00 00 00 	j 80003022 <xQueueGenericCreate+0x2c>
		if( uxItemSize == ( UBaseType_t ) 0 )
80003026:	df 05 14 00 	jeq %d5,0,8000304e <xQueueGenericCreate+0x58>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
8000302a:	e2 54       	mul %d4,%d5
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
8000302c:	1b 84 04 40 	addi %d4,%d4,72
80003030:	6d ff 7f fb 	call 8000272e <pvPortMalloc>
80003034:	40 2c       	mov.aa %a12,%a2
		if( pxNewQueue != NULL )
80003036:	bd 02 0a 00 	jz.a %a2,8000304a <xQueueGenericCreate+0x54>
			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
8000303a:	40 25       	mov.aa %a5,%a2
8000303c:	02 a6       	mov %d6,%d10
8000303e:	d9 24 08 10 	lea %a4,[%a2]72
80003042:	02 95       	mov %d5,%d9
80003044:	02 84       	mov %d4,%d8
80003046:	6d ff c6 ff 	call 80002fd2 <prvInitialiseNewQueue>
	}
8000304a:	40 c2       	mov.aa %a2,%a12
8000304c:	00 90       	ret 
			xQueueSizeInBytes = ( size_t ) 0;
8000304e:	02 54       	mov %d4,%d5
80003050:	1d ff ee ff 	j 8000302c <xQueueGenericCreate+0x36>

80003054 <xQueueGenericSend>:
{
80003054:	40 ae       	mov.aa %a14,%sp
80003056:	20 10       	sub.a %sp,16
80003058:	40 4c       	mov.aa %a12,%a4
8000305a:	80 5a       	mov.d %d10,%a5
8000305c:	59 e4 f4 ff 	st.w [%a14]-12,%d4
80003060:	02 58       	mov %d8,%d5
	configASSERT( pxQueue );
80003062:	bd 04 1b 00 	jz.a %a4,80003098 <xQueueGenericSend+0x44>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
80003066:	df 0a 2a 00 	jeq %d10,0,800030ba <xQueueGenericSend+0x66>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
8000306a:	df 28 3d 80 	jne %d8,2,800030e4 <xQueueGenericSend+0x90>
8000306e:	19 c2 3c 00 	ld.w %d2,[%a12]60
80003072:	df 12 39 00 	jeq %d2,1,800030e4 <xQueueGenericSend+0x90>
  __asm__ volatile ("disable" ::: "memory");
80003076:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
8000307a:	4d c0 e2 2f 	mfcr %d2,$icr
8000307e:	8f f2 cf 21 	andn %d2,%d2,255
80003082:	8f 02 44 21 	or %d2,%d2,64
80003086:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
8000308a:	0d 00 c0 04 	isync 
8000308e:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80003092:	00 a0       	debug 
80003094:	1d 00 00 00 	j 80003094 <xQueueGenericSend+0x40>
  __asm__ volatile ("disable" ::: "memory");
80003098:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
8000309c:	4d c0 e2 2f 	mfcr %d2,$icr
	configASSERT( pxQueue );
800030a0:	8f f2 cf 21 	andn %d2,%d2,255
800030a4:	8f 02 44 21 	or %d2,%d2,64
800030a8:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
800030ac:	0d 00 c0 04 	isync 
800030b0:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
800030b4:	00 a0       	debug 
800030b6:	1d 00 00 00 	j 800030b6 <xQueueGenericSend+0x62>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
800030ba:	19 42 00 10 	ld.w %d2,[%a4]64
800030be:	df 02 d6 7f 	jeq %d2,0,8000306a <xQueueGenericSend+0x16>
  __asm__ volatile ("disable" ::: "memory");
800030c2:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
800030c6:	4d c0 e2 2f 	mfcr %d2,$icr
800030ca:	8f f2 cf 21 	andn %d2,%d2,255
800030ce:	8f 02 44 21 	or %d2,%d2,64
800030d2:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
800030d6:	0d 00 c0 04 	isync 
800030da:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
800030de:	00 a0       	debug 
800030e0:	1d 00 00 00 	j 800030e0 <xQueueGenericSend+0x8c>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
800030e4:	6d 00 40 05 	call 80003b64 <xTaskGetSchedulerState>
800030e8:	02 29       	mov %d9,%d2
800030ea:	df 02 17 80 	jne %d2,0,80003118 <xQueueGenericSend+0xc4>
800030ee:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800030f2:	df 02 4c 00 	jeq %d2,0,8000318a <xQueueGenericSend+0x136>
  __asm__ volatile ("disable" ::: "memory");
800030f6:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
800030fa:	4d c0 e2 2f 	mfcr %d2,$icr
800030fe:	8f f2 cf 21 	andn %d2,%d2,255
80003102:	8f 02 44 21 	or %d2,%d2,64
80003106:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
8000310a:	0d 00 c0 04 	isync 
8000310e:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80003112:	00 a0       	debug 
80003114:	1d 00 00 00 	j 80003114 <xQueueGenericSend+0xc0>
80003118:	82 09       	mov %d9,0
8000311a:	1d 00 38 00 	j 8000318a <xQueueGenericSend+0x136>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000311e:	02 84       	mov %d4,%d8
80003120:	60 a5       	mov.a %a5,%d10
80003122:	40 c4       	mov.aa %a4,%a12
80003124:	6d ff 4d fe 	call 80002dbe <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80003128:	d9 c2 24 00 	lea %a2,[%a12]36
8000312c:	19 c3 24 00 	ld.w %d3,[%a12]36
80003130:	df 03 0a 80 	jne %d3,0,80003144 <xQueueGenericSend+0xf0>
					else if( xYieldRequired != pdFALSE )
80003134:	df 02 04 00 	jeq %d2,0,8000313c <xQueueGenericSend+0xe8>
						queueYIELD_IF_USING_PREEMPTION();
80003138:	ad 00 80 00 	syscall 0
				taskEXIT_CRITICAL();
8000313c:	6d 00 04 06 	call 80003d44 <vTaskExitCritical>
				return pdPASS;
80003140:	82 12       	mov %d2,1
80003142:	00 90       	ret 
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80003144:	40 24       	mov.aa %a4,%a2
80003146:	6d 00 8e 04 	call 80003a62 <xTaskRemoveFromEventList>
8000314a:	df 02 f9 7f 	jeq %d2,0,8000313c <xQueueGenericSend+0xe8>
							queueYIELD_IF_USING_PREEMPTION();
8000314e:	ad 00 80 00 	syscall 0
80003152:	1d ff f5 ff 	j 8000313c <xQueueGenericSend+0xe8>
					taskEXIT_CRITICAL();
80003156:	6d 00 f7 05 	call 80003d44 <vTaskExitCritical>
					return errQUEUE_FULL;
8000315a:	82 02       	mov %d2,0
8000315c:	00 90       	ret 
					vTaskSetTimeOutState( &xTimeOut );
8000315e:	d9 e4 f8 ff 	lea %a4,[%a14]-8
80003162:	6d 00 da 04 	call 80003b16 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
80003166:	82 19       	mov %d9,1
80003168:	1d 00 21 00 	j 800031aa <xQueueGenericSend+0x156>
		prvLockQueue( pxQueue );
8000316c:	82 02       	mov %d2,0
8000316e:	e9 c2 04 10 	st.b [%a12]68,%d2
80003172:	1d 00 26 00 	j 800031be <xQueueGenericSend+0x16a>
80003176:	82 02       	mov %d2,0
80003178:	e9 c2 05 10 	st.b [%a12]69,%d2
8000317c:	1d 00 25 00 	j 800031c6 <xQueueGenericSend+0x172>
				prvUnlockQueue( pxQueue );
80003180:	40 c4       	mov.aa %a4,%a12
80003182:	6d ff 98 fe 	call 80002eb2 <prvUnlockQueue>
				( void ) xTaskResumeAll();
80003186:	6d 00 f5 06 	call 80003f70 <xTaskResumeAll>
		taskENTER_CRITICAL();
8000318a:	6d 00 bb 05 	call 80003d00 <vTaskEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
8000318e:	19 c2 38 00 	ld.w %d2,[%a12]56
80003192:	19 c3 3c 00 	ld.w %d3,[%a12]60
80003196:	3f 32 c4 ff 	jlt.u %d2,%d3,8000311e <xQueueGenericSend+0xca>
8000319a:	df 28 c2 7f 	jeq %d8,2,8000311e <xQueueGenericSend+0xca>
				if( xTicksToWait == ( TickType_t ) 0 )
8000319e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800031a2:	df 02 da 7f 	jeq %d2,0,80003156 <xQueueGenericSend+0x102>
				else if( xEntryTimeSet == pdFALSE )
800031a6:	df 09 dc 7f 	jeq %d9,0,8000315e <xQueueGenericSend+0x10a>
		taskEXIT_CRITICAL();
800031aa:	6d 00 cd 05 	call 80003d44 <vTaskExitCritical>
		vTaskSuspendAll();
800031ae:	6d 00 dc 02 	call 80003766 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
800031b2:	6d 00 a7 05 	call 80003d00 <vTaskEnterCritical>
800031b6:	79 c3 04 10 	ld.b %d3,[%a12]68
800031ba:	df f3 d9 7f 	jeq %d3,-1,8000316c <xQueueGenericSend+0x118>
800031be:	79 c3 05 10 	ld.b %d3,[%a12]69
800031c2:	df f3 da 7f 	jeq %d3,-1,80003176 <xQueueGenericSend+0x122>
800031c6:	6d 00 bf 05 	call 80003d44 <vTaskExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800031ca:	d9 e5 f4 ff 	lea %a5,[%a14]-12
800031ce:	d9 e4 f8 ff 	lea %a4,[%a14]-8
800031d2:	6d 00 cf 07 	call 80004170 <xTaskCheckForTimeOut>
800031d6:	df 02 18 80 	jne %d2,0,80003206 <xQueueGenericSend+0x1b2>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
800031da:	40 c4       	mov.aa %a4,%a12
800031dc:	6d ff cf fd 	call 80002d7a <prvIsQueueFull>
800031e0:	df 02 d0 7f 	jeq %d2,0,80003180 <xQueueGenericSend+0x12c>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800031e4:	19 e4 f4 ff 	ld.w %d4,[%a14]-12
800031e8:	d9 c4 10 00 	lea %a4,[%a12]16
800031ec:	6d 00 f3 03 	call 800039d2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
800031f0:	40 c4       	mov.aa %a4,%a12
800031f2:	6d ff 60 fe 	call 80002eb2 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
800031f6:	6d 00 bd 06 	call 80003f70 <xTaskResumeAll>
800031fa:	df 02 c8 ff 	jne %d2,0,8000318a <xQueueGenericSend+0x136>
					portYIELD_WITHIN_API();
800031fe:	ad 00 80 00 	syscall 0
80003202:	1d ff c4 ff 	j 8000318a <xQueueGenericSend+0x136>
			prvUnlockQueue( pxQueue );
80003206:	40 c4       	mov.aa %a4,%a12
80003208:	6d ff 55 fe 	call 80002eb2 <prvUnlockQueue>
			( void ) xTaskResumeAll();
8000320c:	6d 00 b2 06 	call 80003f70 <xTaskResumeAll>
			return errQUEUE_FULL;
80003210:	82 02       	mov %d2,0
}
80003212:	00 90       	ret 

80003214 <xQueueGenericSendFromISR>:
{
80003214:	40 ae       	mov.aa %a14,%sp
80003216:	40 4c       	mov.aa %a12,%a4
80003218:	80 59       	mov.d %d9,%a5
8000321a:	40 6d       	mov.aa %a13,%a6
8000321c:	02 48       	mov %d8,%d4
	configASSERT( pxQueue );
8000321e:	bd 04 1b 00 	jz.a %a4,80003254 <xQueueGenericSendFromISR+0x40>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
80003222:	df 09 2a 00 	jeq %d9,0,80003276 <xQueueGenericSendFromISR+0x62>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
80003226:	df 28 3d 80 	jne %d8,2,800032a0 <xQueueGenericSendFromISR+0x8c>
8000322a:	19 c2 3c 00 	ld.w %d2,[%a12]60
8000322e:	df 12 39 00 	jeq %d2,1,800032a0 <xQueueGenericSendFromISR+0x8c>
  __asm__ volatile ("disable" ::: "memory");
80003232:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80003236:	4d c0 e2 2f 	mfcr %d2,$icr
8000323a:	8f f2 cf 21 	andn %d2,%d2,255
8000323e:	8f 02 44 21 	or %d2,%d2,64
80003242:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
80003246:	0d 00 c0 04 	isync 
8000324a:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
8000324e:	00 a0       	debug 
80003250:	1d 00 00 00 	j 80003250 <xQueueGenericSendFromISR+0x3c>
  __asm__ volatile ("disable" ::: "memory");
80003254:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80003258:	4d c0 e2 2f 	mfcr %d2,$icr
	configASSERT( pxQueue );
8000325c:	8f f2 cf 21 	andn %d2,%d2,255
80003260:	8f 02 44 21 	or %d2,%d2,64
80003264:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
80003268:	0d 00 c0 04 	isync 
8000326c:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80003270:	00 a0       	debug 
80003272:	1d 00 00 00 	j 80003272 <xQueueGenericSendFromISR+0x5e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
80003276:	19 42 00 10 	ld.w %d2,[%a4]64
8000327a:	df 02 d6 7f 	jeq %d2,0,80003226 <xQueueGenericSendFromISR+0x12>
  __asm__ volatile ("disable" ::: "memory");
8000327e:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80003282:	4d c0 e2 2f 	mfcr %d2,$icr
80003286:	8f f2 cf 21 	andn %d2,%d2,255
8000328a:	8f 02 44 21 	or %d2,%d2,64
8000328e:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
80003292:	0d 00 c0 04 	isync 
80003296:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
8000329a:	00 a0       	debug 
8000329c:	1d 00 00 00 	j 8000329c <xQueueGenericSendFromISR+0x88>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
800032a0:	6d ff 9c fc 	call 80002bd8 <uxPortSetInterruptMaskFromISR>
800032a4:	02 2b       	mov %d11,%d2
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
800032a6:	19 c3 38 00 	ld.w %d3,[%a12]56
800032aa:	19 c2 3c 00 	ld.w %d2,[%a12]60
800032ae:	3f 23 13 80 	jlt.u %d3,%d2,800032d4 <xQueueGenericSendFromISR+0xc0>
800032b2:	df 28 11 00 	jeq %d8,2,800032d4 <xQueueGenericSendFromISR+0xc0>
			xReturn = errQUEUE_FULL;
800032b6:	82 02       	mov %d2,0
  __asm__ volatile ("disable" ::: "memory");
800032b8:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
800032bc:	4d c0 e2 3f 	mfcr %d3,$icr
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
800032c0:	8f f3 cf 31 	andn %d3,%d3,255
800032c4:	a6 b3       	or %d3,%d11
800032c6:	cd c3 e2 0f 	mtcr $icr,%d3
    __asm__ volatile ("isync" : : : "memory");
800032ca:	0d 00 c0 04 	isync 
800032ce:	0d 00 00 03 	enable 
}
800032d2:	00 90       	ret 
			const int8_t cTxLock = pxQueue->cTxLock;
800032d4:	79 ca 05 10 	ld.b %d10,[%a12]69
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800032d8:	02 84       	mov %d4,%d8
800032da:	60 95       	mov.a %a5,%d9
800032dc:	40 c4       	mov.aa %a4,%a12
800032de:	6d ff 70 fd 	call 80002dbe <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
800032e2:	df fa 0b 00 	jeq %d10,-1,800032f8 <xQueueGenericSendFromISR+0xe4>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
800032e6:	1b 1a 00 20 	addi %d2,%d10,1
800032ea:	37 02 48 20 	extr %d2,%d2,0,8
800032ee:	e9 c2 05 10 	st.b [%a12]69,%d2
			xReturn = pdPASS;
800032f2:	82 12       	mov %d2,1
800032f4:	1d ff e2 ff 	j 800032b8 <xQueueGenericSendFromISR+0xa4>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800032f8:	d9 c2 24 00 	lea %a2,[%a12]36
800032fc:	19 c2 24 00 	ld.w %d2,[%a12]36
80003300:	df 02 05 80 	jne %d2,0,8000330a <xQueueGenericSendFromISR+0xf6>
			xReturn = pdPASS;
80003304:	82 12       	mov %d2,1
80003306:	1d ff d9 ff 	j 800032b8 <xQueueGenericSendFromISR+0xa4>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000330a:	40 24       	mov.aa %a4,%a2
8000330c:	6d 00 ab 03 	call 80003a62 <xTaskRemoveFromEventList>
80003310:	df 02 08 00 	jeq %d2,0,80003320 <xQueueGenericSendFromISR+0x10c>
							if( pxHigherPriorityTaskWoken != NULL )
80003314:	bd 0d 09 00 	jz.a %a13,80003326 <xQueueGenericSendFromISR+0x112>
								*pxHigherPriorityTaskWoken = pdTRUE;
80003318:	82 12       	mov %d2,1
8000331a:	74 d2       	st.w [%a13],%d2
8000331c:	1d ff ce ff 	j 800032b8 <xQueueGenericSendFromISR+0xa4>
			xReturn = pdPASS;
80003320:	82 12       	mov %d2,1
80003322:	1d ff cb ff 	j 800032b8 <xQueueGenericSendFromISR+0xa4>
80003326:	82 12       	mov %d2,1
80003328:	1d ff c8 ff 	j 800032b8 <xQueueGenericSendFromISR+0xa4>

8000332c <xQueueGenericReceive>:
{
8000332c:	40 ae       	mov.aa %a14,%sp
8000332e:	20 10       	sub.a %sp,16
80003330:	40 4c       	mov.aa %a12,%a4
80003332:	80 5a       	mov.d %d10,%a5
80003334:	59 e4 f4 ff 	st.w [%a14]-12,%d4
80003338:	02 5b       	mov %d11,%d5
	configASSERT( pxQueue );
8000333a:	bd 04 1e 00 	jz.a %a4,80003376 <xQueueGenericReceive+0x4a>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
8000333e:	df 0a 2d 00 	jeq %d10,0,80003398 <xQueueGenericReceive+0x6c>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
80003342:	6d 00 11 04 	call 80003b64 <xTaskGetSchedulerState>
80003346:	02 28       	mov %d8,%d2
80003348:	df 02 3d 80 	jne %d2,0,800033c2 <xQueueGenericReceive+0x96>
8000334c:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80003350:	df 02 a5 00 	jeq %d2,0,8000349a <xQueueGenericReceive+0x16e>
  __asm__ volatile ("disable" ::: "memory");
80003354:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80003358:	4d c0 e2 2f 	mfcr %d2,$icr
8000335c:	8f f2 cf 21 	andn %d2,%d2,255
80003360:	8f 02 44 21 	or %d2,%d2,64
80003364:	cd c2 e2 0f 	mtcr $icr,%d2
80003368:	0d 00 c0 04 	isync 
8000336c:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80003370:	00 a0       	debug 
80003372:	1d 00 00 00 	j 80003372 <xQueueGenericReceive+0x46>
  __asm__ volatile ("disable" ::: "memory");
80003376:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
8000337a:	4d c0 e2 2f 	mfcr %d2,$icr
	configASSERT( pxQueue );
8000337e:	8f f2 cf 21 	andn %d2,%d2,255
80003382:	8f 02 44 21 	or %d2,%d2,64
80003386:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
8000338a:	0d 00 c0 04 	isync 
8000338e:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80003392:	00 a0       	debug 
80003394:	1d 00 00 00 	j 80003394 <xQueueGenericReceive+0x68>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
80003398:	19 42 00 10 	ld.w %d2,[%a4]64
8000339c:	df 02 d3 7f 	jeq %d2,0,80003342 <xQueueGenericReceive+0x16>
  __asm__ volatile ("disable" ::: "memory");
800033a0:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
800033a4:	4d c0 e2 2f 	mfcr %d2,$icr
800033a8:	8f f2 cf 21 	andn %d2,%d2,255
800033ac:	8f 02 44 21 	or %d2,%d2,64
800033b0:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
800033b4:	0d 00 c0 04 	isync 
800033b8:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
800033bc:	00 a0       	debug 
800033be:	1d 00 00 00 	j 800033be <xQueueGenericReceive+0x92>
800033c2:	82 08       	mov %d8,0
800033c4:	1d 00 6b 00 	j 8000349a <xQueueGenericReceive+0x16e>
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
800033c8:	19 c8 0c 00 	ld.w %d8,[%a12]12
				prvCopyDataFromQueue( pxQueue, pvBuffer );
800033cc:	60 a5       	mov.a %a5,%d10
800033ce:	40 c4       	mov.aa %a4,%a12
800033d0:	6d ff 55 fd 	call 80002e7a <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
800033d4:	df 0b 22 80 	jne %d11,0,80003418 <xQueueGenericReceive+0xec>
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
800033d8:	1b f9 ff 2f 	addi %d2,%d9,-1
800033dc:	59 c2 38 00 	st.w [%a12]56,%d2
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800033e0:	54 c2       	ld.w %d2,[%a12]
800033e2:	df 02 0c 00 	jeq %d2,0,800033fa <xQueueGenericReceive+0xce>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800033e6:	d9 c2 10 00 	lea %a2,[%a12]16
800033ea:	19 c2 10 00 	ld.w %d2,[%a12]16
800033ee:	df 02 0c 80 	jne %d2,0,80003406 <xQueueGenericReceive+0xda>
				taskEXIT_CRITICAL();
800033f2:	6d 00 a9 04 	call 80003d44 <vTaskExitCritical>
				return pdPASS;
800033f6:	82 12       	mov %d2,1
800033f8:	00 90       	ret 
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
800033fa:	6d 00 13 07 	call 80004220 <pvTaskIncrementMutexHeldCount>
800033fe:	b5 c2 04 00 	st.a [%a12]4,%a2
80003402:	1d ff f2 ff 	j 800033e6 <xQueueGenericReceive+0xba>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80003406:	40 24       	mov.aa %a4,%a2
80003408:	6d 00 2d 03 	call 80003a62 <xTaskRemoveFromEventList>
8000340c:	df 02 f3 7f 	jeq %d2,0,800033f2 <xQueueGenericReceive+0xc6>
							queueYIELD_IF_USING_PREEMPTION();
80003410:	ad 00 80 00 	syscall 0
80003414:	1d ff ef ff 	j 800033f2 <xQueueGenericReceive+0xc6>
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
80003418:	59 c8 0c 00 	st.w [%a12]12,%d8
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000341c:	d9 c2 24 00 	lea %a2,[%a12]36
80003420:	19 c2 24 00 	ld.w %d2,[%a12]36
80003424:	df 02 e7 7f 	jeq %d2,0,800033f2 <xQueueGenericReceive+0xc6>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80003428:	40 24       	mov.aa %a4,%a2
8000342a:	6d 00 1c 03 	call 80003a62 <xTaskRemoveFromEventList>
8000342e:	df 02 e2 7f 	jeq %d2,0,800033f2 <xQueueGenericReceive+0xc6>
							queueYIELD_IF_USING_PREEMPTION();
80003432:	ad 00 80 00 	syscall 0
80003436:	1d ff de ff 	j 800033f2 <xQueueGenericReceive+0xc6>
					taskEXIT_CRITICAL();
8000343a:	6d 00 85 04 	call 80003d44 <vTaskExitCritical>
					return errQUEUE_EMPTY;
8000343e:	82 02       	mov %d2,0
80003440:	00 90       	ret 
					vTaskSetTimeOutState( &xTimeOut );
80003442:	d9 e4 f8 ff 	lea %a4,[%a14]-8
80003446:	6d 00 68 03 	call 80003b16 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
8000344a:	82 18       	mov %d8,1
8000344c:	1d 00 33 00 	j 800034b2 <xQueueGenericReceive+0x186>
		prvLockQueue( pxQueue );
80003450:	82 02       	mov %d2,0
80003452:	e9 c2 04 10 	st.b [%a12]68,%d2
80003456:	1d 00 38 00 	j 800034c6 <xQueueGenericReceive+0x19a>
8000345a:	82 02       	mov %d2,0
8000345c:	e9 c2 05 10 	st.b [%a12]69,%d2
80003460:	1d 00 37 00 	j 800034ce <xQueueGenericReceive+0x1a2>
						taskENTER_CRITICAL();
80003464:	6d 00 4e 04 	call 80003d00 <vTaskEnterCritical>
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80003468:	99 c4 04 00 	ld.a %a4,[%a12]4
8000346c:	6d 00 8f 03 	call 80003b8a <vTaskPriorityInherit>
						taskEXIT_CRITICAL();
80003470:	6d 00 6a 04 	call 80003d44 <vTaskExitCritical>
80003474:	1d 00 3f 00 	j 800034f2 <xQueueGenericReceive+0x1c6>
				prvUnlockQueue( pxQueue );
80003478:	40 c4       	mov.aa %a4,%a12
8000347a:	6d ff 1c fd 	call 80002eb2 <prvUnlockQueue>
				( void ) xTaskResumeAll();
8000347e:	6d 00 79 05 	call 80003f70 <xTaskResumeAll>
80003482:	1d 00 0c 00 	j 8000349a <xQueueGenericReceive+0x16e>
			prvUnlockQueue( pxQueue );
80003486:	40 c4       	mov.aa %a4,%a12
80003488:	6d ff 15 fd 	call 80002eb2 <prvUnlockQueue>
			( void ) xTaskResumeAll();
8000348c:	6d 00 72 05 	call 80003f70 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
80003490:	40 c4       	mov.aa %a4,%a12
80003492:	6d ff 86 fc 	call 80002d9e <prvIsQueueEmpty>
80003496:	df 02 3f 80 	jne %d2,0,80003514 <xQueueGenericReceive+0x1e8>
		taskENTER_CRITICAL();
8000349a:	6d 00 33 04 	call 80003d00 <vTaskEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
8000349e:	19 c9 38 00 	ld.w %d9,[%a12]56
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
800034a2:	df 09 93 ff 	jne %d9,0,800033c8 <xQueueGenericReceive+0x9c>
				if( xTicksToWait == ( TickType_t ) 0 )
800034a6:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800034aa:	df 02 c8 7f 	jeq %d2,0,8000343a <xQueueGenericReceive+0x10e>
				else if( xEntryTimeSet == pdFALSE )
800034ae:	df 08 ca 7f 	jeq %d8,0,80003442 <xQueueGenericReceive+0x116>
		taskEXIT_CRITICAL();
800034b2:	6d 00 49 04 	call 80003d44 <vTaskExitCritical>
		vTaskSuspendAll();
800034b6:	6d 00 58 01 	call 80003766 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
800034ba:	6d 00 23 04 	call 80003d00 <vTaskEnterCritical>
800034be:	79 c3 04 10 	ld.b %d3,[%a12]68
800034c2:	df f3 c7 7f 	jeq %d3,-1,80003450 <xQueueGenericReceive+0x124>
800034c6:	79 c3 05 10 	ld.b %d3,[%a12]69
800034ca:	df f3 c8 7f 	jeq %d3,-1,8000345a <xQueueGenericReceive+0x12e>
800034ce:	6d 00 3b 04 	call 80003d44 <vTaskExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800034d2:	d9 e5 f4 ff 	lea %a5,[%a14]-12
800034d6:	d9 e4 f8 ff 	lea %a4,[%a14]-8
800034da:	6d 00 4b 06 	call 80004170 <xTaskCheckForTimeOut>
800034de:	df 02 d4 ff 	jne %d2,0,80003486 <xQueueGenericReceive+0x15a>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
800034e2:	40 c4       	mov.aa %a4,%a12
800034e4:	6d ff 5d fc 	call 80002d9e <prvIsQueueEmpty>
800034e8:	df 02 c8 7f 	jeq %d2,0,80003478 <xQueueGenericReceive+0x14c>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800034ec:	54 c2       	ld.w %d2,[%a12]
800034ee:	df 02 bb 7f 	jeq %d2,0,80003464 <xQueueGenericReceive+0x138>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800034f2:	19 e4 f4 ff 	ld.w %d4,[%a14]-12
800034f6:	d9 c4 24 00 	lea %a4,[%a12]36
800034fa:	6d 00 6c 02 	call 800039d2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
800034fe:	40 c4       	mov.aa %a4,%a12
80003500:	6d ff d9 fc 	call 80002eb2 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
80003504:	6d 00 36 05 	call 80003f70 <xTaskResumeAll>
80003508:	df 02 c9 ff 	jne %d2,0,8000349a <xQueueGenericReceive+0x16e>
					portYIELD_WITHIN_API();
8000350c:	ad 00 80 00 	syscall 0
80003510:	1d ff c5 ff 	j 8000349a <xQueueGenericReceive+0x16e>
				return errQUEUE_EMPTY;
80003514:	82 02       	mov %d2,0
}
80003516:	00 90       	ret 

80003518 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
80003518:	40 ae       	mov.aa %a14,%sp
8000351a:	40 4c       	mov.aa %a12,%a4
8000351c:	02 48       	mov %d8,%d4
8000351e:	02 59       	mov %d9,%d5
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
80003520:	6d 00 f0 03 	call 80003d00 <vTaskEnterCritical>
80003524:	79 c2 04 10 	ld.b %d2,[%a12]68
80003528:	df f2 10 00 	jeq %d2,-1,80003548 <vQueueWaitForMessageRestricted+0x30>
8000352c:	79 c2 05 10 	ld.b %d2,[%a12]69
80003530:	df f2 11 00 	jeq %d2,-1,80003552 <vQueueWaitForMessageRestricted+0x3a>
80003534:	6d 00 08 04 	call 80003d44 <vTaskExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
80003538:	19 c2 38 00 	ld.w %d2,[%a12]56
8000353c:	df 02 10 00 	jeq %d2,0,8000355c <vQueueWaitForMessageRestricted+0x44>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
80003540:	40 c4       	mov.aa %a4,%a12
80003542:	6d ff b8 fc 	call 80002eb2 <prvUnlockQueue>
	}
80003546:	00 90       	ret 
		prvLockQueue( pxQueue );
80003548:	82 02       	mov %d2,0
8000354a:	e9 c2 04 10 	st.b [%a12]68,%d2
8000354e:	1d ff ef ff 	j 8000352c <vQueueWaitForMessageRestricted+0x14>
80003552:	82 02       	mov %d2,0
80003554:	e9 c2 05 10 	st.b [%a12]69,%d2
80003558:	1d ff ee ff 	j 80003534 <vQueueWaitForMessageRestricted+0x1c>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
8000355c:	02 95       	mov %d5,%d9
8000355e:	02 84       	mov %d4,%d8
80003560:	d9 c4 24 00 	lea %a4,[%a12]36
80003564:	6d 00 59 02 	call 80003a16 <vTaskPlaceOnEventListRestricted>
80003568:	1d ff ec ff 	j 80003540 <vQueueWaitForMessageRestricted+0x28>

8000356c <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
8000356c:	40 ae       	mov.aa %a14,%sp
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000356e:	91 10 00 27 	movh.a %a2,28673
80003572:	99 22 10 20 	ld.a %a2,[%a2]144 <70010090 <pxDelayedTaskList>>
80003576:	54 22       	ld.w %d2,[%a2]
80003578:	df 02 08 80 	jne %d2,0,80003588 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
8000357c:	91 10 00 27 	movh.a %a2,28673
80003580:	82 f2       	mov %d2,-1
80003582:	59 22 28 00 	st.w [%a2]40 <70010028 <xNextTaskUnblockTime>>,%d2
80003586:	00 90       	ret 
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80003588:	91 10 00 27 	movh.a %a2,28673
8000358c:	99 22 10 20 	ld.a %a2,[%a2]144 <70010090 <pxDelayedTaskList>>
80003590:	d9 22 0c 00 	lea %a2,[%a2]12 <70010090 <pxDelayedTaskList>>
80003594:	d4 22       	ld.a %a2,[%a2]
80003596:	d9 22 0c 00 	lea %a2,[%a2]12 <70010090 <pxDelayedTaskList>>
8000359a:	d4 22       	ld.a %a2,[%a2]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
8000359c:	19 22 04 00 	ld.w %d2,[%a2]4 <70010090 <pxDelayedTaskList>>
800035a0:	91 10 00 27 	movh.a %a2,28673
800035a4:	59 22 28 00 	st.w [%a2]40 <70010028 <xNextTaskUnblockTime>>,%d2
	}
}
800035a8:	00 90       	ret 

800035aa <prvInitialiseNewTask>:
{
800035aa:	40 ae       	mov.aa %a14,%sp
800035ac:	80 4b       	mov.d %d11,%a4
800035ae:	80 6c       	mov.d %d12,%a6
800035b0:	02 58       	mov %d8,%d5
800035b2:	40 7d       	mov.aa %a13,%a7
800035b4:	d4 ec       	ld.a %a12,[%a14]
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
800035b6:	82 f2       	mov %d2,-1
800035b8:	06 e2       	sh %d2,-2
800035ba:	42 42       	add %d2,%d4
800035bc:	06 22       	sh %d2,2
800035be:	19 c3 30 00 	ld.w %d3,[%a12]48
800035c2:	42 32       	add %d2,%d3
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
800035c4:	8f 32 c0 a1 	andn %d10,%d2,3
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
800035c8:	82 02       	mov %d2,0
800035ca:	8b 02 62 32 	lt.u %d3,%d2,32
800035ce:	df 03 0f 00 	jeq %d3,0,800035ec <prvInitialiseNewTask+0x42>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
800035d2:	01 52 00 26 	addsc.a %a2,%a5,%d2,0
800035d6:	79 23 00 00 	ld.b %d3,[%a2]0
800035da:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
800035de:	e9 23 34 00 	st.b [%a2]52,%d3
		if( pcName[ x ] == 0x00 )
800035e2:	df 03 05 00 	jeq %d3,0,800035ec <prvInitialiseNewTask+0x42>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
800035e6:	c2 12       	add %d2,1
800035e8:	1d ff f1 ff 	j 800035ca <prvInitialiseNewTask+0x20>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
800035ec:	82 02       	mov %d2,0
800035ee:	e9 c2 13 10 	st.b [%a12]83,%d2
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
800035f2:	bf 68 03 80 	jlt.u %d8,6,800035f8 <prvInitialiseNewTask+0x4e>
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
800035f6:	82 58       	mov %d8,5
	pxNewTCB->uxPriority = uxPriority;
800035f8:	59 c8 2c 00 	st.w [%a12]44,%d8
		pxNewTCB->uxBasePriority = uxPriority;
800035fc:	59 c8 18 10 	st.w [%a12]88,%d8
		pxNewTCB->uxMutexesHeld = 0;
80003600:	82 09       	mov %d9,0
80003602:	59 c9 1c 10 	st.w [%a12]92,%d9
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
80003606:	d9 c4 04 00 	lea %a4,[%a12]4
8000360a:	6d ff 60 fb 	call 80002cca <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
8000360e:	d9 c4 18 00 	lea %a4,[%a12]24
80003612:	6d ff 5c fb 	call 80002cca <vListInitialiseItem>
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
80003616:	b5 cc 10 00 	st.a [%a12]16,%a12
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
8000361a:	8b 68 00 81 	rsub %d8,%d8,6
8000361e:	59 c8 18 00 	st.w [%a12]24,%d8
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
80003622:	b5 cc 24 00 	st.a [%a12]36,%a12
		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
80003626:	59 c9 14 10 	st.w [%a12]84,%d9
		pxNewTCB->ulNotifiedValue = 0;
8000362a:	59 c9 20 10 	st.w [%a12]96,%d9
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
8000362e:	e9 c9 24 10 	st.b [%a12]100,%d9
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80003632:	60 c6       	mov.a %a6,%d12
80003634:	60 b5       	mov.a %a5,%d11
80003636:	60 a4       	mov.a %a4,%d10
80003638:	6d ff bf f9 	call 800029b6 <pxPortInitialiseStack>
8000363c:	f4 c2       	st.a [%a12],%a2
	if( ( void * ) pxCreatedTask != NULL )
8000363e:	bd 0d 03 00 	jz.a %a13,80003644 <prvInitialiseNewTask+0x9a>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
80003642:	f4 dc       	st.a [%a13],%a12
}
80003644:	00 90       	ret 

80003646 <prvInitialiseTaskLists>:
{
80003646:	40 ae       	mov.aa %a14,%sp
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
80003648:	82 08       	mov %d8,0
8000364a:	1d 00 0d 00 	j 80003664 <prvInitialiseTaskLists+0x1e>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
8000364e:	91 10 00 47 	movh.a %a4,28673
80003652:	d9 44 3c 20 	lea %a4,[%a4]188 <700100bc <pxReadyTasksLists>>
80003656:	53 48 21 20 	mul %d2,%d8,20
8000365a:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
8000365e:	6d ff 26 fb 	call 80002caa <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
80003662:	c2 18       	add %d8,1
80003664:	bf 68 f5 ff 	jlt.u %d8,6,8000364e <prvInitialiseTaskLists+0x8>
	vListInitialise( &xDelayedTaskList1 );
80003668:	91 10 00 d7 	movh.a %a13,28673
8000366c:	d9 dd 28 20 	lea %a13,[%a13]168 <700100a8 <xDelayedTaskList1>>
80003670:	40 d4       	mov.aa %a4,%a13
80003672:	6d ff 1c fb 	call 80002caa <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
80003676:	91 10 00 c7 	movh.a %a12,28673
8000367a:	d9 cc 14 20 	lea %a12,[%a12]148 <70010094 <xDelayedTaskList2>>
8000367e:	40 c4       	mov.aa %a4,%a12
80003680:	6d ff 15 fb 	call 80002caa <vListInitialise>
	vListInitialise( &xPendingReadyList );
80003684:	91 10 00 47 	movh.a %a4,28673
80003688:	d9 44 38 10 	lea %a4,[%a4]120 <70010078 <xPendingReadyList>>
8000368c:	6d ff 0f fb 	call 80002caa <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
80003690:	91 10 00 47 	movh.a %a4,28673
80003694:	d9 44 24 10 	lea %a4,[%a4]100 <70010064 <xTasksWaitingTermination>>
80003698:	6d ff 09 fb 	call 80002caa <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
8000369c:	91 10 00 47 	movh.a %a4,28673
800036a0:	d9 44 0c 10 	lea %a4,[%a4]76 <7001004c <xSuspendedTaskList>>
800036a4:	6d ff 03 fb 	call 80002caa <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
800036a8:	91 10 00 27 	movh.a %a2,28673
800036ac:	b5 2d 10 20 	st.a [%a2]144 <70010090 <pxDelayedTaskList>>,%a13
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800036b0:	91 10 00 27 	movh.a %a2,28673
800036b4:	b5 2c 0c 20 	st.a [%a2]140 <7001008c <pxOverflowDelayedTaskList>>,%a12
}
800036b8:	00 90       	ret 

800036ba <prvDeleteTCB>:
	{
800036ba:	40 ae       	mov.aa %a14,%sp
800036bc:	40 4c       	mov.aa %a12,%a4
		portCLEAN_UP_TCB( pxTCB );
800036be:	6d ff 42 fa 	call 80002b42 <vPortReclaimCSA>
			vPortFree( pxTCB->pxStack );
800036c2:	99 c4 30 00 	ld.a %a4,[%a12]48
800036c6:	6d ff e0 f8 	call 80002886 <vPortFree>
			vPortFree( pxTCB );
800036ca:	40 c4       	mov.aa %a4,%a12
800036cc:	6d ff dd f8 	call 80002886 <vPortFree>
	}
800036d0:	00 90       	ret 

800036d2 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
800036d2:	40 ae       	mov.aa %a14,%sp
800036d4:	02 48       	mov %d8,%d4
800036d6:	02 5a       	mov %d10,%d5
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
800036d8:	91 10 00 27 	movh.a %a2,28673
800036dc:	19 29 04 10 	ld.w %d9,[%a2]68 <70010044 <xTickCount>>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
800036e0:	91 10 00 47 	movh.a %a4,28673
800036e4:	99 44 34 40 	ld.a %a4,[%a4]308 <70010134 <pxCurrentTCB>>
800036e8:	b0 44       	add.a %a4,4
800036ea:	6d ff 28 fb 	call 80002d3a <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
800036ee:	8b f8 1f 22 	eq %d2,%d8,-1
800036f2:	8b 0a 20 52 	ne %d5,%d10,0
800036f6:	26 25       	and %d5,%d2
800036f8:	df 05 17 80 	jne %d5,0,80003726 <prvAddCurrentTaskToDelayedList+0x54>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
800036fc:	42 98       	add %d8,%d9

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
800036fe:	91 10 00 27 	movh.a %a2,28673
80003702:	99 22 34 40 	ld.a %a2,[%a2]308 <70010134 <pxCurrentTCB>>
80003706:	59 28 04 00 	st.w [%a2]4 <70010134 <pxCurrentTCB>>,%d8

			if( xTimeToWake < xConstTickCount )
8000370a:	7f 98 1a 80 	jge.u %d8,%d9,8000373e <prvAddCurrentTaskToDelayedList+0x6c>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
8000370e:	91 10 00 47 	movh.a %a4,28673
80003712:	99 44 0c 20 	ld.a %a4,[%a4]140 <7001008c <pxOverflowDelayedTaskList>>
80003716:	91 10 00 57 	movh.a %a5,28673
8000371a:	99 55 34 40 	ld.a %a5,[%a5]308 <70010134 <pxCurrentTCB>>
8000371e:	b0 45       	add.a %a5,4
80003720:	6d ff ed fa 	call 80002cfa <vListInsert>
80003724:	00 90       	ret 
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
80003726:	91 10 00 57 	movh.a %a5,28673
8000372a:	99 55 34 40 	ld.a %a5,[%a5]308 <70010134 <pxCurrentTCB>>
8000372e:	b0 45       	add.a %a5,4
80003730:	91 10 00 47 	movh.a %a4,28673
80003734:	d9 44 0c 10 	lea %a4,[%a4]76 <7001004c <xSuspendedTaskList>>
80003738:	6d ff ce fa 	call 80002cd4 <vListInsertEnd>
8000373c:	00 90       	ret 
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
8000373e:	91 10 00 47 	movh.a %a4,28673
80003742:	99 44 10 20 	ld.a %a4,[%a4]144 <70010090 <pxDelayedTaskList>>
80003746:	91 10 00 57 	movh.a %a5,28673
8000374a:	99 55 34 40 	ld.a %a5,[%a5]308 <70010134 <pxCurrentTCB>>
8000374e:	b0 45       	add.a %a5,4
80003750:	6d ff d5 fa 	call 80002cfa <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
80003754:	91 10 00 27 	movh.a %a2,28673
80003758:	19 22 28 00 	ld.w %d2,[%a2]40 <70010028 <xNextTaskUnblockTime>>
8000375c:	7f 28 04 80 	jge.u %d8,%d2,80003764 <prvAddCurrentTaskToDelayedList+0x92>
				{
					xNextTaskUnblockTime = xTimeToWake;
80003760:	59 28 28 00 	st.w [%a2]40 <70010028 <xNextTaskUnblockTime>>,%d8

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
80003764:	00 90       	ret 

80003766 <vTaskSuspendAll>:
{
80003766:	40 ae       	mov.aa %a14,%sp
	++uxSchedulerSuspended;
80003768:	91 10 00 27 	movh.a %a2,28673
8000376c:	19 22 20 00 	ld.w %d2,[%a2]32 <70010020 <uxSchedulerSuspended>>
80003770:	c2 12       	add %d2,1
80003772:	59 22 20 00 	st.w [%a2]32 <70010020 <uxSchedulerSuspended>>,%d2
}
80003776:	00 90       	ret 

80003778 <xTaskGetTickCount>:
{
80003778:	40 ae       	mov.aa %a14,%sp
}
8000377a:	91 10 00 27 	movh.a %a2,28673
8000377e:	19 22 04 10 	ld.w %d2,[%a2]68 <70010044 <xTickCount>>
80003782:	00 90       	ret 

80003784 <xTaskIncrementTick>:
{
80003784:	40 ae       	mov.aa %a14,%sp
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80003786:	91 10 00 27 	movh.a %a2,28673
8000378a:	19 22 20 00 	ld.w %d2,[%a2]32 <70010020 <uxSchedulerSuspended>>
8000378e:	df 02 a8 80 	jne %d2,0,800038de <xTaskIncrementTick+0x15a>
		const TickType_t xConstTickCount = xTickCount + 1;
80003792:	91 10 00 27 	movh.a %a2,28673
80003796:	19 22 04 10 	ld.w %d2,[%a2]68 <70010044 <xTickCount>>
8000379a:	1b 12 00 80 	addi %d8,%d2,1
		xTickCount = xConstTickCount;
8000379e:	59 28 04 10 	st.w [%a2]68 <70010044 <xTickCount>>,%d8
		if( xConstTickCount == ( TickType_t ) 0U )
800037a2:	df 08 2f 80 	jne %d8,0,80003800 <xTaskIncrementTick+0x7c>
			taskSWITCH_DELAYED_LISTS();
800037a6:	91 10 00 27 	movh.a %a2,28673
800037aa:	99 22 10 20 	ld.a %a2,[%a2]144 <70010090 <pxDelayedTaskList>>
800037ae:	54 22       	ld.w %d2,[%a2]
800037b0:	df 02 13 00 	jeq %d2,0,800037d6 <xTaskIncrementTick+0x52>
  __asm__ volatile ("disable" ::: "memory");
800037b4:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
800037b8:	4d c0 e2 2f 	mfcr %d2,$icr
800037bc:	8f f2 cf 21 	andn %d2,%d2,255
800037c0:	8f 02 44 21 	or %d2,%d2,64
800037c4:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
800037c8:	0d 00 c0 04 	isync 
800037cc:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
800037d0:	00 a0       	debug 
800037d2:	1d 00 00 00 	j 800037d2 <xTaskIncrementTick+0x4e>
800037d6:	91 10 00 37 	movh.a %a3,28673
800037da:	19 32 10 20 	ld.w %d2,[%a3]144 <70010090 <pxDelayedTaskList>>
800037de:	91 10 00 27 	movh.a %a2,28673
800037e2:	19 23 0c 20 	ld.w %d3,[%a2]140 <7001008c <pxOverflowDelayedTaskList>>
800037e6:	59 33 10 20 	st.w [%a3]144 <70010090 <pxDelayedTaskList>>,%d3
800037ea:	59 22 0c 20 	st.w [%a2]140 <7001008c <pxOverflowDelayedTaskList>>,%d2
800037ee:	91 10 00 27 	movh.a %a2,28673
800037f2:	19 22 30 00 	ld.w %d2,[%a2]48 <70010030 <xNumOfOverflows>>
800037f6:	c2 12       	add %d2,1
800037f8:	59 22 30 00 	st.w [%a2]48 <70010030 <xNumOfOverflows>>,%d2
800037fc:	6d ff b8 fe 	call 8000356c <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
80003800:	91 10 00 27 	movh.a %a2,28673
80003804:	19 22 28 00 	ld.w %d2,[%a2]40 <70010028 <xNextTaskUnblockTime>>
80003808:	7f 28 5b 80 	jge.u %d8,%d2,800038be <xTaskIncrementTick+0x13a>
BaseType_t xSwitchRequired = pdFALSE;
8000380c:	82 0a       	mov %d10,0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
8000380e:	91 10 00 27 	movh.a %a2,28673
80003812:	99 22 34 40 	ld.a %a2,[%a2]308 <70010134 <pxCurrentTCB>>
80003816:	19 23 2c 00 	ld.w %d3,[%a2]44 <70010134 <pxCurrentTCB>>
8000381a:	91 10 00 27 	movh.a %a2,28673
8000381e:	80 22       	mov.d %d2,%a2
80003820:	1b c2 0b 20 	addi %d2,%d2,188
80003824:	13 43 21 22 	madd %d2,%d2,%d3,20
80003828:	60 22       	mov.a %a2,%d2
8000382a:	54 22       	ld.w %d2,[%a2]
8000382c:	bf 22 61 80 	jlt.u %d2,2,800038ee <xTaskIncrementTick+0x16a>
				xSwitchRequired = pdTRUE;
80003830:	82 1a       	mov %d10,1
80003832:	1d 00 5e 00 	j 800038ee <xTaskIncrementTick+0x16a>
							xSwitchRequired = pdTRUE;
80003836:	82 1a       	mov %d10,1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80003838:	91 10 00 27 	movh.a %a2,28673
8000383c:	99 22 10 20 	ld.a %a2,[%a2]144 <70010090 <pxDelayedTaskList>>
80003840:	54 22       	ld.w %d2,[%a2]
80003842:	df 02 41 00 	jeq %d2,0,800038c4 <xTaskIncrementTick+0x140>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80003846:	91 10 00 27 	movh.a %a2,28673
8000384a:	99 22 10 20 	ld.a %a2,[%a2]144 <70010090 <pxDelayedTaskList>>
8000384e:	d9 22 0c 00 	lea %a2,[%a2]12 <70010090 <pxDelayedTaskList>>
80003852:	d4 22       	ld.a %a2,[%a2]
80003854:	99 2c 0c 00 	ld.a %a12,[%a2]12 <70010090 <pxDelayedTaskList>>
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
80003858:	19 c2 04 00 	ld.w %d2,[%a12]4 <70010090 <pxDelayedTaskList>>
					if( xConstTickCount < xItemValue )
8000385c:	3f 28 3b 80 	jlt.u %d8,%d2,800038d2 <xTaskIncrementTick+0x14e>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80003860:	80 c2       	mov.d %d2,%a12
80003862:	1b 42 00 90 	addi %d9,%d2,4
80003866:	60 94       	mov.a %a4,%d9
80003868:	6d ff 69 fa 	call 80002d3a <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
8000386c:	19 c2 28 00 	ld.w %d2,[%a12]40
80003870:	df 02 06 00 	jeq %d2,0,8000387c <xTaskIncrementTick+0xf8>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80003874:	d9 c4 18 00 	lea %a4,[%a12]24
80003878:	6d ff 61 fa 	call 80002d3a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
8000387c:	19 c2 2c 00 	ld.w %d2,[%a12]44
80003880:	91 10 00 27 	movh.a %a2,28673
80003884:	19 23 00 10 	ld.w %d3,[%a2]64 <70010040 <uxTopReadyPriority>>
80003888:	7f 23 04 80 	jge.u %d3,%d2,80003890 <xTaskIncrementTick+0x10c>
8000388c:	59 22 00 10 	st.w [%a2]64 <70010040 <uxTopReadyPriority>>,%d2
80003890:	60 95       	mov.a %a5,%d9
80003892:	91 10 00 47 	movh.a %a4,28673
80003896:	d9 44 3c 20 	lea %a4,[%a4]188 <700100bc <pxReadyTasksLists>>
8000389a:	53 42 21 30 	mul %d3,%d2,20
8000389e:	01 43 00 46 	addsc.a %a4,%a4,%d3,0
800038a2:	6d ff 19 fa 	call 80002cd4 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800038a6:	19 c3 2c 00 	ld.w %d3,[%a12]44
800038aa:	91 10 00 27 	movh.a %a2,28673
800038ae:	99 22 34 40 	ld.a %a2,[%a2]308 <70010134 <pxCurrentTCB>>
800038b2:	19 22 2c 00 	ld.w %d2,[%a2]44 <70010134 <pxCurrentTCB>>
800038b6:	7f 23 c0 ff 	jge.u %d3,%d2,80003836 <xTaskIncrementTick+0xb2>
800038ba:	1d ff bf ff 	j 80003838 <xTaskIncrementTick+0xb4>
BaseType_t xSwitchRequired = pdFALSE;
800038be:	82 0a       	mov %d10,0
800038c0:	1d ff bc ff 	j 80003838 <xTaskIncrementTick+0xb4>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
800038c4:	91 10 00 27 	movh.a %a2,28673
800038c8:	82 f2       	mov %d2,-1
800038ca:	59 22 28 00 	st.w [%a2]40 <70010028 <xNextTaskUnblockTime>>,%d2
					break;
800038ce:	1d ff a0 ff 	j 8000380e <xTaskIncrementTick+0x8a>
						xNextTaskUnblockTime = xItemValue;
800038d2:	91 10 00 27 	movh.a %a2,28673
800038d6:	59 22 28 00 	st.w [%a2]40 <70010028 <xNextTaskUnblockTime>>,%d2
						break;
800038da:	1d ff 9a ff 	j 8000380e <xTaskIncrementTick+0x8a>
		++uxPendedTicks;
800038de:	91 10 00 27 	movh.a %a2,28673
800038e2:	19 22 38 00 	ld.w %d2,[%a2]56 <70010038 <uxPendedTicks>>
800038e6:	c2 12       	add %d2,1
800038e8:	59 22 38 00 	st.w [%a2]56 <70010038 <uxPendedTicks>>,%d2
BaseType_t xSwitchRequired = pdFALSE;
800038ec:	82 0a       	mov %d10,0
		if( xYieldPending != pdFALSE )
800038ee:	91 10 00 27 	movh.a %a2,28673
800038f2:	19 22 34 00 	ld.w %d2,[%a2]52 <70010034 <xYieldPending>>
800038f6:	df 02 03 00 	jeq %d2,0,800038fc <xTaskIncrementTick+0x178>
			xSwitchRequired = pdTRUE;
800038fa:	82 1a       	mov %d10,1
}
800038fc:	02 a2       	mov %d2,%d10
800038fe:	00 90       	ret 

80003900 <vTaskSwitchContext>:
{
80003900:	40 ae       	mov.aa %a14,%sp
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
80003902:	91 10 00 27 	movh.a %a2,28673
80003906:	19 22 20 00 	ld.w %d2,[%a2]32 <70010020 <uxSchedulerSuspended>>
8000390a:	df 02 08 00 	jeq %d2,0,8000391a <vTaskSwitchContext+0x1a>
		xYieldPending = pdTRUE;
8000390e:	91 10 00 27 	movh.a %a2,28673
80003912:	82 12       	mov %d2,1
80003914:	59 22 34 00 	st.w [%a2]52 <70010034 <xYieldPending>>,%d2
80003918:	00 90       	ret 
		xYieldPending = pdFALSE;
8000391a:	91 10 00 27 	movh.a %a2,28673
8000391e:	82 02       	mov %d2,0
80003920:	59 22 34 00 	st.w [%a2]52 <70010034 <xYieldPending>>,%d2
		taskSELECT_HIGHEST_PRIORITY_TASK();
80003924:	91 10 00 27 	movh.a %a2,28673
80003928:	19 22 00 10 	ld.w %d2,[%a2]64 <70010040 <uxTopReadyPriority>>
8000392c:	91 10 00 27 	movh.a %a2,28673
80003930:	80 23       	mov.d %d3,%a2
80003932:	1b c3 0b 30 	addi %d3,%d3,188
80003936:	13 42 21 33 	madd %d3,%d3,%d2,20
8000393a:	60 32       	mov.a %a2,%d3
8000393c:	54 23       	ld.w %d3,[%a2]
8000393e:	df 03 18 80 	jne %d3,0,8000396e <vTaskSwitchContext+0x6e>
80003942:	df 02 05 00 	jeq %d2,0,8000394c <vTaskSwitchContext+0x4c>
80003946:	c2 f2       	add %d2,-1
80003948:	1d ff f2 ff 	j 8000392c <vTaskSwitchContext+0x2c>
  __asm__ volatile ("disable" ::: "memory");
8000394c:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80003950:	4d c0 e2 2f 	mfcr %d2,$icr
80003954:	8f f2 cf 21 	andn %d2,%d2,255
80003958:	8f 02 44 21 	or %d2,%d2,64
8000395c:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
80003960:	0d 00 c0 04 	isync 
80003964:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80003968:	00 a0       	debug 
8000396a:	1d 00 00 00 	j 8000396a <vTaskSwitchContext+0x6a>
8000396e:	91 10 00 47 	movh.a %a4,28673
80003972:	d9 44 3c 20 	lea %a4,[%a4]188 <700100bc <pxReadyTasksLists>>
80003976:	53 42 21 30 	mul %d3,%d2,20
8000397a:	99 23 04 00 	ld.a %a3,[%a2]4
8000397e:	b0 43       	add.a %a3,4
80003980:	d4 33       	ld.a %a3,[%a3]
80003982:	b5 23 04 00 	st.a [%a2]4,%a3
80003986:	1b 83 00 30 	addi %d3,%d3,8
8000398a:	80 44       	mov.d %d4,%a4
8000398c:	42 43       	add %d3,%d4
8000398e:	80 34       	mov.d %d4,%a3
80003990:	5f 34 17 00 	jeq %d4,%d3,800039be <vTaskSwitchContext+0xbe>
80003994:	91 10 00 27 	movh.a %a2,28673
80003998:	80 23       	mov.d %d3,%a2
8000399a:	1b c3 0b 30 	addi %d3,%d3,188
8000399e:	13 42 21 33 	madd %d3,%d3,%d2,20
800039a2:	60 32       	mov.a %a2,%d3
800039a4:	b0 42       	add.a %a2,4
800039a6:	d4 22       	ld.a %a2,[%a2]
800039a8:	19 23 0c 00 	ld.w %d3,[%a2]12
800039ac:	91 10 00 27 	movh.a %a2,28673
800039b0:	59 23 34 40 	st.w [%a2]308 <70010134 <pxCurrentTCB>>,%d3
800039b4:	91 10 00 27 	movh.a %a2,28673
800039b8:	59 22 00 10 	st.w [%a2]64 <70010040 <uxTopReadyPriority>>,%d2
}
800039bc:	00 90       	ret 
		taskSELECT_HIGHEST_PRIORITY_TASK();
800039be:	19 34 04 00 	ld.w %d4,[%a3]4
800039c2:	80 43       	mov.d %d3,%a4
800039c4:	13 42 21 33 	madd %d3,%d3,%d2,20
800039c8:	60 32       	mov.a %a2,%d3
800039ca:	59 24 04 00 	st.w [%a2]4,%d4
800039ce:	1d ff e3 ff 	j 80003994 <vTaskSwitchContext+0x94>

800039d2 <vTaskPlaceOnEventList>:
{
800039d2:	40 ae       	mov.aa %a14,%sp
800039d4:	02 48       	mov %d8,%d4
	configASSERT( pxEventList );
800039d6:	bd 04 0f 00 	jz.a %a4,800039f4 <vTaskPlaceOnEventList+0x22>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
800039da:	91 10 00 57 	movh.a %a5,28673
800039de:	99 55 34 40 	ld.a %a5,[%a5]308 <70010134 <pxCurrentTCB>>
800039e2:	d9 55 18 00 	lea %a5,[%a5]24 <70010134 <pxCurrentTCB>>
800039e6:	6d ff 8a f9 	call 80002cfa <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
800039ea:	82 15       	mov %d5,1
800039ec:	02 84       	mov %d4,%d8
800039ee:	6d ff 72 fe 	call 800036d2 <prvAddCurrentTaskToDelayedList>
}
800039f2:	00 90       	ret 
  __asm__ volatile ("disable" ::: "memory");
800039f4:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
800039f8:	4d c0 e2 2f 	mfcr %d2,$icr
	configASSERT( pxEventList );
800039fc:	8f f2 cf 21 	andn %d2,%d2,255
80003a00:	8f 02 44 21 	or %d2,%d2,64
80003a04:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
80003a08:	0d 00 c0 04 	isync 
80003a0c:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80003a10:	00 a0       	debug 
80003a12:	1d 00 00 00 	j 80003a12 <vTaskPlaceOnEventList+0x40>

80003a16 <vTaskPlaceOnEventListRestricted>:
	{
80003a16:	40 ae       	mov.aa %a14,%sp
80003a18:	02 49       	mov %d9,%d4
80003a1a:	02 58       	mov %d8,%d5
		configASSERT( pxEventList );
80003a1c:	bd 04 12 00 	jz.a %a4,80003a40 <vTaskPlaceOnEventListRestricted+0x2a>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
80003a20:	91 10 00 57 	movh.a %a5,28673
80003a24:	99 55 34 40 	ld.a %a5,[%a5]308 <70010134 <pxCurrentTCB>>
80003a28:	d9 55 18 00 	lea %a5,[%a5]24 <70010134 <pxCurrentTCB>>
80003a2c:	6d ff 54 f9 	call 80002cd4 <vListInsertEnd>
		if( xWaitIndefinitely != pdFALSE )
80003a30:	df 08 03 00 	jeq %d8,0,80003a36 <vTaskPlaceOnEventListRestricted+0x20>
			xTicksToWait = portMAX_DELAY;
80003a34:	82 f9       	mov %d9,-1
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
80003a36:	02 85       	mov %d5,%d8
80003a38:	02 94       	mov %d4,%d9
80003a3a:	6d ff 4c fe 	call 800036d2 <prvAddCurrentTaskToDelayedList>
	}
80003a3e:	00 90       	ret 
  __asm__ volatile ("disable" ::: "memory");
80003a40:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80003a44:	4d c0 e2 2f 	mfcr %d2,$icr
		configASSERT( pxEventList );
80003a48:	8f f2 cf 21 	andn %d2,%d2,255
80003a4c:	8f 02 44 21 	or %d2,%d2,64
80003a50:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
80003a54:	0d 00 c0 04 	isync 
80003a58:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80003a5c:	00 a0       	debug 
80003a5e:	1d 00 00 00 	j 80003a5e <vTaskPlaceOnEventListRestricted+0x48>

80003a62 <xTaskRemoveFromEventList>:
{
80003a62:	40 ae       	mov.aa %a14,%sp
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80003a64:	99 42 0c 00 	ld.a %a2,[%a4]12
80003a68:	99 2c 0c 00 	ld.a %a12,[%a2]12
	configASSERT( pxUnblockedTCB );
80003a6c:	bd 0c 39 00 	jz.a %a12,80003ade <xTaskRemoveFromEventList+0x7c>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
80003a70:	80 c2       	mov.d %d2,%a12
80003a72:	1b 82 01 80 	addi %d8,%d2,24
80003a76:	60 84       	mov.a %a4,%d8
80003a78:	6d ff 61 f9 	call 80002d3a <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80003a7c:	91 10 00 27 	movh.a %a2,28673
80003a80:	19 22 20 00 	ld.w %d2,[%a2]32 <70010020 <uxSchedulerSuspended>>
80003a84:	df 02 3e 80 	jne %d2,0,80003b00 <xTaskRemoveFromEventList+0x9e>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
80003a88:	80 c2       	mov.d %d2,%a12
80003a8a:	1b 42 00 80 	addi %d8,%d2,4
80003a8e:	60 84       	mov.a %a4,%d8
80003a90:	6d ff 55 f9 	call 80002d3a <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
80003a94:	19 c2 2c 00 	ld.w %d2,[%a12]44
80003a98:	91 10 00 27 	movh.a %a2,28673
80003a9c:	19 23 00 10 	ld.w %d3,[%a2]64 <70010040 <uxTopReadyPriority>>
80003aa0:	7f 23 04 80 	jge.u %d3,%d2,80003aa8 <xTaskRemoveFromEventList+0x46>
80003aa4:	59 22 00 10 	st.w [%a2]64 <70010040 <uxTopReadyPriority>>,%d2
80003aa8:	60 85       	mov.a %a5,%d8
80003aaa:	91 10 00 47 	movh.a %a4,28673
80003aae:	d9 44 3c 20 	lea %a4,[%a4]188 <700100bc <pxReadyTasksLists>>
80003ab2:	53 42 21 30 	mul %d3,%d2,20
80003ab6:	01 43 00 46 	addsc.a %a4,%a4,%d3,0
80003aba:	6d ff 0d f9 	call 80002cd4 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
80003abe:	19 c2 2c 00 	ld.w %d2,[%a12]44
80003ac2:	91 10 00 27 	movh.a %a2,28673
80003ac6:	99 22 34 40 	ld.a %a2,[%a2]308 <70010134 <pxCurrentTCB>>
80003aca:	19 23 2c 00 	ld.w %d3,[%a2]44 <70010134 <pxCurrentTCB>>
80003ace:	7f 23 22 80 	jge.u %d3,%d2,80003b12 <xTaskRemoveFromEventList+0xb0>
		xYieldPending = pdTRUE;
80003ad2:	82 12       	mov %d2,1
80003ad4:	91 10 00 27 	movh.a %a2,28673
80003ad8:	59 22 34 00 	st.w [%a2]52 <70010034 <xYieldPending>>,%d2
80003adc:	00 90       	ret 
  __asm__ volatile ("disable" ::: "memory");
80003ade:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80003ae2:	4d c0 e2 2f 	mfcr %d2,$icr
	configASSERT( pxUnblockedTCB );
80003ae6:	8f f2 cf 21 	andn %d2,%d2,255
80003aea:	8f 02 44 21 	or %d2,%d2,64
80003aee:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
80003af2:	0d 00 c0 04 	isync 
80003af6:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80003afa:	00 a0       	debug 
80003afc:	1d 00 00 00 	j 80003afc <xTaskRemoveFromEventList+0x9a>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80003b00:	60 85       	mov.a %a5,%d8
80003b02:	91 10 00 47 	movh.a %a4,28673
80003b06:	d9 44 38 10 	lea %a4,[%a4]120 <70010078 <xPendingReadyList>>
80003b0a:	6d ff e5 f8 	call 80002cd4 <vListInsertEnd>
80003b0e:	1d ff d8 ff 	j 80003abe <xTaskRemoveFromEventList+0x5c>
		xReturn = pdFALSE;
80003b12:	82 02       	mov %d2,0
}
80003b14:	00 90       	ret 

80003b16 <vTaskSetTimeOutState>:
{
80003b16:	40 ae       	mov.aa %a14,%sp
	configASSERT( pxTimeOut );
80003b18:	bd 04 0e 00 	jz.a %a4,80003b34 <vTaskSetTimeOutState+0x1e>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80003b1c:	91 10 00 27 	movh.a %a2,28673
80003b20:	19 22 30 00 	ld.w %d2,[%a2]48 <70010030 <xNumOfOverflows>>
80003b24:	74 42       	st.w [%a4],%d2
	pxTimeOut->xTimeOnEntering = xTickCount;
80003b26:	91 10 00 27 	movh.a %a2,28673
80003b2a:	19 22 04 10 	ld.w %d2,[%a2]68 <70010044 <xTickCount>>
80003b2e:	59 42 04 00 	st.w [%a4]4 <70010044 <xTickCount>>,%d2
}
80003b32:	00 90       	ret 
  __asm__ volatile ("disable" ::: "memory");
80003b34:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80003b38:	4d c0 e2 2f 	mfcr %d2,$icr
	configASSERT( pxTimeOut );
80003b3c:	8f f2 cf 21 	andn %d2,%d2,255
80003b40:	8f 02 44 21 	or %d2,%d2,64
80003b44:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
80003b48:	0d 00 c0 04 	isync 
80003b4c:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80003b50:	00 a0       	debug 
80003b52:	1d 00 00 00 	j 80003b52 <vTaskSetTimeOutState+0x3c>

80003b56 <vTaskMissedYield>:
{
80003b56:	40 ae       	mov.aa %a14,%sp
	xYieldPending = pdTRUE;
80003b58:	91 10 00 27 	movh.a %a2,28673
80003b5c:	82 12       	mov %d2,1
80003b5e:	59 22 34 00 	st.w [%a2]52 <70010034 <xYieldPending>>,%d2
}
80003b62:	00 90       	ret 

80003b64 <xTaskGetSchedulerState>:
	{
80003b64:	40 ae       	mov.aa %a14,%sp
		if( xSchedulerRunning == pdFALSE )
80003b66:	91 10 00 27 	movh.a %a2,28673
80003b6a:	19 22 3c 00 	ld.w %d2,[%a2]60 <7001003c <xSchedulerRunning>>
80003b6e:	df 02 0c 00 	jeq %d2,0,80003b86 <xTaskGetSchedulerState+0x22>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80003b72:	91 10 00 27 	movh.a %a2,28673
80003b76:	19 22 20 00 	ld.w %d2,[%a2]32 <70010020 <uxSchedulerSuspended>>
80003b7a:	df 02 04 00 	jeq %d2,0,80003b82 <xTaskGetSchedulerState+0x1e>
				xReturn = taskSCHEDULER_SUSPENDED;
80003b7e:	82 02       	mov %d2,0
	}
80003b80:	00 90       	ret 
				xReturn = taskSCHEDULER_RUNNING;
80003b82:	82 22       	mov %d2,2
80003b84:	00 90       	ret 
			xReturn = taskSCHEDULER_NOT_STARTED;
80003b86:	82 12       	mov %d2,1
80003b88:	00 90       	ret 

80003b8a <vTaskPriorityInherit>:
	{
80003b8a:	40 ae       	mov.aa %a14,%sp
80003b8c:	40 4c       	mov.aa %a12,%a4
		if( pxMutexHolder != NULL )
80003b8e:	bd 04 4d 00 	jz.a %a4,80003c28 <vTaskPriorityInherit+0x9e>
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80003b92:	19 42 2c 00 	ld.w %d2,[%a4]44
80003b96:	91 10 00 27 	movh.a %a2,28673
80003b9a:	99 22 34 40 	ld.a %a2,[%a2]308 <70010134 <pxCurrentTCB>>
80003b9e:	19 23 2c 00 	ld.w %d3,[%a2]44 <70010134 <pxCurrentTCB>>
80003ba2:	7f 32 43 80 	jge.u %d2,%d3,80003c28 <vTaskPriorityInherit+0x9e>
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
80003ba6:	19 43 18 00 	ld.w %d3,[%a4]24
80003baa:	bf 03 0c 00 	jlt %d3,0,80003bc2 <vTaskPriorityInherit+0x38>
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80003bae:	91 10 00 27 	movh.a %a2,28673
80003bb2:	99 22 34 40 	ld.a %a2,[%a2]308 <70010134 <pxCurrentTCB>>
80003bb6:	19 23 2c 00 	ld.w %d3,[%a2]44 <70010134 <pxCurrentTCB>>
80003bba:	8b 63 00 31 	rsub %d3,%d3,6
80003bbe:	59 43 18 00 	st.w [%a4]24,%d3
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
80003bc2:	19 c4 14 00 	ld.w %d4,[%a12]20
80003bc6:	91 10 00 27 	movh.a %a2,28673
80003bca:	80 23       	mov.d %d3,%a2
80003bcc:	1b c3 0b 30 	addi %d3,%d3,188
80003bd0:	13 42 21 23 	madd %d2,%d3,%d2,20
80003bd4:	5f 24 0b 00 	jeq %d4,%d2,80003bea <vTaskPriorityInherit+0x60>
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80003bd8:	91 10 00 27 	movh.a %a2,28673
80003bdc:	99 22 34 40 	ld.a %a2,[%a2]308 <70010134 <pxCurrentTCB>>
80003be0:	19 22 2c 00 	ld.w %d2,[%a2]44 <70010134 <pxCurrentTCB>>
80003be4:	59 c2 2c 00 	st.w [%a12]44 <70010134 <pxCurrentTCB>>,%d2
80003be8:	00 90       	ret 
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80003bea:	80 c2       	mov.d %d2,%a12
80003bec:	1b 42 00 80 	addi %d8,%d2,4
80003bf0:	60 84       	mov.a %a4,%d8
80003bf2:	6d ff a4 f8 	call 80002d3a <uxListRemove>
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80003bf6:	91 10 00 27 	movh.a %a2,28673
80003bfa:	99 22 34 40 	ld.a %a2,[%a2]308 <70010134 <pxCurrentTCB>>
80003bfe:	19 22 2c 00 	ld.w %d2,[%a2]44 <70010134 <pxCurrentTCB>>
80003c02:	59 c2 2c 00 	st.w [%a12]44 <70010134 <pxCurrentTCB>>,%d2
					prvAddTaskToReadyList( pxTCB );
80003c06:	91 10 00 27 	movh.a %a2,28673
80003c0a:	19 23 00 10 	ld.w %d3,[%a2]64 <70010040 <uxTopReadyPriority>>
80003c0e:	3f 23 0e 80 	jlt.u %d3,%d2,80003c2a <vTaskPriorityInherit+0xa0>
80003c12:	60 85       	mov.a %a5,%d8
80003c14:	91 10 00 47 	movh.a %a4,28673
80003c18:	d9 44 3c 20 	lea %a4,[%a4]188 <700100bc <pxReadyTasksLists>>
80003c1c:	53 42 21 30 	mul %d3,%d2,20
80003c20:	01 43 00 46 	addsc.a %a4,%a4,%d3,0
80003c24:	6d ff 58 f8 	call 80002cd4 <vListInsertEnd>
	}
80003c28:	00 90       	ret 
					prvAddTaskToReadyList( pxTCB );
80003c2a:	91 10 00 27 	movh.a %a2,28673
80003c2e:	59 22 00 10 	st.w [%a2]64 <70010040 <uxTopReadyPriority>>,%d2
80003c32:	1d ff f0 ff 	j 80003c12 <vTaskPriorityInherit+0x88>

80003c36 <xTaskPriorityDisinherit>:
	{
80003c36:	40 ae       	mov.aa %a14,%sp
80003c38:	40 4c       	mov.aa %a12,%a4
		if( pxMutexHolder != NULL )
80003c3a:	bd 04 5f 00 	jz.a %a4,80003cf8 <xTaskPriorityDisinherit+0xc2>
			configASSERT( pxTCB == pxCurrentTCB );
80003c3e:	91 10 00 27 	movh.a %a2,28673
80003c42:	19 22 34 40 	ld.w %d2,[%a2]308 <70010134 <pxCurrentTCB>>
80003c46:	80 43       	mov.d %d3,%a4
80003c48:	5f 32 13 00 	jeq %d2,%d3,80003c6e <xTaskPriorityDisinherit+0x38>
  __asm__ volatile ("disable" ::: "memory");
80003c4c:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80003c50:	4d c0 e2 2f 	mfcr %d2,$icr
80003c54:	8f f2 cf 21 	andn %d2,%d2,255
80003c58:	8f 02 44 21 	or %d2,%d2,64
80003c5c:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
80003c60:	0d 00 c0 04 	isync 
80003c64:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80003c68:	00 a0       	debug 
80003c6a:	1d 00 00 00 	j 80003c6a <xTaskPriorityDisinherit+0x34>
			configASSERT( pxTCB->uxMutexesHeld );
80003c6e:	19 42 1c 10 	ld.w %d2,[%a4]92
80003c72:	df 02 13 80 	jne %d2,0,80003c98 <xTaskPriorityDisinherit+0x62>
  __asm__ volatile ("disable" ::: "memory");
80003c76:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80003c7a:	4d c0 e2 2f 	mfcr %d2,$icr
80003c7e:	8f f2 cf 21 	andn %d2,%d2,255
80003c82:	8f 02 44 21 	or %d2,%d2,64
80003c86:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
80003c8a:	0d 00 c0 04 	isync 
80003c8e:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80003c92:	00 a0       	debug 
80003c94:	1d 00 00 00 	j 80003c94 <xTaskPriorityDisinherit+0x5e>
			( pxTCB->uxMutexesHeld )--;
80003c98:	c2 f2       	add %d2,-1
80003c9a:	59 42 1c 10 	st.w [%a4]92,%d2
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80003c9e:	19 44 2c 00 	ld.w %d4,[%a4]44
80003ca2:	19 43 18 10 	ld.w %d3,[%a4]88
80003ca6:	5f 34 2b 00 	jeq %d4,%d3,80003cfc <xTaskPriorityDisinherit+0xc6>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
80003caa:	df 02 04 00 	jeq %d2,0,80003cb2 <xTaskPriorityDisinherit+0x7c>
	BaseType_t xReturn = pdFALSE;
80003cae:	82 02       	mov %d2,0
	}
80003cb0:	00 90       	ret 
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80003cb2:	80 42       	mov.d %d2,%a4
80003cb4:	1b 42 00 80 	addi %d8,%d2,4
80003cb8:	60 84       	mov.a %a4,%d8
80003cba:	6d ff 40 f8 	call 80002d3a <uxListRemove>
					pxTCB->uxPriority = pxTCB->uxBasePriority;
80003cbe:	19 c2 18 10 	ld.w %d2,[%a12]88
80003cc2:	59 c2 2c 00 	st.w [%a12]44,%d2
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80003cc6:	8b 62 00 31 	rsub %d3,%d2,6
80003cca:	59 c3 18 00 	st.w [%a12]24,%d3
					prvAddTaskToReadyList( pxTCB );
80003cce:	91 10 00 27 	movh.a %a2,28673
80003cd2:	19 23 00 10 	ld.w %d3,[%a2]64 <70010040 <uxTopReadyPriority>>
80003cd6:	7f 23 04 80 	jge.u %d3,%d2,80003cde <xTaskPriorityDisinherit+0xa8>
80003cda:	59 22 00 10 	st.w [%a2]64 <70010040 <uxTopReadyPriority>>,%d2
80003cde:	60 85       	mov.a %a5,%d8
80003ce0:	91 10 00 47 	movh.a %a4,28673
80003ce4:	d9 44 3c 20 	lea %a4,[%a4]188 <700100bc <pxReadyTasksLists>>
80003ce8:	53 42 21 30 	mul %d3,%d2,20
80003cec:	01 43 00 46 	addsc.a %a4,%a4,%d3,0
80003cf0:	6d ff f2 f7 	call 80002cd4 <vListInsertEnd>
					xReturn = pdTRUE;
80003cf4:	82 12       	mov %d2,1
80003cf6:	00 90       	ret 
	BaseType_t xReturn = pdFALSE;
80003cf8:	82 02       	mov %d2,0
80003cfa:	00 90       	ret 
80003cfc:	82 02       	mov %d2,0
80003cfe:	00 90       	ret 

80003d00 <vTaskEnterCritical>:
	{
80003d00:	40 ae       	mov.aa %a14,%sp
  __asm__ volatile ("disable" ::: "memory");
80003d02:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80003d06:	4d c0 e2 2f 	mfcr %d2,$icr
		portDISABLE_INTERRUPTS();
80003d0a:	8f f2 cf 21 	andn %d2,%d2,255
80003d0e:	8f 02 44 21 	or %d2,%d2,64
80003d12:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
80003d16:	0d 00 c0 04 	isync 
80003d1a:	0d 00 00 03 	enable 
		if( xSchedulerRunning != pdFALSE )
80003d1e:	91 10 00 27 	movh.a %a2,28673
80003d22:	19 22 3c 00 	ld.w %d2,[%a2]60 <7001003c <xSchedulerRunning>>
80003d26:	df 02 0e 00 	jeq %d2,0,80003d42 <vTaskEnterCritical+0x42>
			( pxCurrentTCB->uxCriticalNesting )++;
80003d2a:	91 10 00 37 	movh.a %a3,28673
80003d2e:	99 32 34 40 	ld.a %a2,[%a3]308 <70010134 <pxCurrentTCB>>
80003d32:	d9 24 14 10 	lea %a4,[%a2]84 <70010134 <pxCurrentTCB>>
80003d36:	19 22 14 10 	ld.w %d2,[%a2]84 <70010134 <pxCurrentTCB>>
80003d3a:	c2 12       	add %d2,1
80003d3c:	74 42       	st.w [%a4],%d2
			if( pxCurrentTCB->uxCriticalNesting == 1 )
80003d3e:	19 32 34 40 	ld.w %d2,[%a3]308 <70010134 <pxCurrentTCB>>
	}
80003d42:	00 90       	ret 

80003d44 <vTaskExitCritical>:
	{
80003d44:	40 ae       	mov.aa %a14,%sp
		if( xSchedulerRunning != pdFALSE )
80003d46:	91 10 00 27 	movh.a %a2,28673
80003d4a:	19 22 3c 00 	ld.w %d2,[%a2]60 <7001003c <xSchedulerRunning>>
80003d4e:	df 02 26 00 	jeq %d2,0,80003d9a <vTaskExitCritical+0x56>
			if( pxCurrentTCB->uxCriticalNesting > 0U )
80003d52:	91 10 00 27 	movh.a %a2,28673
80003d56:	99 22 34 40 	ld.a %a2,[%a2]308 <70010134 <pxCurrentTCB>>
80003d5a:	19 22 14 10 	ld.w %d2,[%a2]84 <70010134 <pxCurrentTCB>>
80003d5e:	df 02 1e 00 	jeq %d2,0,80003d9a <vTaskExitCritical+0x56>
				( pxCurrentTCB->uxCriticalNesting )--;
80003d62:	91 10 00 37 	movh.a %a3,28673
80003d66:	99 32 34 40 	ld.a %a2,[%a3]308 <70010134 <pxCurrentTCB>>
80003d6a:	d9 24 14 10 	lea %a4,[%a2]84 <70010134 <pxCurrentTCB>>
80003d6e:	19 22 14 10 	ld.w %d2,[%a2]84 <70010134 <pxCurrentTCB>>
80003d72:	c2 f2       	add %d2,-1
80003d74:	74 42       	st.w [%a4],%d2
				if( pxCurrentTCB->uxCriticalNesting == 0U )
80003d76:	99 33 34 40 	ld.a %a3,[%a3]308 <70010134 <pxCurrentTCB>>
80003d7a:	19 32 14 10 	ld.w %d2,[%a3]84 <70010134 <pxCurrentTCB>>
80003d7e:	df 02 0e 80 	jne %d2,0,80003d9a <vTaskExitCritical+0x56>
  __asm__ volatile ("disable" ::: "memory");
80003d82:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80003d86:	4d c0 e2 2f 	mfcr %d2,$icr
					portENABLE_INTERRUPTS();
80003d8a:	8f f2 cf 21 	andn %d2,%d2,255
80003d8e:	cd c2 e2 0f 	mtcr $icr,%d2
80003d92:	0d 00 c0 04 	isync 
80003d96:	0d 00 00 03 	enable 
	}
80003d9a:	00 90       	ret 

80003d9c <prvAddNewTaskToReadyList>:
{
80003d9c:	40 ae       	mov.aa %a14,%sp
80003d9e:	40 4c       	mov.aa %a12,%a4
	taskENTER_CRITICAL();
80003da0:	6d ff b0 ff 	call 80003d00 <vTaskEnterCritical>
		uxCurrentNumberOfTasks++;
80003da4:	91 10 00 27 	movh.a %a2,28673
80003da8:	19 22 08 10 	ld.w %d2,[%a2]72 <70010048 <uxCurrentNumberOfTasks>>
80003dac:	c2 12       	add %d2,1
80003dae:	59 22 08 10 	st.w [%a2]72 <70010048 <uxCurrentNumberOfTasks>>,%d2
		if( pxCurrentTCB == NULL )
80003db2:	91 10 00 27 	movh.a %a2,28673
80003db6:	19 22 34 40 	ld.w %d2,[%a2]308 <70010134 <pxCurrentTCB>>
80003dba:	df 02 18 00 	jeq %d2,0,80003dea <prvAddNewTaskToReadyList+0x4e>
			if( xSchedulerRunning == pdFALSE )
80003dbe:	91 10 00 27 	movh.a %a2,28673
80003dc2:	19 22 3c 00 	ld.w %d2,[%a2]60 <7001003c <xSchedulerRunning>>
80003dc6:	df 02 1a 80 	jne %d2,0,80003dfa <prvAddNewTaskToReadyList+0x5e>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
80003dca:	91 10 00 27 	movh.a %a2,28673
80003dce:	99 22 34 40 	ld.a %a2,[%a2]308 <70010134 <pxCurrentTCB>>
80003dd2:	19 22 2c 00 	ld.w %d2,[%a2]44 <70010134 <pxCurrentTCB>>
80003dd6:	19 c3 2c 00 	ld.w %d3,[%a12]44 <70010134 <pxCurrentTCB>>
80003dda:	3f 23 10 80 	jlt.u %d3,%d2,80003dfa <prvAddNewTaskToReadyList+0x5e>
					pxCurrentTCB = pxNewTCB;
80003dde:	91 10 00 27 	movh.a %a2,28673
80003de2:	b5 2c 34 40 	st.a [%a2]308 <70010134 <pxCurrentTCB>>,%a12
80003de6:	1d 00 0a 00 	j 80003dfa <prvAddNewTaskToReadyList+0x5e>
			pxCurrentTCB = pxNewTCB;
80003dea:	b5 2c 34 40 	st.a [%a2]308 <70010134 <pxCurrentTCB>>,%a12
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
80003dee:	91 10 00 27 	movh.a %a2,28673
80003df2:	19 22 08 10 	ld.w %d2,[%a2]72 <70010048 <uxCurrentNumberOfTasks>>
80003df6:	df 12 35 00 	jeq %d2,1,80003e60 <prvAddNewTaskToReadyList+0xc4>
		uxTaskNumber++;
80003dfa:	91 10 00 27 	movh.a %a2,28673
80003dfe:	d9 23 2c 00 	lea %a3,[%a2]44 <7001002c <uxTaskNumber>>
80003e02:	54 32       	ld.w %d2,[%a3]
80003e04:	c2 12       	add %d2,1
80003e06:	59 22 2c 00 	st.w [%a2]44 <7001002c <uxTaskNumber>>,%d2
		prvAddTaskToReadyList( pxNewTCB );
80003e0a:	19 c2 2c 00 	ld.w %d2,[%a12]44 <7001002c <uxTaskNumber>>
80003e0e:	91 10 00 27 	movh.a %a2,28673
80003e12:	19 23 00 10 	ld.w %d3,[%a2]64 <70010040 <uxTopReadyPriority>>
80003e16:	7f 23 04 80 	jge.u %d3,%d2,80003e1e <prvAddNewTaskToReadyList+0x82>
80003e1a:	59 22 00 10 	st.w [%a2]64 <70010040 <uxTopReadyPriority>>,%d2
80003e1e:	d9 c5 04 00 	lea %a5,[%a12]4 <70010040 <uxTopReadyPriority>>
80003e22:	91 10 00 47 	movh.a %a4,28673
80003e26:	d9 44 3c 20 	lea %a4,[%a4]188 <700100bc <pxReadyTasksLists>>
80003e2a:	53 42 21 30 	mul %d3,%d2,20
80003e2e:	01 43 00 46 	addsc.a %a4,%a4,%d3,0
80003e32:	6d ff 51 f7 	call 80002cd4 <vListInsertEnd>
	taskEXIT_CRITICAL();
80003e36:	6d ff 87 ff 	call 80003d44 <vTaskExitCritical>
	if( xSchedulerRunning != pdFALSE )
80003e3a:	91 10 00 27 	movh.a %a2,28673
80003e3e:	19 22 3c 00 	ld.w %d2,[%a2]60 <7001003c <xSchedulerRunning>>
80003e42:	df 02 0e 00 	jeq %d2,0,80003e5e <prvAddNewTaskToReadyList+0xc2>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
80003e46:	91 10 00 27 	movh.a %a2,28673
80003e4a:	99 22 34 40 	ld.a %a2,[%a2]308 <70010134 <pxCurrentTCB>>
80003e4e:	19 23 2c 00 	ld.w %d3,[%a2]44 <70010134 <pxCurrentTCB>>
80003e52:	19 c2 2c 00 	ld.w %d2,[%a12]44 <70010134 <pxCurrentTCB>>
80003e56:	7f 23 04 80 	jge.u %d3,%d2,80003e5e <prvAddNewTaskToReadyList+0xc2>
			taskYIELD_IF_USING_PREEMPTION();
80003e5a:	ad 00 80 00 	syscall 0
}
80003e5e:	00 90       	ret 
				prvInitialiseTaskLists();
80003e60:	6d ff f3 fb 	call 80003646 <prvInitialiseTaskLists>
80003e64:	1d ff cb ff 	j 80003dfa <prvAddNewTaskToReadyList+0x5e>

80003e68 <xTaskCreate>:
	{
80003e68:	40 ae       	mov.aa %a14,%sp
80003e6a:	20 08       	sub.a %sp,8
80003e6c:	80 4a       	mov.d %d10,%a4
80003e6e:	80 5b       	mov.d %d11,%a5
80003e70:	80 6c       	mov.d %d12,%a6
80003e72:	02 5d       	mov %d13,%d5
80003e74:	80 7e       	mov.d %d14,%a7
80003e76:	37 04 70 80 	extr.u %d8,%d4,0,16
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80003e7a:	8f 28 00 40 	sh %d4,%d8,2
80003e7e:	6d ff 58 f4 	call 8000272e <pvPortMalloc>
80003e82:	80 29       	mov.d %d9,%a2
			if( pxStack != NULL )
80003e84:	df 09 23 00 	jeq %d9,0,80003eca <xTaskCreate+0x62>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
80003e88:	3b 80 06 40 	mov %d4,104
80003e8c:	6d ff 51 f4 	call 8000272e <pvPortMalloc>
80003e90:	40 2c       	mov.aa %a12,%a2
				if( pxNewTCB != NULL )
80003e92:	bd 02 17 00 	jz.a %a2,80003ec0 <xTaskCreate+0x58>
					pxNewTCB->pxStack = pxStack;
80003e96:	59 29 30 00 	st.w [%a2]48,%d9
		if( pxNewTCB != NULL )
80003e9a:	bd 0c 1a 00 	jz.a %a12,80003ece <xTaskCreate+0x66>
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
80003e9e:	82 02       	mov %d2,0
80003ea0:	59 a2 04 00 	st.w [%sp]4,%d2
80003ea4:	f4 ac       	st.a [%sp],%a12
80003ea6:	60 e7       	mov.a %a7,%d14
80003ea8:	02 d5       	mov %d5,%d13
80003eaa:	60 c6       	mov.a %a6,%d12
80003eac:	02 84       	mov %d4,%d8
80003eae:	60 b5       	mov.a %a5,%d11
80003eb0:	60 a4       	mov.a %a4,%d10
80003eb2:	6d ff 7c fb 	call 800035aa <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
80003eb6:	40 c4       	mov.aa %a4,%a12
80003eb8:	6d ff 72 ff 	call 80003d9c <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
80003ebc:	82 12       	mov %d2,1
80003ebe:	00 90       	ret 
					vPortFree( pxStack );
80003ec0:	60 94       	mov.a %a4,%d9
80003ec2:	6d ff e2 f4 	call 80002886 <vPortFree>
80003ec6:	1d ff ea ff 	j 80003e9a <xTaskCreate+0x32>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
80003eca:	82 f2       	mov %d2,-1
80003ecc:	00 90       	ret 
80003ece:	82 f2       	mov %d2,-1
	}
80003ed0:	00 90       	ret 

80003ed2 <vTaskStartScheduler>:
{
80003ed2:	40 ae       	mov.aa %a14,%sp
		xReturn = xTaskCreate(	prvIdleTask,
80003ed4:	91 10 00 77 	movh.a %a7,28673
80003ed8:	d9 77 24 00 	lea %a7,[%a7]36 <70010024 <xIdleTaskHandle>>
80003edc:	82 05       	mov %d5,0
80003ede:	a0 06       	mov.a %a6,0
80003ee0:	3b 00 08 40 	mov %d4,128
80003ee4:	91 00 00 58 	movh.a %a5,32768
80003ee8:	d9 55 0c 80 	lea %a5,[%a5]524 <8000020c <IfxCpu_Trap_vectorTable0_end+0x18>>
80003eec:	91 00 00 48 	movh.a %a4,32768
80003ef0:	d9 44 26 54 	lea %a4,[%a4]16742 <80004166 <prvIdleTask>>
80003ef4:	6d ff ba ff 	call 80003e68 <xTaskCreate>
		if( xReturn == pdPASS )
80003ef8:	df 12 07 00 	jeq %d2,1,80003f06 <vTaskStartScheduler+0x34>
	if( xReturn == pdPASS )
80003efc:	df 12 09 00 	jeq %d2,1,80003f0e <vTaskStartScheduler+0x3c>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
80003f00:	df f2 27 00 	jeq %d2,-1,80003f4e <vTaskStartScheduler+0x7c>
}
80003f04:	00 90       	ret 
			xReturn = xTimerCreateTimerTask();
80003f06:	6d 00 0c 02 	call 8000431e <xTimerCreateTimerTask>
80003f0a:	1d ff f9 ff 	j 80003efc <vTaskStartScheduler+0x2a>
  __asm__ volatile ("disable" ::: "memory");
80003f0e:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80003f12:	4d c0 e2 2f 	mfcr %d2,$icr
		portDISABLE_INTERRUPTS();
80003f16:	8f f2 cf 21 	andn %d2,%d2,255
80003f1a:	8f 02 44 21 	or %d2,%d2,64
80003f1e:	cd c2 e2 0f 	mtcr $icr,%d2
80003f22:	0d 00 c0 04 	isync 
80003f26:	0d 00 00 03 	enable 
		xNextTaskUnblockTime = portMAX_DELAY;
80003f2a:	91 10 00 27 	movh.a %a2,28673
80003f2e:	82 f2       	mov %d2,-1
80003f30:	59 22 28 00 	st.w [%a2]40 <70010028 <xNextTaskUnblockTime>>,%d2
		xSchedulerRunning = pdTRUE;
80003f34:	91 10 00 27 	movh.a %a2,28673
80003f38:	82 12       	mov %d2,1
80003f3a:	59 22 3c 00 	st.w [%a2]60 <7001003c <xSchedulerRunning>>,%d2
		xTickCount = ( TickType_t ) 0U;
80003f3e:	91 10 00 27 	movh.a %a2,28673
80003f42:	82 02       	mov %d2,0
80003f44:	59 22 04 10 	st.w [%a2]68 <70010044 <xTickCount>>,%d2
		if( xPortStartScheduler() != pdFALSE )
80003f48:	6d ff ad f5 	call 80002aa2 <xPortStartScheduler>
80003f4c:	00 90       	ret 
  __asm__ volatile ("disable" ::: "memory");
80003f4e:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80003f52:	4d c0 e2 2f 	mfcr %d2,$icr
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
80003f56:	8f f2 cf 21 	andn %d2,%d2,255
80003f5a:	8f 02 44 21 	or %d2,%d2,64
80003f5e:	cd c2 e2 0f 	mtcr $icr,%d2
80003f62:	0d 00 c0 04 	isync 
80003f66:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80003f6a:	00 a0       	debug 
80003f6c:	1d 00 00 00 	j 80003f6c <vTaskStartScheduler+0x9a>

80003f70 <xTaskResumeAll>:
{
80003f70:	40 ae       	mov.aa %a14,%sp
	configASSERT( uxSchedulerSuspended );
80003f72:	91 10 00 27 	movh.a %a2,28673
80003f76:	19 22 20 00 	ld.w %d2,[%a2]32 <70010020 <uxSchedulerSuspended>>
80003f7a:	df 02 13 80 	jne %d2,0,80003fa0 <xTaskResumeAll+0x30>
  __asm__ volatile ("disable" ::: "memory");
80003f7e:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80003f82:	4d c0 e2 2f 	mfcr %d2,$icr
80003f86:	8f f2 cf 21 	andn %d2,%d2,255
80003f8a:	8f 02 44 21 	or %d2,%d2,64
80003f8e:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
80003f92:	0d 00 c0 04 	isync 
80003f96:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80003f9a:	00 a0       	debug 
80003f9c:	1d 00 00 00 	j 80003f9c <xTaskResumeAll+0x2c>
	taskENTER_CRITICAL();
80003fa0:	6d ff b0 fe 	call 80003d00 <vTaskEnterCritical>
		--uxSchedulerSuspended;
80003fa4:	91 10 00 27 	movh.a %a2,28673
80003fa8:	19 22 20 00 	ld.w %d2,[%a2]32 <70010020 <uxSchedulerSuspended>>
80003fac:	c2 f2       	add %d2,-1
80003fae:	59 22 20 00 	st.w [%a2]32 <70010020 <uxSchedulerSuspended>>,%d2
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80003fb2:	19 22 20 00 	ld.w %d2,[%a2]32 <70010020 <uxSchedulerSuspended>>
80003fb6:	df 02 75 80 	jne %d2,0,800040a0 <xTaskResumeAll+0x130>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
80003fba:	91 10 00 27 	movh.a %a2,28673
80003fbe:	19 22 08 10 	ld.w %d2,[%a2]72 <70010048 <uxCurrentNumberOfTasks>>
80003fc2:	df 02 05 80 	jne %d2,0,80003fcc <xTaskResumeAll+0x5c>
BaseType_t xAlreadyYielded = pdFALSE;
80003fc6:	82 08       	mov %d8,0
80003fc8:	1d 00 6d 00 	j 800040a2 <xTaskResumeAll+0x132>
TCB_t *pxTCB = NULL;
80003fcc:	a0 0c       	mov.a %a12,0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
80003fce:	91 10 00 27 	movh.a %a2,28673
80003fd2:	19 22 38 10 	ld.w %d2,[%a2]120 <70010078 <xPendingReadyList>>
80003fd6:	df 02 3b 00 	jeq %d2,0,8000404c <xTaskResumeAll+0xdc>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
80003fda:	91 10 00 27 	movh.a %a2,28673
80003fde:	d9 22 38 10 	lea %a2,[%a2]120 <70010078 <xPendingReadyList>>
80003fe2:	d9 22 0c 00 	lea %a2,[%a2]12 <7001000c <_SMALL_DATA_+0x800c>>
80003fe6:	d4 22       	ld.a %a2,[%a2]
80003fe8:	99 2c 0c 00 	ld.a %a12,[%a2]12 <7001000c <_SMALL_DATA_+0x800c>>
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80003fec:	d9 c4 18 00 	lea %a4,[%a12]24 <7001000c <_SMALL_DATA_+0x800c>>
80003ff0:	6d ff a5 f6 	call 80002d3a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80003ff4:	80 c2       	mov.d %d2,%a12
80003ff6:	1b 42 00 80 	addi %d8,%d2,4
80003ffa:	60 84       	mov.a %a4,%d8
80003ffc:	6d ff 9f f6 	call 80002d3a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
80004000:	19 c2 2c 00 	ld.w %d2,[%a12]44
80004004:	91 10 00 27 	movh.a %a2,28673
80004008:	19 23 00 10 	ld.w %d3,[%a2]64 <70010040 <uxTopReadyPriority>>
8000400c:	7f 23 04 80 	jge.u %d3,%d2,80004014 <xTaskResumeAll+0xa4>
80004010:	59 22 00 10 	st.w [%a2]64 <70010040 <uxTopReadyPriority>>,%d2
80004014:	60 85       	mov.a %a5,%d8
80004016:	91 10 00 47 	movh.a %a4,28673
8000401a:	d9 44 3c 20 	lea %a4,[%a4]188 <700100bc <pxReadyTasksLists>>
8000401e:	53 42 21 30 	mul %d3,%d2,20
80004022:	01 43 00 46 	addsc.a %a4,%a4,%d3,0
80004026:	6d ff 57 f6 	call 80002cd4 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000402a:	19 c3 2c 00 	ld.w %d3,[%a12]44
8000402e:	91 10 00 27 	movh.a %a2,28673
80004032:	99 22 34 40 	ld.a %a2,[%a2]308 <70010134 <pxCurrentTCB>>
80004036:	19 22 2c 00 	ld.w %d2,[%a2]44 <70010134 <pxCurrentTCB>>
8000403a:	3f 23 ca ff 	jlt.u %d3,%d2,80003fce <xTaskResumeAll+0x5e>
						xYieldPending = pdTRUE;
8000403e:	91 10 00 27 	movh.a %a2,28673
80004042:	82 12       	mov %d2,1
80004044:	59 22 34 00 	st.w [%a2]52 <70010034 <xYieldPending>>,%d2
80004048:	1d ff c3 ff 	j 80003fce <xTaskResumeAll+0x5e>
				if( pxTCB != NULL )
8000404c:	bd 0c 04 00 	jz.a %a12,80004054 <xTaskResumeAll+0xe4>
					prvResetNextTaskUnblockTime();
80004050:	6d ff 8e fa 	call 8000356c <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
80004054:	91 10 00 27 	movh.a %a2,28673
80004058:	19 28 38 00 	ld.w %d8,[%a2]56 <70010038 <uxPendedTicks>>
					if( uxPendedCounts > ( UBaseType_t ) 0U )
8000405c:	df 08 10 80 	jne %d8,0,8000407c <xTaskResumeAll+0x10c>
				if( xYieldPending != pdFALSE )
80004060:	91 10 00 27 	movh.a %a2,28673
80004064:	19 28 34 00 	ld.w %d8,[%a2]52 <70010034 <xYieldPending>>
80004068:	df 08 1d 00 	jeq %d8,0,800040a2 <xTaskResumeAll+0x132>
					taskYIELD_IF_USING_PREEMPTION();
8000406c:	ad 00 80 00 	syscall 0
						xAlreadyYielded = pdTRUE;
80004070:	82 18       	mov %d8,1
80004072:	1d 00 18 00 	j 800040a2 <xTaskResumeAll+0x132>
							--uxPendedCounts;
80004076:	c2 f8       	add %d8,-1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
80004078:	df 08 0d 00 	jeq %d8,0,80004092 <xTaskResumeAll+0x122>
							if( xTaskIncrementTick() != pdFALSE )
8000407c:	6d ff 84 fb 	call 80003784 <xTaskIncrementTick>
80004080:	df 02 fb 7f 	jeq %d2,0,80004076 <xTaskResumeAll+0x106>
								xYieldPending = pdTRUE;
80004084:	91 10 00 27 	movh.a %a2,28673
80004088:	82 12       	mov %d2,1
8000408a:	59 22 34 00 	st.w [%a2]52 <70010034 <xYieldPending>>,%d2
8000408e:	1d ff f4 ff 	j 80004076 <xTaskResumeAll+0x106>
						uxPendedTicks = 0;
80004092:	91 10 00 27 	movh.a %a2,28673
80004096:	82 02       	mov %d2,0
80004098:	59 22 38 00 	st.w [%a2]56 <70010038 <uxPendedTicks>>,%d2
8000409c:	1d ff e2 ff 	j 80004060 <xTaskResumeAll+0xf0>
BaseType_t xAlreadyYielded = pdFALSE;
800040a0:	82 08       	mov %d8,0
	taskEXIT_CRITICAL();
800040a2:	6d ff 51 fe 	call 80003d44 <vTaskExitCritical>
}
800040a6:	02 82       	mov %d2,%d8
800040a8:	00 90       	ret 

800040aa <vTaskDelay>:
	{
800040aa:	40 ae       	mov.aa %a14,%sp
800040ac:	02 48       	mov %d8,%d4
		if( xTicksToDelay > ( TickType_t ) 0U )
800040ae:	df 04 23 00 	jeq %d4,0,800040f4 <vTaskDelay+0x4a>
			configASSERT( uxSchedulerSuspended == 0 );
800040b2:	91 10 00 27 	movh.a %a2,28673
800040b6:	19 22 20 00 	ld.w %d2,[%a2]32 <70010020 <uxSchedulerSuspended>>
800040ba:	df 02 13 00 	jeq %d2,0,800040e0 <vTaskDelay+0x36>
  __asm__ volatile ("disable" ::: "memory");
800040be:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
800040c2:	4d c0 e2 2f 	mfcr %d2,$icr
800040c6:	8f f2 cf 21 	andn %d2,%d2,255
800040ca:	8f 02 44 21 	or %d2,%d2,64
800040ce:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
800040d2:	0d 00 c0 04 	isync 
800040d6:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
800040da:	00 a0       	debug 
800040dc:	1d 00 00 00 	j 800040dc <vTaskDelay+0x32>
			vTaskSuspendAll();
800040e0:	6d ff 43 fb 	call 80003766 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
800040e4:	82 05       	mov %d5,0
800040e6:	02 84       	mov %d4,%d8
800040e8:	6d ff f5 fa 	call 800036d2 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
800040ec:	6d ff 42 ff 	call 80003f70 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
800040f0:	df 02 04 80 	jne %d2,0,800040f8 <vTaskDelay+0x4e>
			portYIELD_WITHIN_API();
800040f4:	ad 00 80 00 	syscall 0
	}
800040f8:	00 90       	ret 

800040fa <prvCheckTasksWaitingTermination>:
{
800040fa:	40 ae       	mov.aa %a14,%sp
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
800040fc:	91 10 00 27 	movh.a %a2,28673
80004100:	19 22 20 10 	ld.w %d2,[%a2]96 <70010060 <uxDeletedTasksWaitingCleanUp>>
80004104:	df 02 30 00 	jeq %d2,0,80004164 <prvCheckTasksWaitingTermination+0x6a>
			vTaskSuspendAll();
80004108:	6d ff 2f fb 	call 80003766 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000410c:	91 10 00 27 	movh.a %a2,28673
80004110:	19 28 24 10 	ld.w %d8,[%a2]100 <70010064 <xTasksWaitingTermination>>
			( void ) xTaskResumeAll();
80004114:	6d ff 2e ff 	call 80003f70 <xTaskResumeAll>
			if( xListIsEmpty == pdFALSE )
80004118:	df 08 f2 7f 	jeq %d8,0,800040fc <prvCheckTasksWaitingTermination+0x2>
				taskENTER_CRITICAL();
8000411c:	6d ff f2 fd 	call 80003d00 <vTaskEnterCritical>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
80004120:	91 10 00 27 	movh.a %a2,28673
80004124:	d9 22 24 10 	lea %a2,[%a2]100 <70010064 <xTasksWaitingTermination>>
80004128:	d9 22 0c 00 	lea %a2,[%a2]12 <7001000c <_SMALL_DATA_+0x800c>>
8000412c:	d4 22       	ld.a %a2,[%a2]
8000412e:	99 2c 0c 00 	ld.a %a12,[%a2]12 <7001000c <_SMALL_DATA_+0x800c>>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80004132:	d9 c4 04 00 	lea %a4,[%a12]4 <7001000c <_SMALL_DATA_+0x800c>>
80004136:	6d ff 02 f6 	call 80002d3a <uxListRemove>
					--uxCurrentNumberOfTasks;
8000413a:	91 10 00 27 	movh.a %a2,28673
8000413e:	19 22 08 10 	ld.w %d2,[%a2]72 <70010048 <uxCurrentNumberOfTasks>>
80004142:	c2 f2       	add %d2,-1
80004144:	59 22 08 10 	st.w [%a2]72 <70010048 <uxCurrentNumberOfTasks>>,%d2
					--uxDeletedTasksWaitingCleanUp;
80004148:	91 10 00 27 	movh.a %a2,28673
8000414c:	19 22 20 10 	ld.w %d2,[%a2]96 <70010060 <uxDeletedTasksWaitingCleanUp>>
80004150:	c2 f2       	add %d2,-1
80004152:	59 22 20 10 	st.w [%a2]96 <70010060 <uxDeletedTasksWaitingCleanUp>>,%d2
				taskEXIT_CRITICAL();
80004156:	6d ff f7 fd 	call 80003d44 <vTaskExitCritical>
				prvDeleteTCB( pxTCB );
8000415a:	40 c4       	mov.aa %a4,%a12
8000415c:	6d ff af fa 	call 800036ba <prvDeleteTCB>
80004160:	1d ff ce ff 	j 800040fc <prvCheckTasksWaitingTermination+0x2>
}
80004164:	00 90       	ret 

80004166 <prvIdleTask>:
{
80004166:	40 ae       	mov.aa %a14,%sp
		prvCheckTasksWaitingTermination();
80004168:	6d ff c9 ff 	call 800040fa <prvCheckTasksWaitingTermination>
	for( ;; )
8000416c:	1d ff fe ff 	j 80004168 <prvIdleTask+0x2>

80004170 <xTaskCheckForTimeOut>:
{
80004170:	40 ae       	mov.aa %a14,%sp
80004172:	40 4c       	mov.aa %a12,%a4
80004174:	40 5d       	mov.aa %a13,%a5
	configASSERT( pxTimeOut );
80004176:	bd 04 21 00 	jz.a %a4,800041b8 <xTaskCheckForTimeOut+0x48>
	configASSERT( pxTicksToWait );
8000417a:	bd 05 30 00 	jz.a %a5,800041da <xTaskCheckForTimeOut+0x6a>
	taskENTER_CRITICAL();
8000417e:	6d ff c1 fd 	call 80003d00 <vTaskEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
80004182:	91 10 00 27 	movh.a %a2,28673
80004186:	19 23 04 10 	ld.w %d3,[%a2]68 <70010044 <xTickCount>>
			if( *pxTicksToWait == portMAX_DELAY )
8000418a:	54 d2       	ld.w %d2,[%a13]
8000418c:	df f2 42 00 	jeq %d2,-1,80004210 <xTaskCheckForTimeOut+0xa0>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
80004190:	54 c5       	ld.w %d5,[%a12]
80004192:	91 10 00 27 	movh.a %a2,28673
80004196:	19 24 30 00 	ld.w %d4,[%a2]48 <70010030 <xNumOfOverflows>>
8000419a:	5f 45 06 00 	jeq %d5,%d4,800041a6 <xTaskCheckForTimeOut+0x36>
8000419e:	19 c4 04 00 	ld.w %d4,[%a12]4
800041a2:	7f 43 3c 80 	jge.u %d3,%d4,8000421a <xTaskCheckForTimeOut+0xaa>
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
800041a6:	19 c4 04 00 	ld.w %d4,[%a12]4
800041aa:	0b 43 80 50 	sub %d5,%d3,%d4
800041ae:	3f 25 27 80 	jlt.u %d5,%d2,800041fc <xTaskCheckForTimeOut+0x8c>
			xReturn = pdTRUE;
800041b2:	82 18       	mov %d8,1
800041b4:	1d 00 2f 00 	j 80004212 <xTaskCheckForTimeOut+0xa2>
  __asm__ volatile ("disable" ::: "memory");
800041b8:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
800041bc:	4d c0 e2 2f 	mfcr %d2,$icr
	configASSERT( pxTimeOut );
800041c0:	8f f2 cf 21 	andn %d2,%d2,255
800041c4:	8f 02 44 21 	or %d2,%d2,64
800041c8:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
800041cc:	0d 00 c0 04 	isync 
800041d0:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
800041d4:	00 a0       	debug 
800041d6:	1d 00 00 00 	j 800041d6 <xTaskCheckForTimeOut+0x66>
  __asm__ volatile ("disable" ::: "memory");
800041da:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
800041de:	4d c0 e2 2f 	mfcr %d2,$icr
	configASSERT( pxTicksToWait );
800041e2:	8f f2 cf 21 	andn %d2,%d2,255
800041e6:	8f 02 44 21 	or %d2,%d2,64
800041ea:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
800041ee:	0d 00 c0 04 	isync 
800041f2:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
800041f6:	00 a0       	debug 
800041f8:	1d 00 00 00 	j 800041f8 <xTaskCheckForTimeOut+0x88>
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
800041fc:	0b 34 80 30 	sub %d3,%d4,%d3
80004200:	42 32       	add %d2,%d3
80004202:	74 d2       	st.w [%a13],%d2
			vTaskSetTimeOutState( pxTimeOut );
80004204:	40 c4       	mov.aa %a4,%a12
80004206:	6d ff 88 fc 	call 80003b16 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
8000420a:	82 08       	mov %d8,0
8000420c:	1d 00 03 00 	j 80004212 <xTaskCheckForTimeOut+0xa2>
				xReturn = pdFALSE;
80004210:	82 08       	mov %d8,0
	taskEXIT_CRITICAL();
80004212:	6d ff 99 fd 	call 80003d44 <vTaskExitCritical>
}
80004216:	02 82       	mov %d2,%d8
80004218:	00 90       	ret 
			xReturn = pdTRUE;
8000421a:	82 18       	mov %d8,1
8000421c:	1d ff fb ff 	j 80004212 <xTaskCheckForTimeOut+0xa2>

80004220 <pvTaskIncrementMutexHeldCount>:
	{
80004220:	40 ae       	mov.aa %a14,%sp
		if( pxCurrentTCB != NULL )
80004222:	91 10 00 27 	movh.a %a2,28673
80004226:	19 22 34 40 	ld.w %d2,[%a2]308 <70010134 <pxCurrentTCB>>
8000422a:	df 02 0a 00 	jeq %d2,0,8000423e <pvTaskIncrementMutexHeldCount+0x1e>
			( pxCurrentTCB->uxMutexesHeld )++;
8000422e:	99 22 34 40 	ld.a %a2,[%a2]308 <70010134 <pxCurrentTCB>>
80004232:	d9 23 1c 10 	lea %a3,[%a2]92 <70010134 <pxCurrentTCB>>
80004236:	19 22 1c 10 	ld.w %d2,[%a2]92 <70010134 <pxCurrentTCB>>
8000423a:	c2 12       	add %d2,1
8000423c:	74 32       	st.w [%a3],%d2
	}
8000423e:	91 10 00 27 	movh.a %a2,28673
80004242:	99 22 34 40 	ld.a %a2,[%a2]308 <70010134 <pxCurrentTCB>>
80004246:	00 90       	ret 

80004248 <prvGetNextExpireTime>:
	}
}
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
80004248:	40 ae       	mov.aa %a14,%sp
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
8000424a:	91 10 00 27 	movh.a %a2,28673
8000424e:	99 22 08 50 	ld.a %a2,[%a2]328 <70010148 <pxCurrentTimerList>>
80004252:	54 22       	ld.w %d2,[%a2]
80004254:	8b 02 00 22 	eq %d2,%d2,0
80004258:	74 42       	st.w [%a4],%d2
	if( *pxListWasEmpty == pdFALSE )
8000425a:	df 02 07 80 	jne %d2,0,80004268 <prvGetNextExpireTime+0x20>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
8000425e:	d9 22 0c 00 	lea %a2,[%a2]12
80004262:	d4 22       	ld.a %a2,[%a2]
80004264:	54 22       	ld.w %d2,[%a2]
80004266:	00 90       	ret 
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
80004268:	82 02       	mov %d2,0
	}

	return xNextExpireTime;
}
8000426a:	00 90       	ret 

8000426c <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
8000426c:	40 ae       	mov.aa %a14,%sp
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
8000426e:	59 44 04 00 	st.w [%a4]4,%d4
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
80004272:	b5 44 10 00 	st.a [%a4]16,%a4

	if( xNextExpiryTime <= xTimeNow )
80004276:	3f 45 13 80 	jlt.u %d5,%d4,8000429c <prvInsertTimerInActiveList+0x30>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
8000427a:	a2 65       	sub %d5,%d6
8000427c:	19 43 18 00 	ld.w %d3,[%a4]24
80004280:	3f 35 04 80 	jlt.u %d5,%d3,80004288 <prvInsertTimerInActiveList+0x1c>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
80004284:	82 12       	mov %d2,1
80004286:	00 90       	ret 
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
80004288:	d9 45 04 00 	lea %a5,[%a4]4
8000428c:	91 10 00 47 	movh.a %a4,28673
80004290:	99 44 04 50 	ld.a %a4,[%a4]324 <70010144 <pxOverflowTimerList>>
80004294:	6d ff 33 f5 	call 80002cfa <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
80004298:	82 02       	mov %d2,0
8000429a:	00 90       	ret 
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
8000429c:	0b 65 30 51 	lt.u %d5,%d5,%d6
800042a0:	0b 64 50 21 	ge.u %d2,%d4,%d6
800042a4:	26 52       	and %d2,%d5
800042a6:	df 02 04 00 	jeq %d2,0,800042ae <prvInsertTimerInActiveList+0x42>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
800042aa:	82 12       	mov %d2,1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
800042ac:	00 90       	ret 
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
800042ae:	d9 45 04 00 	lea %a5,[%a4]4
800042b2:	91 10 00 47 	movh.a %a4,28673
800042b6:	99 44 08 50 	ld.a %a4,[%a4]328 <70010148 <pxCurrentTimerList>>
800042ba:	6d ff 20 f5 	call 80002cfa <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
800042be:	82 02       	mov %d2,0
800042c0:	00 90       	ret 

800042c2 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
800042c2:	40 ae       	mov.aa %a14,%sp
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
800042c4:	6d ff 1e fd 	call 80003d00 <vTaskEnterCritical>
	{
		if( xTimerQueue == NULL )
800042c8:	91 10 00 27 	movh.a %a2,28673
800042cc:	19 22 00 50 	ld.w %d2,[%a2]320 <70010140 <xTimerQueue>>
800042d0:	df 02 05 00 	jeq %d2,0,800042da <prvCheckForValidListAndQueue+0x18>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
800042d4:	6d ff 38 fd 	call 80003d44 <vTaskExitCritical>
}
800042d8:	00 90       	ret 
			vListInitialise( &xActiveTimerList1 );
800042da:	91 10 00 d7 	movh.a %a13,28673
800042de:	d9 dd 20 50 	lea %a13,[%a13]352 <70010160 <xActiveTimerList1>>
800042e2:	40 d4       	mov.aa %a4,%a13
800042e4:	6d ff e3 f4 	call 80002caa <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
800042e8:	91 10 00 c7 	movh.a %a12,28673
800042ec:	d9 cc 0c 50 	lea %a12,[%a12]332 <7001014c <xActiveTimerList2>>
800042f0:	40 c4       	mov.aa %a4,%a12
800042f2:	6d ff dc f4 	call 80002caa <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
800042f6:	91 10 00 27 	movh.a %a2,28673
800042fa:	b5 2d 08 50 	st.a [%a2]328 <70010148 <pxCurrentTimerList>>,%a13
			pxOverflowTimerList = &xActiveTimerList2;
800042fe:	91 10 00 27 	movh.a %a2,28673
80004302:	b5 2c 04 50 	st.a [%a2]324 <70010144 <pxOverflowTimerList>>,%a12
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
80004306:	82 06       	mov %d6,0
80004308:	3b c0 00 50 	mov %d5,12
8000430c:	82 54       	mov %d4,5
8000430e:	6d ff 74 f6 	call 80002ff6 <xQueueGenericCreate>
80004312:	91 10 00 37 	movh.a %a3,28673
80004316:	b5 32 00 50 	st.a [%a3]320 <70010140 <xTimerQueue>>,%a2
8000431a:	1d ff dd ff 	j 800042d4 <prvCheckForValidListAndQueue+0x12>

8000431e <xTimerCreateTimerTask>:
{
8000431e:	40 ae       	mov.aa %a14,%sp
	prvCheckForValidListAndQueue();
80004320:	6d ff d1 ff 	call 800042c2 <prvCheckForValidListAndQueue>
	if( xTimerQueue != NULL )
80004324:	91 10 00 27 	movh.a %a2,28673
80004328:	19 22 00 50 	ld.w %d2,[%a2]320 <70010140 <xTimerQueue>>
8000432c:	df 02 16 00 	jeq %d2,0,80004358 <xTimerCreateTimerTask+0x3a>
			xReturn = xTaskCreate(	prvTimerTask,
80004330:	91 10 00 77 	movh.a %a7,28673
80004334:	d9 77 3c 40 	lea %a7,[%a7]316 <7001013c <xTimerTaskHandle>>
80004338:	82 35       	mov %d5,3
8000433a:	a0 06       	mov.a %a6,0
8000433c:	3b 00 08 40 	mov %d4,128
80004340:	91 00 00 58 	movh.a %a5,32768
80004344:	d9 55 11 80 	lea %a5,[%a5]529 <80000211 <IfxCpu_Trap_vectorTable0_end+0x1d>>
80004348:	91 00 00 48 	movh.a %a4,32768
8000434c:	d9 44 4c c4 	lea %a4,[%a4]18188 <8000470c <prvTimerTask>>
80004350:	6d ff 8c fd 	call 80003e68 <xTaskCreate>
	configASSERT( xReturn );
80004354:	df 02 13 80 	jne %d2,0,8000437a <xTimerCreateTimerTask+0x5c>
  __asm__ volatile ("disable" ::: "memory");
80004358:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
8000435c:	4d c0 e2 2f 	mfcr %d2,$icr
80004360:	8f f2 cf 21 	andn %d2,%d2,255
80004364:	8f 02 44 21 	or %d2,%d2,64
80004368:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
8000436c:	0d 00 c0 04 	isync 
80004370:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80004374:	00 a0       	debug 
80004376:	1d 00 00 00 	j 80004376 <xTimerCreateTimerTask+0x58>
}
8000437a:	00 90       	ret 

8000437c <xTimerGenericCommand>:
{
8000437c:	40 ae       	mov.aa %a14,%sp
8000437e:	20 10       	sub.a %sp,16
80004380:	80 42       	mov.d %d2,%a4
80004382:	02 43       	mov %d3,%d4
80004384:	02 68       	mov %d8,%d6
	configASSERT( xTimer );
80004386:	df 02 1f 00 	jeq %d2,0,800043c4 <xTimerGenericCommand+0x48>
	if( xTimerQueue != NULL )
8000438a:	91 10 00 47 	movh.a %a4,28673
8000438e:	99 44 00 50 	ld.a %a4,[%a4]320 <70010140 <xTimerQueue>>
80004392:	bd 04 3c 00 	jz.a %a4,8000440a <xTimerGenericCommand+0x8e>
		xMessage.xMessageID = xCommandID;
80004396:	59 e3 f4 ff 	st.w [%a14]-12,%d3
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
8000439a:	59 e5 f8 ff 	st.w [%a14]-8,%d5
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
8000439e:	59 e2 fc ff 	st.w [%a14]-4,%d2
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
800043a2:	ff 63 2d 00 	jge %d3,6,800043fc <xTimerGenericCommand+0x80>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
800043a6:	6d ff df fb 	call 80003b64 <xTaskGetSchedulerState>
800043aa:	df 22 1e 00 	jeq %d2,2,800043e6 <xTimerGenericCommand+0x6a>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
800043ae:	82 05       	mov %d5,0
800043b0:	82 04       	mov %d4,0
800043b2:	d9 e5 f4 ff 	lea %a5,[%a14]-12
800043b6:	91 10 00 47 	movh.a %a4,28673
800043ba:	99 44 00 50 	ld.a %a4,[%a4]320 <70010140 <xTimerQueue>>
800043be:	6d ff 4b f6 	call 80003054 <xQueueGenericSend>
800043c2:	00 90       	ret 
  __asm__ volatile ("disable" ::: "memory");
800043c4:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
800043c8:	4d c0 e2 2f 	mfcr %d2,$icr
	configASSERT( xTimer );
800043cc:	8f f2 cf 21 	andn %d2,%d2,255
800043d0:	8f 02 44 21 	or %d2,%d2,64
800043d4:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
800043d8:	0d 00 c0 04 	isync 
800043dc:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
800043e0:	00 a0       	debug 
800043e2:	1d 00 00 00 	j 800043e2 <xTimerGenericCommand+0x66>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
800043e6:	82 05       	mov %d5,0
800043e8:	02 84       	mov %d4,%d8
800043ea:	d9 e5 f4 ff 	lea %a5,[%a14]-12
800043ee:	91 10 00 47 	movh.a %a4,28673
800043f2:	99 44 00 50 	ld.a %a4,[%a4]320 <70010140 <xTimerQueue>>
800043f6:	6d ff 2f f6 	call 80003054 <xQueueGenericSend>
800043fa:	00 90       	ret 
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
800043fc:	82 04       	mov %d4,0
800043fe:	40 56       	mov.aa %a6,%a5
80004400:	d9 e5 f4 ff 	lea %a5,[%a14]-12
80004404:	6d ff 08 f7 	call 80003214 <xQueueGenericSendFromISR>
80004408:	00 90       	ret 
BaseType_t xReturn = pdFAIL;
8000440a:	82 02       	mov %d2,0
}
8000440c:	00 90       	ret 

8000440e <prvSwitchTimerLists>:
{
8000440e:	40 ae       	mov.aa %a14,%sp
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
80004410:	91 10 00 27 	movh.a %a2,28673
80004414:	99 22 08 50 	ld.a %a2,[%a2]328 <70010148 <pxCurrentTimerList>>
80004418:	54 22       	ld.w %d2,[%a2]
8000441a:	df 02 43 00 	jeq %d2,0,800044a0 <prvSwitchTimerLists+0x92>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
8000441e:	d9 22 0c 00 	lea %a2,[%a2]12
80004422:	d4 22       	ld.a %a2,[%a2]
80004424:	54 29       	ld.w %d9,[%a2]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
80004426:	99 2c 0c 00 	ld.a %a12,[%a2]12
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
8000442a:	80 c2       	mov.d %d2,%a12
8000442c:	1b 42 00 80 	addi %d8,%d2,4
80004430:	60 84       	mov.a %a4,%d8
80004432:	6d ff 84 f4 	call 80002d3a <uxListRemove>
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
80004436:	99 c2 24 00 	ld.a %a2,[%a12]36
8000443a:	40 c4       	mov.aa %a4,%a12
8000443c:	2d 02 00 00 	calli %a2
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
80004440:	19 c2 1c 00 	ld.w %d2,[%a12]28
80004444:	df 12 e6 ff 	jne %d2,1,80004410 <prvSwitchTimerLists+0x2>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
80004448:	19 c2 18 00 	ld.w %d2,[%a12]24
8000444c:	42 92       	add %d2,%d9
			if( xReloadTime > xNextExpireTime )
8000444e:	7f 29 0f 80 	jge.u %d9,%d2,8000446c <prvSwitchTimerLists+0x5e>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
80004452:	60 82       	mov.a %a2,%d8
80004454:	74 22       	st.w [%a2],%d2
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
80004456:	b5 cc 10 00 	st.a [%a12]16,%a12
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
8000445a:	60 85       	mov.a %a5,%d8
8000445c:	91 10 00 47 	movh.a %a4,28673
80004460:	99 44 08 50 	ld.a %a4,[%a4]328 <70010148 <pxCurrentTimerList>>
80004464:	6d ff 4b f4 	call 80002cfa <vListInsert>
80004468:	1d ff d4 ff 	j 80004410 <prvSwitchTimerLists+0x2>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
8000446c:	82 06       	mov %d6,0
8000446e:	a0 05       	mov.a %a5,0
80004470:	02 95       	mov %d5,%d9
80004472:	82 04       	mov %d4,0
80004474:	40 c4       	mov.aa %a4,%a12
80004476:	6d ff 83 ff 	call 8000437c <xTimerGenericCommand>
				configASSERT( xResult );
8000447a:	df 02 cb ff 	jne %d2,0,80004410 <prvSwitchTimerLists+0x2>
  __asm__ volatile ("disable" ::: "memory");
8000447e:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80004482:	4d c0 e2 2f 	mfcr %d2,$icr
80004486:	8f f2 cf 21 	andn %d2,%d2,255
8000448a:	8f 02 44 21 	or %d2,%d2,64
8000448e:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
80004492:	0d 00 c0 04 	isync 
80004496:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
8000449a:	00 a0       	debug 
8000449c:	1d 00 00 00 	j 8000449c <prvSwitchTimerLists+0x8e>
	pxCurrentTimerList = pxOverflowTimerList;
800044a0:	91 10 00 37 	movh.a %a3,28673
800044a4:	19 32 04 50 	ld.w %d2,[%a3]324 <70010144 <pxOverflowTimerList>>
800044a8:	91 10 00 47 	movh.a %a4,28673
800044ac:	59 42 08 50 	st.w [%a4]328 <70010148 <pxCurrentTimerList>>,%d2
	pxOverflowTimerList = pxTemp;
800044b0:	b5 32 04 50 	st.a [%a3]324 <70010144 <pxOverflowTimerList>>,%a2
}
800044b4:	00 90       	ret 

800044b6 <prvSampleTimeNow>:
{
800044b6:	40 ae       	mov.aa %a14,%sp
800044b8:	40 4c       	mov.aa %a12,%a4
	xTimeNow = xTaskGetTickCount();
800044ba:	6d ff 5f f9 	call 80003778 <xTaskGetTickCount>
800044be:	02 28       	mov %d8,%d2
	if( xTimeNow < xLastTime )
800044c0:	91 10 00 27 	movh.a %a2,28673
800044c4:	19 22 38 40 	ld.w %d2,[%a2]312 <70010138 <xLastTime.0>>
800044c8:	3f 28 0a 80 	jlt.u %d8,%d2,800044dc <prvSampleTimeNow+0x26>
		*pxTimerListsWereSwitched = pdFALSE;
800044cc:	82 02       	mov %d2,0
800044ce:	74 c2       	st.w [%a12],%d2
	xLastTime = xTimeNow;
800044d0:	91 10 00 27 	movh.a %a2,28673
800044d4:	59 28 38 40 	st.w [%a2]312 <70010138 <xLastTime.0>>,%d8
}
800044d8:	02 82       	mov %d2,%d8
800044da:	00 90       	ret 
		prvSwitchTimerLists();
800044dc:	6d ff 99 ff 	call 8000440e <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
800044e0:	82 12       	mov %d2,1
800044e2:	74 c2       	st.w [%a12],%d2
800044e4:	1d ff f6 ff 	j 800044d0 <prvSampleTimeNow+0x1a>

800044e8 <prvProcessExpiredTimer>:
{
800044e8:	40 ae       	mov.aa %a14,%sp
800044ea:	02 48       	mov %d8,%d4
800044ec:	02 59       	mov %d9,%d5
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
800044ee:	91 10 00 27 	movh.a %a2,28673
800044f2:	99 22 08 50 	ld.a %a2,[%a2]328 <70010148 <pxCurrentTimerList>>
800044f6:	d9 22 0c 00 	lea %a2,[%a2]12 <70010148 <pxCurrentTimerList>>
800044fa:	d4 22       	ld.a %a2,[%a2]
800044fc:	99 2c 0c 00 	ld.a %a12,[%a2]12 <70010148 <pxCurrentTimerList>>
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
80004500:	d9 c4 04 00 	lea %a4,[%a12]4 <70010148 <pxCurrentTimerList>>
80004504:	6d ff 1b f4 	call 80002d3a <uxListRemove>
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
80004508:	19 c2 1c 00 	ld.w %d2,[%a12]28
8000450c:	df 12 08 00 	jeq %d2,1,8000451c <prvProcessExpiredTimer+0x34>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
80004510:	99 c2 24 00 	ld.a %a2,[%a12]36
80004514:	40 c4       	mov.aa %a4,%a12
80004516:	2d 02 00 00 	calli %a2
}
8000451a:	00 90       	ret 
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
8000451c:	02 86       	mov %d6,%d8
8000451e:	02 95       	mov %d5,%d9
80004520:	19 c2 18 00 	ld.w %d2,[%a12]24
80004524:	0b 82 00 40 	add %d4,%d2,%d8
80004528:	40 c4       	mov.aa %a4,%a12
8000452a:	6d ff a1 fe 	call 8000426c <prvInsertTimerInActiveList>
8000452e:	df 02 f1 7f 	jeq %d2,0,80004510 <prvProcessExpiredTimer+0x28>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
80004532:	82 06       	mov %d6,0
80004534:	a0 05       	mov.a %a5,0
80004536:	02 85       	mov %d5,%d8
80004538:	82 04       	mov %d4,0
8000453a:	40 c4       	mov.aa %a4,%a12
8000453c:	6d ff 20 ff 	call 8000437c <xTimerGenericCommand>
			configASSERT( xResult );
80004540:	df 02 e8 ff 	jne %d2,0,80004510 <prvProcessExpiredTimer+0x28>
  __asm__ volatile ("disable" ::: "memory");
80004544:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
80004548:	4d c0 e2 2f 	mfcr %d2,$icr
8000454c:	8f f2 cf 21 	andn %d2,%d2,255
80004550:	8f 02 44 21 	or %d2,%d2,64
80004554:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
80004558:	0d 00 c0 04 	isync 
8000455c:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
80004560:	00 a0       	debug 
80004562:	1d 00 00 00 	j 80004562 <prvProcessExpiredTimer+0x7a>

80004566 <prvProcessTimerOrBlockTask>:
{
80004566:	40 ae       	mov.aa %a14,%sp
80004568:	20 08       	sub.a %sp,8
8000456a:	02 4a       	mov %d10,%d4
8000456c:	02 58       	mov %d8,%d5
	vTaskSuspendAll();
8000456e:	6d ff fc f8 	call 80003766 <vTaskSuspendAll>
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
80004572:	d9 e4 fc ff 	lea %a4,[%a14]-4
80004576:	6d ff a0 ff 	call 800044b6 <prvSampleTimeNow>
8000457a:	02 29       	mov %d9,%d2
		if( xTimerListsWereSwitched == pdFALSE )
8000457c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80004580:	df 02 29 80 	jne %d2,0,800045d2 <prvProcessTimerOrBlockTask+0x6c>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
80004584:	8b 08 00 32 	eq %d3,%d8,0
80004588:	0b a9 50 21 	ge.u %d2,%d9,%d10
8000458c:	26 32       	and %d2,%d3
8000458e:	df 02 1b 80 	jne %d2,0,800045c4 <prvProcessTimerOrBlockTask+0x5e>
				if( xListWasEmpty != pdFALSE )
80004592:	df 08 09 00 	jeq %d8,0,800045a4 <prvProcessTimerOrBlockTask+0x3e>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
80004596:	91 10 00 27 	movh.a %a2,28673
8000459a:	99 22 04 50 	ld.a %a2,[%a2]324 <70010144 <pxOverflowTimerList>>
8000459e:	54 22       	ld.w %d2,[%a2]
800045a0:	8b 02 00 82 	eq %d8,%d2,0
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
800045a4:	02 85       	mov %d5,%d8
800045a6:	0b 9a 80 40 	sub %d4,%d10,%d9
800045aa:	91 10 00 47 	movh.a %a4,28673
800045ae:	99 44 00 50 	ld.a %a4,[%a4]320 <70010140 <xTimerQueue>>
800045b2:	6d ff b3 f7 	call 80003518 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
800045b6:	6d ff dd fc 	call 80003f70 <xTaskResumeAll>
800045ba:	df 02 0e 80 	jne %d2,0,800045d6 <prvProcessTimerOrBlockTask+0x70>
					portYIELD_WITHIN_API();
800045be:	ad 00 80 00 	syscall 0
800045c2:	00 90       	ret 
				( void ) xTaskResumeAll();
800045c4:	6d ff d6 fc 	call 80003f70 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
800045c8:	02 95       	mov %d5,%d9
800045ca:	02 a4       	mov %d4,%d10
800045cc:	6d ff 8e ff 	call 800044e8 <prvProcessExpiredTimer>
800045d0:	00 90       	ret 
			( void ) xTaskResumeAll();
800045d2:	6d ff cf fc 	call 80003f70 <xTaskResumeAll>
}
800045d6:	00 90       	ret 

800045d8 <prvProcessReceivedCommands>:
{
800045d8:	40 ae       	mov.aa %a14,%sp
800045da:	20 10       	sub.a %sp,16
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
800045dc:	82 05       	mov %d5,0
800045de:	82 04       	mov %d4,0
800045e0:	d9 e5 f4 ff 	lea %a5,[%a14]-12
800045e4:	91 10 00 47 	movh.a %a4,28673
800045e8:	99 44 00 50 	ld.a %a4,[%a4]320 <70010140 <xTimerQueue>>
800045ec:	6d ff a0 f6 	call 8000332c <xQueueGenericReceive>
800045f0:	df 02 8c 00 	jeq %d2,0,80004708 <prvProcessReceivedCommands+0x130>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
800045f4:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800045f8:	bf 02 f2 7f 	jlt %d2,0,800045dc <prvProcessReceivedCommands+0x4>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
800045fc:	99 ec fc ff 	ld.a %a12,[%a14]-4
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
80004600:	19 c2 14 00 	ld.w %d2,[%a12]20
80004604:	df 02 06 00 	jeq %d2,0,80004610 <prvProcessReceivedCommands+0x38>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
80004608:	d9 c4 04 00 	lea %a4,[%a12]4
8000460c:	6d ff 97 f3 	call 80002d3a <uxListRemove>
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
80004610:	d9 e4 f0 ff 	lea %a4,[%a14]-16
80004614:	6d ff 51 ff 	call 800044b6 <prvSampleTimeNow>
			switch( xMessage.xMessageID )
80004618:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
8000461c:	ff a3 e0 ff 	jge.u %d3,10,800045dc <prvProcessReceivedCommands+0x4>
80004620:	91 00 00 28 	movh.a %a2,32768
80004624:	d9 22 70 84 	lea %a2,[%a2]17968 <80004630 <prvProcessReceivedCommands+0x58>>
80004628:	01 23 02 26 	addsc.a %a2,%a2,%d3,2
8000462c:	dc 02       	ji %a2
8000462e:	00 00       	nop 
80004630:	1d 00 14 00 	j 80004658 <prvProcessReceivedCommands+0x80>
80004634:	1d 00 12 00 	j 80004658 <prvProcessReceivedCommands+0x80>
80004638:	1d 00 10 00 	j 80004658 <prvProcessReceivedCommands+0x80>
8000463c:	1d ff d0 ff 	j 800045dc <prvProcessReceivedCommands+0x4>
80004640:	1d 00 40 00 	j 800046c0 <prvProcessReceivedCommands+0xe8>
80004644:	1d 00 5d 00 	j 800046fe <prvProcessReceivedCommands+0x126>
80004648:	1d 00 08 00 	j 80004658 <prvProcessReceivedCommands+0x80>
8000464c:	1d 00 06 00 	j 80004658 <prvProcessReceivedCommands+0x80>
80004650:	1d ff c6 ff 	j 800045dc <prvProcessReceivedCommands+0x4>
80004654:	1d 00 36 00 	j 800046c0 <prvProcessReceivedCommands+0xe8>
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
80004658:	19 e6 f8 ff 	ld.w %d6,[%a14]-8
8000465c:	02 25       	mov %d5,%d2
8000465e:	19 c2 18 00 	ld.w %d2,[%a12]24
80004662:	0b 26 00 40 	add %d4,%d6,%d2
80004666:	40 c4       	mov.aa %a4,%a12
80004668:	6d ff 02 fe 	call 8000426c <prvInsertTimerInActiveList>
8000466c:	df 02 b8 7f 	jeq %d2,0,800045dc <prvProcessReceivedCommands+0x4>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
80004670:	99 c2 24 00 	ld.a %a2,[%a12]36
80004674:	40 c4       	mov.aa %a4,%a12
80004676:	2d 02 00 00 	calli %a2
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
8000467a:	19 c2 1c 00 	ld.w %d2,[%a12]28
8000467e:	df 12 af ff 	jne %d2,1,800045dc <prvProcessReceivedCommands+0x4>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
80004682:	82 06       	mov %d6,0
80004684:	a0 05       	mov.a %a5,0
80004686:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000468a:	19 c3 18 00 	ld.w %d3,[%a12]24
8000468e:	0b 32 00 50 	add %d5,%d2,%d3
80004692:	82 04       	mov %d4,0
80004694:	40 c4       	mov.aa %a4,%a12
80004696:	6d ff 73 fe 	call 8000437c <xTimerGenericCommand>
							configASSERT( xResult );
8000469a:	df 02 a1 ff 	jne %d2,0,800045dc <prvProcessReceivedCommands+0x4>
  __asm__ volatile ("disable" ::: "memory");
8000469e:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
800046a2:	4d c0 e2 2f 	mfcr %d2,$icr
800046a6:	8f f2 cf 21 	andn %d2,%d2,255
800046aa:	8f 02 44 21 	or %d2,%d2,64
800046ae:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
800046b2:	0d 00 c0 04 	isync 
800046b6:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
800046ba:	00 a0       	debug 
800046bc:	1d 00 00 00 	j 800046bc <prvProcessReceivedCommands+0xe4>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
800046c0:	19 e4 f8 ff 	ld.w %d4,[%a14]-8
800046c4:	59 c4 18 00 	st.w [%a12]24,%d4
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
800046c8:	df 04 0a 00 	jeq %d4,0,800046dc <prvProcessReceivedCommands+0x104>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
800046cc:	02 26       	mov %d6,%d2
800046ce:	02 25       	mov %d5,%d2
800046d0:	42 24       	add %d4,%d2
800046d2:	40 c4       	mov.aa %a4,%a12
800046d4:	6d ff cc fd 	call 8000426c <prvInsertTimerInActiveList>
					break;
800046d8:	1d ff 82 ff 	j 800045dc <prvProcessReceivedCommands+0x4>
  __asm__ volatile ("disable" ::: "memory");
800046dc:	0d 00 40 03 	disable 
  __asm__ volatile ("mfcr %0, LO:%1"
800046e0:	4d c0 e2 2f 	mfcr %d2,$icr
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
800046e4:	8f f2 cf 21 	andn %d2,%d2,255
800046e8:	8f 02 44 21 	or %d2,%d2,64
800046ec:	cd c2 e2 0f 	mtcr $icr,%d2
    __asm__ volatile ("isync" : : : "memory");
800046f0:	0d 00 c0 04 	isync 
800046f4:	0d 00 00 03 	enable 
    __asm__ volatile ("debug" : : : "memory");
800046f8:	00 a0       	debug 
800046fa:	1d 00 00 00 	j 800046fa <prvProcessReceivedCommands+0x122>
						vPortFree( pxTimer );
800046fe:	40 c4       	mov.aa %a4,%a12
80004700:	6d ff c3 f0 	call 80002886 <vPortFree>
					break;
80004704:	1d ff 6c ff 	j 800045dc <prvProcessReceivedCommands+0x4>
}
80004708:	00 90       	ret 
	...

8000470c <prvTimerTask>:
{
8000470c:	40 ae       	mov.aa %a14,%sp
8000470e:	20 08       	sub.a %sp,8
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
80004710:	d9 e4 fc ff 	lea %a4,[%a14]-4
80004714:	6d ff 9a fd 	call 80004248 <prvGetNextExpireTime>
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
80004718:	19 e5 fc ff 	ld.w %d5,[%a14]-4
8000471c:	02 24       	mov %d4,%d2
8000471e:	6d ff 24 ff 	call 80004566 <prvProcessTimerOrBlockTask>
		prvProcessReceivedCommands();
80004722:	6d ff 5b ff 	call 800045d8 <prvProcessReceivedCommands>
	for( ;; )
80004726:	1d ff f5 ff 	j 80004710 <prvTimerTask+0x4>

8000472a <Ifx_Ssw_Pms_Init>:
#pragma GCC optimize ("O1")
#endif

#if (IFX_CFG_SSW_ENABLE_PMS_INIT == 1U)
void Ifx_Ssw_Pms_Init(void)
{
8000472a:	40 ae       	mov.aa %a14,%sp
    uint16 password = MODULE_SCU.SEICON0.B.EPW ^ 0x003F;
8000472c:	91 30 00 2f 	movh.a %a2,61443
80004730:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <bmhd_3_copy+0x40c34a00>>
80004734:	19 22 34 a0 	ld.w %d2,[%a2]692 <f00302b4 <bmhd_3_copy+0x40c2ecb4>>
80004738:	37 02 6e 21 	extr.u %d2,%d2,2,14
    uint32                                      regVal;
    uint16                                      endinitSfty_pw = IfxScuWdt_getGlobalSafetyEndinitPasswordInline();
    const IfxPmsEvr_initSequencePhase          *phaseConfig;
    const IfxPmsEvr_StepDownRegulatorRegConfig *regConfig;

    if (PMS_EVRSTAT.B.EVRC == 1U)
8000473c:	91 50 02 2f 	movh.a %a2,61477
80004740:	d9 22 2c 08 	lea %a2,[%a2]-32724 <f024802c <bmhd_3_copy+0x40e46a2c>>
80004744:	54 23       	ld.w %d3,[%a2]
80004746:	6f 03 04 80 	jnz.t %d3,0,8000474e <Ifx_Ssw_Pms_Init+0x24>
}


IFX_SSW_INLINE void Ifx_Ssw_jumpBackToLink(void)
{
    __asm__ volatile ("ji %a11");
8000474a:	dc 0b       	ji %a11
        __debug();
        /* Application may have call to error handling here */
    }

    Ifx_Ssw_jumpBackToLink();
}
8000474c:	00 90       	ret 
    {
        /*Loop through each configured phase*/
        for (phaseConfig = &sequence->phaseConfig[0];
8000474e:	91 00 00 28 	movh.a %a2,32768
80004752:	d9 23 48 00 	lea %a3,[%a2]1032 <80000408 <IfxPmsEvr_cfgSequenceDefault>>
80004756:	b0 43       	add.a %a3,4
80004758:	d4 33       	ld.a %a3,[%a3]
             phaseConfig < &sequence->phaseConfig[sequence->numOfPhases];
8000475a:	39 27 48 00 	ld.bu %d7,[%a2]1032 <80000408 <IfxPmsEvr_cfgSequenceDefault>>
8000475e:	53 c7 20 70 	mul %d7,%d7,12
80004762:	80 33       	mov.d %d3,%a3
80004764:	42 73       	add %d3,%d7
80004766:	80 34       	mov.d %d4,%a3
80004768:	7f 34 f1 ff 	jge.u %d4,%d3,8000474a <Ifx_Ssw_Pms_Init+0x20>
             phaseConfig++)
        {
            IfxScuWdt_clearGlobalSafetyEndinitInline(endinitSfty_pw);
8000476c:	8f f2 83 21 	xor %d2,%d2,63
    MODULE_SCU.SEICON0.U = (0xFFFCU << 16U) | (password << IFX_SCU_SEICON0_EPW_OFF);
80004770:	06 22       	sh %d2,2
80004772:	7b c0 ff 1f 	movh %d1,65532
80004776:	a6 21       	or %d1,%d2
    MODULE_SCU.SEICON0.U = (0xFFFCU << 16U) | (password << IFX_SCU_SEICON0_EPW_OFF) | (1 << IFX_SCU_SEICON0_ENDINIT_OFF);
80004778:	7b c0 ff 0f 	movh %d0,65532
8000477c:	c2 20       	add %d0,2
8000477e:	a6 20       	or %d0,%d2
    boolean                                     pmsInitDone    = TRUE;
80004780:	82 18       	mov %d8,1
    MODULE_SCU.SEICON0.U = (0xFFFCU << 16U) | (password << IFX_SCU_SEICON0_EPW_OFF);
80004782:	91 30 00 4f 	movh.a %a4,61443
80004786:	d9 44 00 06 	lea %a4,[%a4]24576 <f0036000 <bmhd_3_copy+0x40c34a00>>
    while (MODULE_SCU.SEICON0.B.ENDINIT == 1)
8000478a:	02 84       	mov %d4,%d8
                 * However, for this function, as this is used only with CPU0 startup no wait required
                 */
                (*((volatile uint32 *)regConfig->regAddr)) = regVal; /*Write to the physical register*/
            }

            PMS_EVRSDCTRL0.B.UP = 1;
8000478c:	91 50 02 5f 	movh.a %a5,61477
80004790:	d9 55 08 48 	lea %a5,[%a5]-32504 <f0248108 <bmhd_3_copy+0x40e46b08>>
            /*Now, wait for the UP bit at EVRSDCTRL0 is reset, which is to indicate the configurations are done*/
            do
            {
                if (--timeoutCount <= 0)
                {
                    pmsInitDone = FALSE;
80004794:	82 09       	mov %d9,0
}


IFX_INLINE void IfxPmsEvr_wait(float32 waitInSec)
{
    uint32 stmCount      = (uint32)((float32)33000000UL * waitInSec);
80004796:	7b c0 bf 64 	movh %d6,19452
8000479a:	1b 06 52 6c 	addi %d6,%d6,-15072
    uint32 stmCountBegin = STM0_TIM0.U;     /* it is necessary to get this value to have minimum 100uS delay in subsequent CPU start */
8000479e:	c5 f6 10 01 	lea %a6,f0001010 <bmhd_3_copy+0x40bffa10>
             phaseConfig < &sequence->phaseConfig[sequence->numOfPhases];
800047a2:	d9 2c 48 00 	lea %a12,[%a2]1032 <80000408 <IfxPmsEvr_cfgSequenceDefault>>
800047a6:	1d 00 15 00 	j 800047d0 <Ifx_Ssw_Pms_Init+0xa6>
    uint32 stmCount      = (uint32)((float32)33000000UL * waitInSec);
800047aa:	19 32 08 00 	ld.w %d2,[%a3]8
800047ae:	4b 26 41 20 	mul.f %d2,%d6,%d2
800047b2:	4b 02 71 31 	ftouz %d3,%d2
    uint32 stmCountBegin = STM0_TIM0.U;     /* it is necessary to get this value to have minimum 100uS delay in subsequent CPU start */
800047b6:	54 65       	ld.w %d5,[%a6]

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
800047b8:	54 62       	ld.w %d2,[%a6]
800047ba:	a2 52       	sub %d2,%d5
800047bc:	3f 32 fe ff 	jlt.u %d2,%d3,800047b8 <Ifx_Ssw_Pms_Init+0x8e>
             phaseConfig++)
800047c0:	d9 33 0c 00 	lea %a3,[%a3]12
             phaseConfig < &sequence->phaseConfig[sequence->numOfPhases];
800047c4:	19 c2 04 00 	ld.w %d2,[%a12]4
800047c8:	42 72       	add %d2,%d7
800047ca:	80 33       	mov.d %d3,%a3
800047cc:	7f 23 3d 80 	jge.u %d3,%d2,80004846 <Ifx_Ssw_Pms_Init+0x11c>
    MODULE_SCU.SEICON0.U = (0xFFFCU << 16U) | (password << IFX_SCU_SEICON0_EPW_OFF);
800047d0:	59 41 34 a0 	st.w [%a4]692 <f00302b4 <bmhd_3_copy+0x40c2ecb4>>,%d1
    while (MODULE_SCU.SEICON0.B.ENDINIT == 1)
800047d4:	19 42 34 a0 	ld.w %d2,[%a4]692 <f00302b4 <bmhd_3_copy+0x40c2ecb4>>
800047d8:	37 02 e1 20 	extr.u %d2,%d2,1,1
800047dc:	5f 42 fc 7f 	jeq %d2,%d4,800047d4 <Ifx_Ssw_Pms_Init+0xaa>
            for (regConfig = &phaseConfig->regConfig[0];
800047e0:	99 32 04 00 	ld.a %a2,[%a3]4
                 regConfig < &phaseConfig->regConfig[phaseConfig->numOfRegisters];
800047e4:	14 32       	ld.bu %d2,[%a3]
800047e6:	80 23       	mov.d %d3,%a2
800047e8:	13 c2 20 23 	madd %d2,%d3,%d2,12
800047ec:	7f 23 16 80 	jge.u %d3,%d2,80004818 <Ifx_Ssw_Pms_Init+0xee>
                regVal  = (*((volatile uint32 *)regConfig->regAddr));
800047f0:	d4 27       	ld.a %a7,[%a2]
800047f2:	54 72       	ld.w %d2,[%a7]
                regVal &= ~regConfig->mask;
800047f4:	19 23 08 00 	ld.w %d3,[%a2]8
800047f8:	0f 32 e0 20 	andn %d2,%d2,%d3
                regVal |= regConfig->value;
800047fc:	19 23 04 00 	ld.w %d3,[%a2]4
80004800:	a6 32       	or %d2,%d3
                (*((volatile uint32 *)regConfig->regAddr)) = regVal; /*Write to the physical register*/
80004802:	74 72       	st.w [%a7],%d2
                 regConfig++)
80004804:	d9 22 0c 00 	lea %a2,[%a2]12
                 regConfig < &phaseConfig->regConfig[phaseConfig->numOfRegisters];
80004808:	14 32       	ld.bu %d2,[%a3]
8000480a:	19 33 04 00 	ld.w %d3,[%a3]4
8000480e:	13 c2 20 23 	madd %d2,%d3,%d2,12
80004812:	80 23       	mov.d %d3,%a2
80004814:	3f 23 ee ff 	jlt.u %d3,%d2,800047f0 <Ifx_Ssw_Pms_Init+0xc6>
            PMS_EVRSDCTRL0.B.UP = 1;
80004818:	54 52       	ld.w %d2,[%a5]
8000481a:	b7 12 01 2f 	insert %d2,%d2,1,30,1
8000481e:	74 52       	st.w [%a5],%d2
    MODULE_SCU.SEICON0.U = (0xFFFCU << 16U) | (password << IFX_SCU_SEICON0_EPW_OFF) | (1 << IFX_SCU_SEICON0_ENDINIT_OFF);
80004820:	59 40 34 a0 	st.w [%a4]692 <f00302b4 <bmhd_3_copy+0x40c2ecb4>>,%d0
    while (MODULE_SCU.SEICON0.B.ENDINIT == 0)
80004824:	19 42 34 a0 	ld.w %d2,[%a4]692 <f00302b4 <bmhd_3_copy+0x40c2ecb4>>
80004828:	6f 12 fe 7f 	jz.t %d2,1,80004824 <Ifx_Ssw_Pms_Init+0xfa>
8000482c:	3b f0 0f 20 	mov %d2,255
            } while (PMS_EVRSDCTRL0.B.UP == 1);
80004830:	54 53       	ld.w %d3,[%a5]
80004832:	37 03 61 3f 	extr.u %d3,%d3,30,1
80004836:	5f 43 ba ff 	jne %d3,%d4,800047aa <Ifx_Ssw_Pms_Init+0x80>
                if (--timeoutCount <= 0)
8000483a:	c2 f2       	add %d2,-1
8000483c:	df 02 fa ff 	jne %d2,0,80004830 <Ifx_Ssw_Pms_Init+0x106>
                    pmsInitDone = FALSE;
80004840:	02 98       	mov %d8,%d9
80004842:	1d ff b4 ff 	j 800047aa <Ifx_Ssw_Pms_Init+0x80>
    if (IfxPmsEvr_runInitSequence(&IfxPmsEvr_cfgSequenceDefault) == 0)
80004846:	df 08 82 ff 	jne %d8,0,8000474a <Ifx_Ssw_Pms_Init+0x20>
8000484a:	00 a0       	debug 
}
8000484c:	1d ff 7f ff 	j 8000474a <Ifx_Ssw_Pms_Init+0x20>

80004850 <Ifx_Ssw_Pms_InitCheck>:

#if (IFX_CFG_SSW_ENABLE_PMS_INIT_CHECK == 1U)
void Ifx_Ssw_Pms_InitCheck(void)
{
80004850:	40 ae       	mov.aa %a14,%sp
    if (PMS_EVRSTAT.B.EVRC == 1U)
80004852:	91 50 02 2f 	movh.a %a2,61477
80004856:	d9 22 2c 08 	lea %a2,[%a2]-32724 <f024802c <bmhd_3_copy+0x40e46a2c>>
8000485a:	54 22       	ld.w %d2,[%a2]
8000485c:	6f 02 04 80 	jnz.t %d2,0,80004864 <Ifx_Ssw_Pms_InitCheck+0x14>
80004860:	dc 0b       	ji %a11
    {
        __debug();
        /* Application may have call to error handling here */
    }
    Ifx_Ssw_jumpBackToLink();
}
80004862:	00 90       	ret 
        for (regCfgCount = 0; regCfgCount < checkConfig->numOfRegisters; regCfgCount++)
80004864:	91 00 00 28 	movh.a %a2,32768
80004868:	39 25 38 b0 	ld.bu %d5,[%a2]760 <800002f8 <IfxPmsEvr_checkRegCfgDefault>>
8000486c:	bf 15 1d 00 	jlt %d5,1,800048a6 <Ifx_Ssw_Pms_InitCheck+0x56>
            const IfxPmsEvr_StepDownRegulatorRegConfig *regConfig = &checkConfig->regConfig[regCfgCount];
80004870:	d9 22 38 b0 	lea %a2,[%a2]760 <800002f8 <IfxPmsEvr_checkRegCfgDefault>>
80004874:	b0 42       	add.a %a2,4
80004876:	d4 22       	ld.a %a2,[%a2]
    boolean allRight = TRUE;
80004878:	82 12       	mov %d2,1
        for (regCfgCount = 0; regCfgCount < checkConfig->numOfRegisters; regCfgCount++)
8000487a:	82 03       	mov %d3,0
            regVal  = (*((volatile uint32 *)regConfig->regAddr));
8000487c:	d4 23       	ld.a %a3,[%a2]
8000487e:	54 34       	ld.w %d4,[%a3]
            regVal &= regConfig->mask;
80004880:	19 26 08 00 	ld.w %d6,[%a2]8
80004884:	26 64       	and %d4,%d6
            if (regVal != regConfig->value)
80004886:	19 26 04 00 	ld.w %d6,[%a2]4
                allRight = FALSE;
8000488a:	0b 64 00 41 	eq %d4,%d4,%d6
8000488e:	ab 02 80 24 	sel %d2,%d4,%d2,0
        for (regCfgCount = 0; regCfgCount < checkConfig->numOfRegisters; regCfgCount++)
80004892:	c2 13       	add %d3,1
80004894:	d9 22 0c 00 	lea %a2,[%a2]12
80004898:	5f 53 f2 ff 	jne %d3,%d5,8000487c <Ifx_Ssw_Pms_InitCheck+0x2c>
        if (allRight == TRUE)
8000489c:	df 12 05 00 	jeq %d2,1,800048a6 <Ifx_Ssw_Pms_InitCheck+0x56>
    __asm__ volatile ("debug" : : : "memory");
800048a0:	00 a0       	debug 
}
800048a2:	1d ff df ff 	j 80004860 <Ifx_Ssw_Pms_InitCheck+0x10>
            if (PMS_EVRSTAT.B.SDVOK != 1)
800048a6:	91 50 02 2f 	movh.a %a2,61477
800048aa:	d9 22 2c 08 	lea %a2,[%a2]-32724 <f024802c <bmhd_3_copy+0x40e46a2c>>
800048ae:	54 22       	ld.w %d2,[%a2]
800048b0:	ef 52 d8 ff 	jnz.t %d2,21,80004860 <Ifx_Ssw_Pms_InitCheck+0x10>
800048b4:	1d ff f6 ff 	j 800048a0 <Ifx_Ssw_Pms_InitCheck+0x50>

800048b8 <LDE1>:
 *
 *
 */

void LDE1(void *pvParameters)
{
800048b8:	40 ae       	mov.aa %a14,%sp
    for(;;)
    {
        IfxPort_setPinState(g_led1.port, g_led1.pinIndex,  IfxPort_State_toggled);
800048ba:	91 10 00 27 	movh.a %a2,28673
800048be:	d9 23 1c 60 	lea %a3,[%a2]412 <7001019c <g_led1>>
800048c2:	99 22 1c 60 	ld.a %a2,[%a2]412 <7001019c <g_led1>>
800048c6:	39 32 04 00 	ld.bu %d2,[%a3]4 <7001019c <g_led1>>
}


IFX_INLINE void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
800048ca:	7b 10 00 30 	movh %d3,1
800048ce:	c2 13       	add %d3,1
800048d0:	0f 23 00 20 	sh %d2,%d3,%d2
800048d4:	59 22 04 00 	st.w [%a2]4,%d2
        //printf("finish");
        ++cnt;
800048d8:	91 10 00 27 	movh.a %a2,28673
800048dc:	d9 23 38 50 	lea %a3,[%a2]376 <70010178 <cnt>>
800048e0:	54 32       	ld.w %d2,[%a3]
800048e2:	c2 12       	add %d2,1
800048e4:	59 22 38 50 	st.w [%a2]376 <70010178 <cnt>>,%d2
        vTaskDelay(4294967295);
800048e8:	82 f4       	mov %d4,-1
800048ea:	6d ff e0 fb 	call 800040aa <vTaskDelay>
    for(;;)
800048ee:	1d ff e6 ff 	j 800048ba <LDE1+0x2>

800048f2 <canIsrTxHandler>:
    }
}


void canIsrTxHandler(void)
{
800048f2:	40 ae       	mov.aa %a14,%sp
    /* Clear the "Transmission Completed" interrupt flag */
    //����
    IfxCan_Node_clearInterruptFlag(g_mcmcan.canSrcNode.node, IfxCan_Interrupt_transmissionCompleted);
800048f4:	91 10 00 27 	movh.a %a2,28673
800048f8:	d9 22 54 70 	lea %a2,[%a2]1492 <700105d4 <g_mcmcan>>
800048fc:	d9 22 0c 00 	lea %a2,[%a2]12 <7001000c <_SMALL_DATA_+0x800c>>
80004900:	d4 22       	ld.a %a2,[%a2]
    node->IR.U = value;
80004902:	3b 00 20 20 	mov %d2,512
80004906:	59 22 10 50 	st.w [%a2]336,%d2
    /* Just to indicate that the CAN message has been transmitted by turning on LED1 */
    IfxPort_setPinLow(g_led1.port, g_led1.pinIndex);
8000490a:	91 10 00 27 	movh.a %a2,28673
8000490e:	d9 23 1c 60 	lea %a3,[%a2]412 <7001019c <g_led1>>
80004912:	99 22 1c 60 	ld.a %a2,[%a2]412 <7001019c <g_led1>>
80004916:	39 32 04 00 	ld.bu %d2,[%a3]4 <7001019c <g_led1>>
8000491a:	7b 10 00 30 	movh %d3,1
8000491e:	0f 23 00 20 	sh %d2,%d3,%d2
80004922:	59 22 04 00 	st.w [%a2]4,%d2
//    {
//        /* Turn on the LED2 to indicate correctness of the received message */
//        IfxPort_setPinLow(g_led2.port, g_led2.pinIndex);
//    }

}
80004926:	0d 00 40 02 	rslcx 
8000492a:	00 80       	rfe 

8000492c <canIsrTxHandler1>:

void canIsrTxHandler1(void)
{
8000492c:	40 ae       	mov.aa %a14,%sp
    /* Clear the "Transmission Completed" interrupt flag */
    //����
    IfxCan_Node_clearInterruptFlag(g_mcmcan1.canSrcNode.node, IfxCan_Interrupt_transmissionCompleted);
8000492e:	91 10 00 27 	movh.a %a2,28673
80004932:	d9 22 00 f0 	lea %a2,[%a2]960 <700103c0 <g_mcmcan1>>
80004936:	d9 22 0c 00 	lea %a2,[%a2]12 <7001000c <_SMALL_DATA_+0x800c>>
8000493a:	d4 22       	ld.a %a2,[%a2]
8000493c:	3b 00 20 20 	mov %d2,512
80004940:	59 22 10 50 	st.w [%a2]336,%d2
    /* Just to indicate that the CAN message has been transmitted by turning on LED1 */
    IfxPort_setPinLow(g_led3.port, g_led3.pinIndex);
80004944:	91 10 00 27 	movh.a %a2,28673
80004948:	d9 23 3c 50 	lea %a3,[%a2]380 <7001017c <g_led3>>
8000494c:	99 22 3c 50 	ld.a %a2,[%a2]380 <7001017c <g_led3>>
80004950:	39 32 04 00 	ld.bu %d2,[%a3]4 <7001017c <g_led3>>
80004954:	7b 10 00 30 	movh %d3,1
80004958:	0f 23 00 20 	sh %d2,%d3,%d2
8000495c:	59 22 04 00 	st.w [%a2]4,%d2
//    {
//        /* Turn on the LED2 to indicate correctness of the received message */
//        IfxPort_setPinLow(g_led2.port, g_led2.pinIndex);
//    }

}
80004960:	0d 00 40 02 	rslcx 
80004964:	00 80       	rfe 

80004966 <canIsrTxHandler2>:

void canIsrTxHandler2(void)
{
80004966:	40 ae       	mov.aa %a14,%sp
    /* Clear the "Transmission Completed" interrupt flag */
    //����
    IfxCan_Node_clearInterruptFlag(g_mcmcan2.canSrcNode.node, IfxCan_Interrupt_transmissionCompleted);
80004968:	91 10 00 27 	movh.a %a2,28673
8000496c:	d9 22 2c 60 	lea %a2,[%a2]428 <700101ac <g_mcmcan2>>
80004970:	d9 22 0c 00 	lea %a2,[%a2]12 <7001000c <_SMALL_DATA_+0x800c>>
80004974:	d4 22       	ld.a %a2,[%a2]
80004976:	3b 00 20 20 	mov %d2,512
8000497a:	59 22 10 50 	st.w [%a2]336,%d2
    /* Just to indicate that the CAN message has been transmitted by turning on LED1 */
    IfxPort_setPinLow(g_led3.port, g_led3.pinIndex);
8000497e:	91 10 00 27 	movh.a %a2,28673
80004982:	d9 23 3c 50 	lea %a3,[%a2]380 <7001017c <g_led3>>
80004986:	99 22 3c 50 	ld.a %a2,[%a2]380 <7001017c <g_led3>>
8000498a:	39 32 04 00 	ld.bu %d2,[%a3]4 <7001017c <g_led3>>
8000498e:	7b 10 00 30 	movh %d3,1
80004992:	0f 23 00 20 	sh %d2,%d3,%d2
80004996:	59 22 04 00 	st.w [%a2]4,%d2
//    {
//        /* Turn on the LED2 to indicate correctness of the received message */
//        IfxPort_setPinLow(g_led2.port, g_led2.pinIndex);
//    }

}
8000499a:	0d 00 40 02 	rslcx 
8000499e:	00 80       	rfe 

800049a0 <canIsrRxHandler>:
/* Interrupt Service Routine (ISR) called once the RX interrupt has been generated.
 * Compares the content of the received CAN message with the content of the transmitted CAN message
 * and in case of success, turns on the LED2 to indicate successful CAN message reception.
 */
void canIsrRxHandler(void)
{
800049a0:	40 ae       	mov.aa %a14,%sp
    /* Clear the "Message stored to Dedicated RX Buffer" interrupt flag */
    IfxCan_Node_clearInterruptFlag(g_mcmcan.canDstNode.node, IfxCan_Interrupt_rxFifo0NewMessage);
800049a2:	91 10 00 47 	movh.a %a4,28673
800049a6:	d9 44 54 70 	lea %a4,[%a4]1492 <700105d4 <g_mcmcan>>
800049aa:	99 42 2c 00 	ld.a %a2,[%a4]44 <7001002c <uxTaskNumber>>
800049ae:	82 12       	mov %d2,1
800049b0:	59 22 10 50 	st.w [%a2]336,%d2

    /* Read the received CAN message */
    g_mcmcan.rxMsg.readFromRxFifo0 = TRUE;
800049b4:	e9 42 02 80 	st.b [%a4]514 <70010202 <g_mcmcan2+0x56>>,%d2
    //g_mcmcan.rxMsg.readFromRxFifo1 = FALSE;

    IfxCan_Can_readMessage(&g_mcmcan.canDstNode, &g_mcmcan.rxMsg, g_mcmcan.rxData);
800049b8:	d9 46 0c 80 	lea %a6,[%a4]524 <7001020c <g_mcmcan2+0x60>>
800049bc:	d9 45 24 70 	lea %a5,[%a4]484 <700101e4 <g_mcmcan2+0x38>>
800049c0:	d9 44 28 00 	lea %a4,[%a4]40 <70010028 <xNextTaskUnblockTime>>
800049c4:	6d ff ab eb 	call 8000211a <IfxCan_Can_readMessage>
    IfxPort_setPinState(g_led2.port, g_led2.pinIndex,  IfxPort_State_toggled);
800049c8:	91 10 00 27 	movh.a %a2,28673
800049cc:	d9 23 0c 60 	lea %a3,[%a2]396 <7001018c <g_led2>>
800049d0:	99 22 0c 60 	ld.a %a2,[%a2]396 <7001018c <g_led2>>
800049d4:	39 32 04 00 	ld.bu %d2,[%a3]4 <7001018c <g_led2>>
800049d8:	7b 10 00 30 	movh %d3,1
800049dc:	c2 13       	add %d3,1
800049de:	0f 23 00 20 	sh %d2,%d3,%d2
800049e2:	59 22 04 00 	st.w [%a2]4,%d2
//        ( g_mcmcan.rxMsg.messageId == g_mcmcan.txMsg.messageId ) )
//    {
//        /* Turn on the LED2 to indicate correctness of the received message */
//        IfxPort_setPinLow(g_led2.port, g_led2.pinIndex);
//    }
}
800049e6:	0d 00 40 02 	rslcx 
800049ea:	00 80       	rfe 

800049ec <canIsrRxHandler1>:

void canIsrRxHandler1(void)
{
800049ec:	40 ae       	mov.aa %a14,%sp
    /* Clear the "Message stored to Dedicated RX Buffer" interrupt flag */
    IfxCan_Node_clearInterruptFlag(g_mcmcan1.canDstNode.node, IfxCan_Interrupt_rxFifo0NewMessage);
800049ee:	91 10 00 47 	movh.a %a4,28673
800049f2:	d9 44 00 f0 	lea %a4,[%a4]960 <700103c0 <g_mcmcan1>>
800049f6:	99 42 2c 00 	ld.a %a2,[%a4]44 <7001002c <uxTaskNumber>>
800049fa:	82 12       	mov %d2,1
800049fc:	59 22 10 50 	st.w [%a2]336,%d2

    /* Read the received CAN message */
    g_mcmcan1.rxMsg.readFromRxFifo0 = TRUE;
80004a00:	e9 42 02 80 	st.b [%a4]514 <70010202 <g_mcmcan2+0x56>>,%d2
    //g_mcmcan1.rxMsg.readFromRxFifo1 = FALSE;

    IfxCan_Can_readMessage(&g_mcmcan1.canDstNode, &g_mcmcan1.rxMsg, g_mcmcan1.rxData);
80004a04:	d9 46 0c 80 	lea %a6,[%a4]524 <7001020c <g_mcmcan2+0x60>>
80004a08:	d9 45 24 70 	lea %a5,[%a4]484 <700101e4 <g_mcmcan2+0x38>>
80004a0c:	d9 44 28 00 	lea %a4,[%a4]40 <70010028 <xNextTaskUnblockTime>>
80004a10:	6d ff 85 eb 	call 8000211a <IfxCan_Can_readMessage>
    IfxPort_setPinState(g_led2.port, g_led2.pinIndex,  IfxPort_State_toggled);
80004a14:	91 10 00 27 	movh.a %a2,28673
80004a18:	d9 23 0c 60 	lea %a3,[%a2]396 <7001018c <g_led2>>
80004a1c:	99 22 0c 60 	ld.a %a2,[%a2]396 <7001018c <g_led2>>
80004a20:	39 32 04 00 	ld.bu %d2,[%a3]4 <7001018c <g_led2>>
80004a24:	7b 10 00 30 	movh %d3,1
80004a28:	c2 13       	add %d3,1
80004a2a:	0f 23 00 20 	sh %d2,%d3,%d2
80004a2e:	59 22 04 00 	st.w [%a2]4,%d2
//        ( g_mcmcan.rxMsg.messageId == g_mcmcan.txMsg.messageId ) )
//    {
//        /* Turn on the LED2 to indicate correctness of the received message */
//        IfxPort_setPinLow(g_led2.port, g_led2.pinIndex);
//    }
}
80004a32:	0d 00 40 02 	rslcx 
80004a36:	00 80       	rfe 

80004a38 <canIsrRxHandler2>:


void canIsrRxHandler2(void)
{
80004a38:	40 ae       	mov.aa %a14,%sp
    /* Clear the "Message stored to Dedicated RX Buffer" interrupt flag */
    IfxCan_Node_clearInterruptFlag(g_mcmcan2.canDstNode.node, IfxCan_Interrupt_rxFifo0NewMessage);
80004a3a:	91 10 00 47 	movh.a %a4,28673
80004a3e:	d9 44 2c 60 	lea %a4,[%a4]428 <700101ac <g_mcmcan2>>
80004a42:	99 42 2c 00 	ld.a %a2,[%a4]44 <7001002c <uxTaskNumber>>
80004a46:	82 12       	mov %d2,1
80004a48:	59 22 10 50 	st.w [%a2]336,%d2

    /* Read the received CAN message */
    g_mcmcan2.rxMsg.readFromRxFifo0 = TRUE;
80004a4c:	e9 42 02 80 	st.b [%a4]514 <70010202 <g_mcmcan2+0x56>>,%d2
    //g_mcmcan1.rxMsg.readFromRxFifo1 = FALSE;

    IfxCan_Can_readMessage(&g_mcmcan2.canDstNode, &g_mcmcan2.rxMsg, g_mcmcan2.rxData);
80004a50:	d9 46 0c 80 	lea %a6,[%a4]524 <7001020c <g_mcmcan2+0x60>>
80004a54:	d9 45 24 70 	lea %a5,[%a4]484 <700101e4 <g_mcmcan2+0x38>>
80004a58:	d9 44 28 00 	lea %a4,[%a4]40 <70010028 <xNextTaskUnblockTime>>
80004a5c:	6d ff 5f eb 	call 8000211a <IfxCan_Can_readMessage>
    IfxPort_setPinState(g_led2.port, g_led2.pinIndex,  IfxPort_State_toggled);
80004a60:	91 10 00 27 	movh.a %a2,28673
80004a64:	d9 23 0c 60 	lea %a3,[%a2]396 <7001018c <g_led2>>
80004a68:	99 22 0c 60 	ld.a %a2,[%a2]396 <7001018c <g_led2>>
80004a6c:	39 32 04 00 	ld.bu %d2,[%a3]4 <7001018c <g_led2>>
80004a70:	7b 10 00 30 	movh %d3,1
80004a74:	c2 13       	add %d3,1
80004a76:	0f 23 00 20 	sh %d2,%d3,%d2
80004a7a:	59 22 04 00 	st.w [%a2]4,%d2
//        ( g_mcmcan.rxMsg.messageId == g_mcmcan.txMsg.messageId ) )
//    {
//        /* Turn on the LED2 to indicate correctness of the received message */
//        IfxPort_setPinLow(g_led2.port, g_led2.pinIndex);
//    }
}
80004a7e:	0d 00 40 02 	rslcx 
80004a82:	00 80       	rfe 

80004a84 <initLeds>:
    }
}

/* Function to initialize the LEDs */
void initLeds(void)
{
80004a84:	40 ae       	mov.aa %a14,%sp
     *  - define the GPIO pin that is connected to the LED
     *  - define the general GPIO pin usage (no alternate function used)
     *  - define the pad driver strength
     * ======================================================================
     */
    g_led1.port      = &MODULE_P21;
80004a86:	7b 10 00 a7 	movh %d10,28673
80004a8a:	60 a2       	mov.a %a2,%d10
80004a8c:	d9 2f 1c 60 	lea %a15,[%a2]412
80004a90:	91 40 00 4f 	movh.a %a4,61444
80004a94:	d9 44 40 4b 	lea %a4,[%a4]-19200 <f003b500 <bmhd_3_copy+0x40c39f00>>
80004a98:	b5 24 1c 60 	st.a [%a2]412 <f003b500 <bmhd_3_copy+0x40c39f00>>,%a4
    g_led1.pinIndex  = 4;
80004a9c:	82 42       	mov %d2,4
80004a9e:	28 42       	st.b [%a15]4,%d2
    g_led1.mode      = IfxPort_OutputIdx_general;
80004aa0:	3b 00 08 50 	mov %d5,128
80004aa4:	68 25       	st.w [%a15]8,%d5
    g_led1.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1;
80004aa6:	82 02       	mov %d2,0
80004aa8:	68 32       	st.w [%a15]12,%d2

    g_led2.port      = &MODULE_P21;
80004aaa:	7b 10 00 97 	movh %d9,28673
80004aae:	60 92       	mov.a %a2,%d9
80004ab0:	d9 2d 0c 60 	lea %a13,[%a2]396
80004ab4:	b5 24 0c 60 	st.a [%a2]396,%a4
    g_led2.pinIndex  = 5;
80004ab8:	82 53       	mov %d3,5
80004aba:	e9 d3 04 00 	st.b [%a13]4,%d3
    g_led2.mode      = IfxPort_OutputIdx_general;
80004abe:	59 d5 08 00 	st.w [%a13]8,%d5
    g_led2.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1;
80004ac2:	59 d2 0c 00 	st.w [%a13]12,%d2

    g_led3.port      = &MODULE_P20;
80004ac6:	7b 10 00 87 	movh %d8,28673
80004aca:	60 82       	mov.a %a2,%d8
80004acc:	d9 2c 3c 50 	lea %a12,[%a2]380
80004ad0:	91 40 00 2f 	movh.a %a2,61444
80004ad4:	d9 22 40 0b 	lea %a2,[%a2]-19456 <f003b400 <bmhd_3_copy+0x40c39e00>>
80004ad8:	60 83       	mov.a %a3,%d8
80004ada:	b5 32 3c 50 	st.a [%a3]380,%a2
    g_led3.pinIndex  = 9;
80004ade:	3b 90 00 30 	mov %d3,9
80004ae2:	e9 c3 04 00 	st.b [%a12]4,%d3
    g_led3.mode      = IfxPort_OutputIdx_general;
80004ae6:	59 c5 08 00 	st.w [%a12]8,%d5
    g_led3.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1;
80004aea:	59 c2 0c 00 	st.w [%a12]12,%d2
80004aee:	3b 00 01 20 	mov %d2,16
80004af2:	d9 43 04 00 	lea %a3,[%a4]4 <f0040004 <bmhd_3_copy+0x40c3ea04>>
80004af6:	59 42 04 00 	st.w [%a4]4 <f0040004 <bmhd_3_copy+0x40c3ea04>>,%d2
80004afa:	3b 00 02 20 	mov %d2,32
80004afe:	74 32       	st.w [%a3],%d2
80004b00:	3b 00 20 20 	mov %d2,512
80004b04:	59 22 04 00 	st.w [%a2]4 <f0040004 <bmhd_3_copy+0x40c3ea04>>,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
80004b08:	82 44       	mov %d4,4
80004b0a:	6d ff 9b e8 	call 80001c40 <IfxPort_setPinMode>
    IfxPort_setPinHigh(g_led2.port, g_led2.pinIndex);
    IfxPort_setPinHigh(g_led3.port, g_led3.pinIndex);

    /* Set the pin input/output mode for both pins connected to the LEDs */
    IfxPort_setPinModeOutput(g_led1.port, g_led1.pinIndex, IfxPort_OutputMode_pushPull, g_led1.mode);
    IfxPort_setPinModeOutput(g_led2.port, g_led2.pinIndex, IfxPort_OutputMode_pushPull, g_led2.mode);
80004b0e:	19 d5 08 00 	ld.w %d5,[%a13]8
80004b12:	8f 05 48 51 	or %d5,%d5,128
80004b16:	39 d4 04 00 	ld.bu %d4,[%a13]4
80004b1a:	60 92       	mov.a %a2,%d9
80004b1c:	99 24 0c 60 	ld.a %a4,[%a2]396
80004b20:	6d ff 90 e8 	call 80001c40 <IfxPort_setPinMode>
    IfxPort_setPinModeOutput(g_led3.port, g_led3.pinIndex, IfxPort_OutputMode_pushPull, g_led3.mode);
80004b24:	19 c5 08 00 	ld.w %d5,[%a12]8
80004b28:	8f 05 48 51 	or %d5,%d5,128
80004b2c:	39 c4 04 00 	ld.bu %d4,[%a12]4
80004b30:	60 82       	mov.a %a2,%d8
80004b32:	99 24 3c 50 	ld.a %a4,[%a2]380
80004b36:	6d ff 85 e8 	call 80001c40 <IfxPort_setPinMode>

    /* Set the pad driver mode for both pins connected to the LEDs */
    IfxPort_setPinPadDriver(g_led1.port, g_led1.pinIndex, g_led1.padDriver);
80004b3a:	48 35       	ld.w %d5,[%a15]12
80004b3c:	08 44       	ld.bu %d4,[%a15]4
80004b3e:	60 a2       	mov.a %a2,%d10
80004b40:	99 24 1c 60 	ld.a %a4,[%a2]412
80004b44:	6d ff bb e8 	call 80001cba <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(g_led2.port, g_led2.pinIndex, g_led2.padDriver);
80004b48:	19 d5 0c 00 	ld.w %d5,[%a13]12
80004b4c:	39 d4 04 00 	ld.bu %d4,[%a13]4
80004b50:	60 92       	mov.a %a2,%d9
80004b52:	99 24 0c 60 	ld.a %a4,[%a2]396
80004b56:	6d ff b2 e8 	call 80001cba <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(g_led3.port, g_led3.pinIndex, g_led3.padDriver);
80004b5a:	19 c5 0c 00 	ld.w %d5,[%a12]12
80004b5e:	39 c4 04 00 	ld.bu %d4,[%a12]4
80004b62:	60 82       	mov.a %a2,%d8
80004b64:	99 24 3c 50 	ld.a %a4,[%a2]380
80004b68:	6d ff a9 e8 	call 80001cba <IfxPort_setPinPadDriver>
}
80004b6c:	00 90       	ret 

80004b6e <__fixunsdfsi>:
80004b6e:	82 06       	mov %d6,0
80004b70:	7b 00 1e 74 	movh %d7,16864
80004b74:	60 4d       	mov.a %a13,%d4
80004b76:	60 5c       	mov.a %a12,%d5
80004b78:	6d 00 91 02 	call 8000509a <__gedf2>
80004b7c:	ff 02 07 00 	jge %d2,0,80004b8a <__fixunsdfsi+0x1c>
80004b80:	80 d4       	mov.d %d4,%a13
80004b82:	80 c5       	mov.d %d5,%a12
80004b84:	6d 00 ab 02 	call 800050da <__fixdfsi>
80004b88:	00 90       	ret 
80004b8a:	82 06       	mov %d6,0
80004b8c:	7b 00 1e 74 	movh %d7,16864
80004b90:	80 d4       	mov.d %d4,%a13
80004b92:	80 c5       	mov.d %d5,%a12
80004b94:	6d 00 4e 01 	call 80004e30 <__subdf3>
80004b98:	0b 23 10 48 	mov %e4,%d3,%d2
80004b9c:	6d 00 9f 02 	call 800050da <__fixdfsi>
80004ba0:	9b 02 00 28 	addih %d2,%d2,32768
80004ba4:	00 90       	ret 

80004ba6 <__extendsfdf2>:
80004ba6:	20 20       	sub.a %sp,32
80004ba8:	d9 a5 10 00 	lea %a5,[%sp]16
80004bac:	d9 a4 0c 00 	lea %a4,[%sp]12
80004bb0:	59 a4 0c 00 	st.w [%sp]12,%d4
80004bb4:	6d 00 e1 02 	call 80005176 <__unpack_f>
80004bb8:	19 a2 1c 00 	ld.w %d2,[%sp]28
80004bbc:	19 a6 18 00 	ld.w %d6,[%sp]24
80004bc0:	53 12 40 40 	mul.u %e4,%d2,1
80004bc4:	77 45 00 3f 	dextr %d3,%d5,%d4,30
80004bc8:	8f e4 01 20 	sh %d2,%d4,30
80004bcc:	19 a5 14 00 	ld.w %d5,[%sp]20
80004bd0:	19 a4 10 00 	ld.w %d4,[%sp]16
80004bd4:	74 a2       	st.w [%sp],%d2
80004bd6:	59 a3 04 00 	st.w [%sp]4,%d3
80004bda:	6d 00 be 02 	call 80005156 <__make_dp>
80004bde:	00 90       	ret 

80004be0 <_fpadd_parts>:
80004be0:	54 42       	ld.w %d2,[%a4]
80004be2:	40 42       	mov.aa %a2,%a4
80004be4:	bf 22 c2 80 	jlt.u %d2,2,80004d68 <_fpadd_parts+0x188>
80004be8:	54 53       	ld.w %d3,[%a5]
80004bea:	40 52       	mov.aa %a2,%a5
80004bec:	bf 23 be 80 	jlt.u %d3,2,80004d68 <_fpadd_parts+0x188>
80004bf0:	df 42 e3 00 	jeq %d2,4,80004db6 <_fpadd_parts+0x1d6>
80004bf4:	df 43 ba 00 	jeq %d3,4,80004d68 <_fpadd_parts+0x188>
80004bf8:	df 23 b9 00 	jeq %d3,2,80004d6a <_fpadd_parts+0x18a>
80004bfc:	df 22 b6 00 	jeq %d2,2,80004d68 <_fpadd_parts+0x188>
80004c00:	19 40 08 00 	ld.w %d0,[%a4]8
80004c04:	19 57 08 00 	ld.w %d7,[%a5]8
80004c08:	09 44 4c 09 	ld.d %e4,[%a4]12
80004c0c:	0b 70 80 60 	sub %d6,%d0,%d7
80004c10:	09 52 4c 09 	ld.d %e2,[%a5]12
80004c14:	bf 06 c2 00 	jlt %d6,0,80004d98 <_fpadd_parts+0x1b8>
80004c18:	8b 06 84 12 	ge %d1,%d6,64
80004c1c:	df 01 c4 80 	jne %d1,0,80004da4 <_fpadd_parts+0x1c4>
80004c20:	df 06 2a 00 	jeq %d6,0,80004c74 <_fpadd_parts+0x94>
80004c24:	8b 06 82 72 	ge %d7,%d6,32
80004c28:	2b 32 50 97 	seln %d9,%d7,%d2,%d3
80004c2c:	ab 03 a0 87 	seln %d8,%d7,%d3,0
80004c30:	8f f6 01 71 	and %d7,%d6,31
80004c34:	8b 07 02 11 	rsub %d1,%d7,32
80004c38:	17 98 80 11 	dextr %d1,%d8,%d9,%d1
80004c3c:	2b 91 40 17 	sel %d1,%d7,%d1,%d9
80004c40:	8b 06 82 a2 	ge %d10,%d6,32
80004c44:	32 57       	rsub %d7
80004c46:	02 19       	mov %d9,%d1
80004c48:	8f f6 01 61 	and %d6,%d6,31
80004c4c:	82 f1       	mov %d1,-1
80004c4e:	0f 78 00 80 	sh %d8,%d8,%d7
80004c52:	17 11 80 76 	dextr %d7,%d1,%d1,%d6
80004c56:	0f 61 00 60 	sh %d6,%d1,%d6
80004c5a:	2b 67 50 7a 	seln %d7,%d10,%d7,%d6
80004c5e:	ab 06 a0 6a 	seln %d6,%d10,%d6,0
80004c62:	0f 62 e0 10 	andn %d1,%d2,%d6
80004c66:	0f 73 e0 60 	andn %d6,%d3,%d7
80004c6a:	a6 16       	or %d6,%d1
80004c6c:	8b 06 00 95 	or.ne %d9,%d6,0
80004c70:	0b 98 10 28 	mov %e2,%d8,%d9
80004c74:	19 41 04 00 	ld.w %d1,[%a4]4
80004c78:	19 56 04 00 	ld.w %d6,[%a5]4
80004c7c:	5f 61 4c 00 	jeq %d1,%d6,80004d14 <_fpadd_parts+0x134>
80004c80:	0b 24 c0 60 	subx %d6,%d4,%d2
80004c84:	0b 35 d0 70 	subc %d7,%d5,%d3
80004c88:	df 01 06 00 	jeq %d1,0,80004c94 <_fpadd_parts+0xb4>
80004c8c:	0b 42 c0 60 	subx %d6,%d2,%d4
80004c90:	0b 53 d0 70 	subc %d7,%d3,%d5
80004c94:	8b 07 00 31 	rsub %d3,%d7,0
80004c98:	8b 06 00 91 	rsub %d9,%d6,0
80004c9c:	ab f3 1f 36 	cadd %d3,%d6,%d3,-1
80004ca0:	82 12       	mov %d2,1
80004ca2:	bf 07 05 00 	jlt %d7,0,80004cac <_fpadd_parts+0xcc>
80004ca6:	02 69       	mov %d9,%d6
80004ca8:	02 73       	mov %d3,%d7
80004caa:	82 02       	mov %d2,0
80004cac:	8b f9 9f 70 	addx %d7,%d9,-1
80004cb0:	82 f5       	mov %d5,-1
80004cb2:	8b f3 bf 60 	addc %d6,%d3,-1
80004cb6:	06 c5       	sh %d5,-4
80004cb8:	59 62 04 00 	st.w [%a6]4,%d2
80004cbc:	82 e1       	mov %d1,-2
80004cbe:	0b 56 00 21 	eq %d2,%d6,%d5
80004cc2:	0b 71 30 22 	and.lt.u %d2,%d1,%d7
80004cc6:	59 60 08 00 	st.w [%a6]8,%d0
80004cca:	59 69 0c 00 	st.w [%a6]12,%d9
80004cce:	59 63 10 00 	st.w [%a6]16,%d3
80004cd2:	0b 65 a0 22 	or.lt.u %d2,%d5,%d6
80004cd6:	df 02 2b 80 	jne %d2,0,80004d2c <_fpadd_parts+0x14c>
80004cda:	1b f0 ff 7f 	addi %d7,%d0,-1
80004cde:	77 93 80 30 	dextr %d3,%d3,%d9,1
80004ce2:	06 19       	sh %d9,1
80004ce4:	8b f9 9f 00 	addx %d0,%d9,-1
80004ce8:	8b f3 bf 60 	addc %d6,%d3,-1
80004cec:	0b 56 00 21 	eq %d2,%d6,%d5
80004cf0:	0b 01 50 22 	and.ge.u %d2,%d1,%d0
80004cf4:	0b 56 a0 22 	or.lt.u %d2,%d6,%d5
80004cf8:	02 78       	mov %d8,%d7
80004cfa:	c2 f7       	add %d7,-1
80004cfc:	df 02 f1 ff 	jne %d2,0,80004cde <_fpadd_parts+0xfe>
80004d00:	82 32       	mov %d2,3
80004d02:	59 69 0c 00 	st.w [%a6]12,%d9
80004d06:	59 63 10 00 	st.w [%a6]16,%d3
80004d0a:	59 68 08 00 	st.w [%a6]8,%d8
80004d0e:	74 62       	st.w [%a6],%d2
80004d10:	40 62       	mov.aa %a2,%a6
80004d12:	00 90       	ret 
80004d14:	0b 24 40 90 	addx %d9,%d4,%d2
80004d18:	0b 35 50 30 	addc %d3,%d5,%d3
80004d1c:	59 61 04 00 	st.w [%a6]4,%d1
80004d20:	59 60 08 00 	st.w [%a6]8,%d0
80004d24:	59 69 0c 00 	st.w [%a6]12,%d9
80004d28:	59 63 10 00 	st.w [%a6]16,%d3
80004d2c:	82 32       	mov %d2,3
80004d2e:	7b 00 00 52 	movh %d5,8192
80004d32:	40 62       	mov.aa %a2,%a6
80004d34:	74 62       	st.w [%a6],%d2
80004d36:	0b 53 00 21 	eq %d2,%d3,%d5
80004d3a:	b7 02 01 20 	insert %d2,%d2,0,0,1
80004d3e:	0b 53 a0 22 	or.lt.u %d2,%d3,%d5
80004d42:	df 02 13 80 	jne %d2,0,80004d68 <_fpadd_parts+0x188>
80004d46:	8f f3 1f 20 	sh %d2,%d3,-1
80004d4a:	77 93 80 5f 	dextr %d5,%d3,%d9,31
80004d4e:	8f 19 00 31 	and %d3,%d9,1
80004d52:	59 62 10 00 	st.w [%a6]16,%d2
80004d56:	19 62 08 00 	ld.w %d2,[%a6]8
80004d5a:	a6 53       	or %d3,%d5
80004d5c:	c2 12       	add %d2,1
80004d5e:	d9 63 08 00 	lea %a3,[%a6]8
80004d62:	59 63 0c 00 	st.w [%a6]12,%d3
80004d66:	74 32       	st.w [%a3],%d2
80004d68:	00 90       	ret 
80004d6a:	40 42       	mov.aa %a2,%a4
80004d6c:	df 22 fe ff 	jne %d2,2,80004d68 <_fpadd_parts+0x188>
80004d70:	40 63       	mov.aa %a3,%a6
80004d72:	09 44 48 01 	ld.d %e4,[%a4+]8
80004d76:	89 34 48 01 	st.d [%a3+]8,%e4
80004d7a:	09 44 48 01 	ld.d %e4,[%a4+]8
80004d7e:	89 34 48 01 	st.d [%a3+]8,%e4
80004d82:	44 44       	ld.w %d4,[%a4+]
80004d84:	64 34       	st.w [%a3+],%d4
80004d86:	19 23 04 00 	ld.w %d3,[%a2]4
80004d8a:	19 52 04 00 	ld.w %d2,[%a5]4
80004d8e:	40 62       	mov.aa %a2,%a6
80004d90:	26 32       	and %d2,%d3
80004d92:	59 62 04 00 	st.w [%a6]4,%d2
80004d96:	00 90       	ret 
80004d98:	0b 07 80 60 	sub %d6,%d7,%d0
80004d9c:	8b 06 44 12 	lt %d1,%d6,64
80004da0:	df 01 1d 80 	jne %d1,0,80004dda <_fpadd_parts+0x1fa>
80004da4:	3f 07 06 00 	jlt %d7,%d0,80004db0 <_fpadd_parts+0x1d0>
80004da8:	d2 04       	mov %e4,0
80004daa:	02 70       	mov %d0,%d7
80004dac:	1d ff 64 ff 	j 80004c74 <_fpadd_parts+0x94>
80004db0:	d2 02       	mov %e2,0
80004db2:	1d ff 61 ff 	j 80004c74 <_fpadd_parts+0x94>
80004db6:	40 42       	mov.aa %a2,%a4
80004db8:	df 43 d8 ff 	jne %d3,4,80004d68 <_fpadd_parts+0x188>
80004dbc:	19 43 04 00 	ld.w %d3,[%a4]4
80004dc0:	19 52 04 00 	ld.w %d2,[%a5]4
80004dc4:	7b 00 00 48 	movh %d4,32768
80004dc8:	0b 23 10 21 	ne %d2,%d3,%d2
80004dcc:	1b c4 21 40 	addi %d4,%d4,540
80004dd0:	80 43       	mov.d %d3,%a4
80004dd2:	2b 43 50 22 	seln %d2,%d2,%d3,%d4
80004dd6:	60 22       	mov.a %a2,%d2
80004dd8:	00 90       	ret 
80004dda:	8b 06 82 02 	ge %d0,%d6,32
80004dde:	2b 54 50 90 	seln %d9,%d0,%d4,%d5
80004de2:	ab 05 a0 80 	seln %d8,%d0,%d5,0
80004de6:	8f f6 01 01 	and %d0,%d6,31
80004dea:	8b 00 02 11 	rsub %d1,%d0,32
80004dee:	17 98 80 11 	dextr %d1,%d8,%d9,%d1
80004df2:	2b 91 40 10 	sel %d1,%d0,%d1,%d9
80004df6:	8b 06 82 a2 	ge %d10,%d6,32
80004dfa:	32 50       	rsub %d0
80004dfc:	02 19       	mov %d9,%d1
80004dfe:	8f f6 01 61 	and %d6,%d6,31
80004e02:	82 f1       	mov %d1,-1
80004e04:	0f 08 00 80 	sh %d8,%d8,%d0
80004e08:	17 11 80 06 	dextr %d0,%d1,%d1,%d6
80004e0c:	0f 61 00 60 	sh %d6,%d1,%d6
80004e10:	2b 60 50 0a 	seln %d0,%d10,%d0,%d6
80004e14:	ab 06 a0 6a 	seln %d6,%d10,%d6,0
80004e18:	0f 64 e0 10 	andn %d1,%d4,%d6
80004e1c:	0f 05 e0 60 	andn %d6,%d5,%d0
80004e20:	a6 16       	or %d6,%d1
80004e22:	8b 06 00 95 	or.ne %d9,%d6,0
80004e26:	0b 98 10 48 	mov %e4,%d8,%d9
80004e2a:	02 70       	mov %d0,%d7
80004e2c:	1d ff 24 ff 	j 80004c74 <_fpadd_parts+0x94>

80004e30 <__subdf3>:
80004e30:	20 50       	sub.a %sp,80
80004e32:	d9 a5 14 00 	lea %a5,[%sp]20
80004e36:	d9 a4 04 00 	lea %a4,[%sp]4
80004e3a:	89 a4 44 09 	st.d [%sp]4,%e4
80004e3e:	89 a6 4c 09 	st.d [%sp]12,%e6
80004e42:	6d 00 ad 02 	call 8000539c <__unpack_d>
80004e46:	d9 a5 28 00 	lea %a5,[%sp]40
80004e4a:	d9 a4 0c 00 	lea %a4,[%sp]12
80004e4e:	6d 00 a7 02 	call 8000539c <__unpack_d>
80004e52:	19 a2 2c 00 	ld.w %d2,[%sp]44
80004e56:	d9 a4 14 00 	lea %a4,[%sp]20
80004e5a:	8f 12 80 21 	xor %d2,%d2,1
80004e5e:	d9 a6 3c 00 	lea %a6,[%sp]60
80004e62:	d9 a5 28 00 	lea %a5,[%sp]40
80004e66:	59 a2 2c 00 	st.w [%sp]44,%d2
80004e6a:	6d ff bb fe 	call 80004be0 <_fpadd_parts>
80004e6e:	40 24       	mov.aa %a4,%a2
80004e70:	6d 00 c7 01 	call 800051fe <__pack_d>
80004e74:	00 90       	ret 

80004e76 <__muldf3>:
80004e76:	20 50       	sub.a %sp,80
80004e78:	d9 a5 14 00 	lea %a5,[%sp]20
80004e7c:	d9 a4 04 00 	lea %a4,[%sp]4
80004e80:	89 a4 44 09 	st.d [%sp]4,%e4
80004e84:	89 a6 4c 09 	st.d [%sp]12,%e6
80004e88:	6d 00 8a 02 	call 8000539c <__unpack_d>
80004e8c:	d9 a5 28 00 	lea %a5,[%sp]40
80004e90:	d9 a4 0c 00 	lea %a4,[%sp]12
80004e94:	6d 00 84 02 	call 8000539c <__unpack_d>
80004e98:	19 a2 14 00 	ld.w %d2,[%sp]20
80004e9c:	ff 22 0f 80 	jge.u %d2,2,80004eba <__muldf3+0x44>
80004ea0:	19 a3 18 00 	ld.w %d3,[%sp]24
80004ea4:	19 a2 2c 00 	ld.w %d2,[%sp]44
80004ea8:	d9 a4 14 00 	lea %a4,[%sp]20
80004eac:	0b 23 10 21 	ne %d2,%d3,%d2
80004eb0:	59 a2 18 00 	st.w [%sp]24,%d2
80004eb4:	6d 00 a5 01 	call 800051fe <__pack_d>
80004eb8:	00 90       	ret 
80004eba:	19 a3 28 00 	ld.w %d3,[%sp]40
80004ebe:	bf 23 14 80 	jlt.u %d3,2,80004ee6 <__muldf3+0x70>
80004ec2:	df 42 0a 80 	jne %d2,4,80004ed6 <__muldf3+0x60>
80004ec6:	91 00 00 48 	movh.a %a4,32768
80004eca:	d9 44 1c 80 	lea %a4,[%a4]540 <8000021c <__thenan_df>>
80004ece:	df 23 f3 7f 	jeq %d3,2,80004eb4 <__muldf3+0x3e>
80004ed2:	1d ff e7 ff 	j 80004ea0 <__muldf3+0x2a>
80004ed6:	df 43 15 80 	jne %d3,4,80004f00 <__muldf3+0x8a>
80004eda:	91 00 00 48 	movh.a %a4,32768
80004ede:	d9 44 1c 80 	lea %a4,[%a4]540 <8000021c <__thenan_df>>
80004ee2:	df 22 e9 7f 	jeq %d2,2,80004eb4 <__muldf3+0x3e>
80004ee6:	19 a2 2c 00 	ld.w %d2,[%sp]44
80004eea:	19 a3 18 00 	ld.w %d3,[%sp]24
80004eee:	d9 a4 28 00 	lea %a4,[%sp]40
80004ef2:	0b 23 10 21 	ne %d2,%d3,%d2
80004ef6:	59 a2 2c 00 	st.w [%sp]44,%d2
80004efa:	6d 00 82 01 	call 800051fe <__pack_d>
80004efe:	00 90       	ret 
80004f00:	19 a5 2c 00 	ld.w %d5,[%sp]44
80004f04:	19 a4 18 00 	ld.w %d4,[%sp]24
80004f08:	0b 45 10 a1 	ne %d10,%d5,%d4
80004f0c:	df 22 aa 00 	jeq %d2,2,80005060 <__muldf3+0x1ea>
80004f10:	df 23 ae 00 	jeq %d3,2,8000506c <__muldf3+0x1f6>
80004f14:	19 a6 34 00 	ld.w %d6,[%sp]52
80004f18:	19 a4 20 00 	ld.w %d4,[%sp]32
80004f1c:	82 03       	mov %d3,0
80004f1e:	73 46 68 00 	mul.u %e0,%d6,%d4
80004f22:	19 a2 38 00 	ld.w %d2,[%sp]56
80004f26:	82 0b       	mov %d11,0
80004f28:	03 36 0a 11 	madd %d1,%d1,%d6,%d3
80004f2c:	02 48       	mov %d8,%d4
80004f2e:	19 a7 24 00 	ld.w %d7,[%sp]36
80004f32:	03 4b 0a 11 	madd %d1,%d1,%d11,%d4
80004f36:	73 42 68 40 	mul.u %e4,%d2,%d4
80004f3a:	82 0d       	mov %d13,0
80004f3c:	82 0c       	mov %d12,0
80004f3e:	03 32 0a 55 	madd %d5,%d5,%d2,%d3
80004f42:	03 8d 0a 55 	madd %d5,%d5,%d13,%d8
80004f46:	73 27 68 80 	mul.u %e8,%d7,%d2
80004f4a:	03 d7 0a 99 	madd %d9,%d9,%d7,%d13
80004f4e:	03 2c 0a 99 	madd %d9,%d9,%d12,%d2
80004f52:	03 67 68 24 	madd.u %e2,%e4,%d7,%d6
80004f56:	03 b7 0a 33 	madd %d3,%d3,%d7,%d11
80004f5a:	03 6c 0a 33 	madd %d3,%d3,%d12,%d6
80004f5e:	0b 35 00 61 	eq %d6,%d5,%d3
80004f62:	0b 42 30 62 	and.lt.u %d6,%d2,%d4
80004f66:	0b 53 a0 62 	or.lt.u %d6,%d3,%d5
80004f6a:	02 67       	mov %d7,%d6
80004f6c:	82 06       	mov %d6,0
80004f6e:	0b 06 40 60 	addx %d6,%d6,%d0
80004f72:	0b 12 50 50 	addc %d5,%d2,%d1
80004f76:	0b 51 00 41 	eq %d4,%d1,%d5
80004f7a:	0b 06 50 42 	and.ge.u %d4,%d6,%d0
80004f7e:	0b 51 a0 42 	or.lt.u %d4,%d1,%d5
80004f82:	df 04 06 80 	jne %d4,0,80004f8e <__muldf3+0x118>
80004f86:	8b 1b 80 b0 	addx %d11,%d11,1
80004f8a:	8b 07 a0 70 	addc %d7,%d7,0
80004f8e:	82 04       	mov %d4,0
80004f90:	0b 83 40 30 	addx %d3,%d3,%d8
80004f94:	0b 94 50 20 	addc %d2,%d4,%d9
80004f98:	0b b3 40 30 	addx %d3,%d3,%d11
80004f9c:	0b 72 50 20 	addc %d2,%d2,%d7
80004fa0:	19 a4 1c 00 	ld.w %d4,[%sp]28
80004fa4:	19 a7 30 00 	ld.w %d7,[%sp]48
80004fa8:	59 aa 00 10 	st.w [%sp]64,%d10
80004fac:	0b 74 00 10 	add %d1,%d4,%d7
80004fb0:	7b 00 00 42 	movh %d4,8192
80004fb4:	1b 41 00 00 	addi %d0,%d1,4
80004fb8:	0b 42 00 71 	eq %d7,%d2,%d4
80004fbc:	b7 07 01 70 	insert %d7,%d7,0,0,1
80004fc0:	59 a0 04 10 	st.w [%sp]68,%d0
80004fc4:	0b 42 a0 72 	or.lt.u %d7,%d2,%d4
80004fc8:	df 07 2b 80 	jne %d7,0,8000501e <__muldf3+0x1a8>
80004fcc:	1b 51 00 70 	addi %d7,%d1,5
80004fd0:	8f 13 00 01 	and %d0,%d3,1
80004fd4:	02 71       	mov %d1,%d7
80004fd6:	df 00 07 00 	jeq %d0,0,80004fe4 <__muldf3+0x16e>
80004fda:	77 65 80 6f 	dextr %d6,%d5,%d6,31
80004fde:	06 f5       	sh %d5,-1
80004fe0:	b7 f5 81 5f 	insert %d5,%d5,15,31,1
80004fe4:	77 32 80 3f 	dextr %d3,%d2,%d3,31
80004fe8:	06 f2       	sh %d2,-1
80004fea:	0b 24 30 01 	lt.u %d0,%d4,%d2
80004fee:	0b 24 70 02 	or.eq %d0,%d4,%d2
80004ff2:	c2 17       	add %d7,1
80004ff4:	df 00 ee ff 	jne %d0,0,80004fd0 <__muldf3+0x15a>
80004ff8:	59 a1 04 10 	st.w [%sp]68,%d1
80004ffc:	8f f3 0f 41 	and %d4,%d3,255
80005000:	8b 04 28 42 	ne %d4,%d4,128
80005004:	df 04 3a 00 	jeq %d4,0,80005078 <__muldf3+0x202>
80005008:	59 a2 0c 10 	st.w [%sp]76,%d2
8000500c:	82 32       	mov %d2,3
8000500e:	59 a3 08 10 	st.w [%sp]72,%d3
80005012:	d9 a4 3c 00 	lea %a4,[%sp]60
80005016:	59 a2 3c 00 	st.w [%sp]60,%d2
8000501a:	1d ff 4d ff 	j 80004eb4 <__muldf3+0x3e>
8000501e:	7b 00 00 71 	movh %d7,4096
80005022:	0b 27 30 41 	lt.u %d4,%d7,%d2
80005026:	0b 27 70 42 	or.eq %d4,%d7,%d2
8000502a:	df 04 e9 ff 	jne %d4,0,80004ffc <__muldf3+0x186>
8000502e:	77 32 80 20 	dextr %d2,%d2,%d3,1
80005032:	c2 f0       	add %d0,-1
80005034:	06 13       	sh %d3,1
80005036:	ff 05 06 00 	jge %d5,0,80005042 <__muldf3+0x1cc>
8000503a:	8f 13 40 11 	or %d1,%d3,1
8000503e:	0b 21 10 28 	mov %e2,%d1,%d2
80005042:	0b 72 00 41 	eq %d4,%d2,%d7
80005046:	b7 04 01 40 	insert %d4,%d4,0,0,1
8000504a:	77 65 80 50 	dextr %d5,%d5,%d6,1
8000504e:	0b 72 a0 42 	or.lt.u %d4,%d2,%d7
80005052:	06 16       	sh %d6,1
80005054:	df 04 ed ff 	jne %d4,0,8000502e <__muldf3+0x1b8>
80005058:	59 a0 04 10 	st.w [%sp]68,%d0
8000505c:	1d ff d0 ff 	j 80004ffc <__muldf3+0x186>
80005060:	59 aa 18 00 	st.w [%sp]24,%d10
80005064:	d9 a4 14 00 	lea %a4,[%sp]20
80005068:	1d ff 26 ff 	j 80004eb4 <__muldf3+0x3e>
8000506c:	59 aa 2c 00 	st.w [%sp]44,%d10
80005070:	d9 a4 28 00 	lea %a4,[%sp]40
80005074:	1d ff 20 ff 	j 80004eb4 <__muldf3+0x3e>
80005078:	77 32 00 4c 	dextr %d4,%d2,%d3,24
8000507c:	a6 65       	or %d5,%d6
8000507e:	8b 05 20 52 	ne %d5,%d5,0
80005082:	0f 45 e0 40 	andn %d4,%d5,%d4
80005086:	df 04 c1 7f 	jeq %d4,0,80005008 <__muldf3+0x192>
8000508a:	8b 03 88 30 	addx %d3,%d3,128
8000508e:	8b 02 a0 20 	addc %d2,%d2,0
80005092:	8f f3 cf 31 	andn %d3,%d3,255
80005096:	1d ff b9 ff 	j 80005008 <__muldf3+0x192>

8000509a <__gedf2>:
8000509a:	20 38       	sub.a %sp,56
8000509c:	d9 a5 10 00 	lea %a5,[%sp]16
800050a0:	40 a4       	mov.aa %a4,%sp
800050a2:	89 a4 40 09 	st.d [%sp],%e4
800050a6:	89 a6 48 09 	st.d [%sp]8,%e6
800050aa:	6d 00 79 01 	call 8000539c <__unpack_d>
800050ae:	d9 a5 24 00 	lea %a5,[%sp]36
800050b2:	d9 a4 08 00 	lea %a4,[%sp]8
800050b6:	6d 00 73 01 	call 8000539c <__unpack_d>
800050ba:	19 a3 10 00 	ld.w %d3,[%sp]16
800050be:	82 f2       	mov %d2,-1
800050c0:	bf 23 0c 80 	jlt.u %d3,2,800050d8 <__gedf2+0x3e>
800050c4:	19 a3 24 00 	ld.w %d3,[%sp]36
800050c8:	bf 23 08 80 	jlt.u %d3,2,800050d8 <__gedf2+0x3e>
800050cc:	d9 a5 24 00 	lea %a5,[%sp]36
800050d0:	d9 a4 10 00 	lea %a4,[%sp]16
800050d4:	6d 00 c3 01 	call 8000545a <__fpcmp_parts_d>
800050d8:	00 90       	ret 

800050da <__fixdfsi>:
800050da:	20 20       	sub.a %sp,32
800050dc:	d9 a5 0c 00 	lea %a5,[%sp]12
800050e0:	d9 a4 04 00 	lea %a4,[%sp]4
800050e4:	89 a4 44 09 	st.d [%sp]4,%e4
800050e8:	6d 00 5a 01 	call 8000539c <__unpack_d>
800050ec:	19 a3 0c 00 	ld.w %d3,[%sp]12
800050f0:	82 02       	mov %d2,0
800050f2:	bf 33 25 80 	jlt.u %d3,3,8000513c <__fixdfsi+0x62>
800050f6:	df 43 29 00 	jeq %d3,4,80005148 <__fixdfsi+0x6e>
800050fa:	19 a3 14 00 	ld.w %d3,[%sp]20
800050fe:	bf 03 1f 00 	jlt %d3,0,8000513c <__fixdfsi+0x62>
80005102:	8b f3 41 22 	lt %d2,%d3,31
80005106:	19 a6 10 00 	ld.w %d6,[%sp]16
8000510a:	df 02 1a 00 	jeq %d2,0,8000513e <__fixdfsi+0x64>
8000510e:	8b c3 03 21 	rsub %d2,%d3,60
80005112:	19 a5 1c 00 	ld.w %d5,[%sp]28
80005116:	19 a4 18 00 	ld.w %d4,[%sp]24
8000511a:	8b 02 82 32 	ge %d3,%d2,32
8000511e:	2b 54 50 43 	seln %d4,%d3,%d4,%d5
80005122:	ab 05 a0 53 	seln %d5,%d3,%d5,0
80005126:	8f f2 01 31 	and %d3,%d2,31
8000512a:	8b 03 02 21 	rsub %d2,%d3,32
8000512e:	17 45 80 22 	dextr %d2,%d5,%d4,%d2
80005132:	2b 42 40 23 	sel %d2,%d3,%d2,%d4
80005136:	df 06 03 00 	jeq %d6,0,8000513c <__fixdfsi+0x62>
8000513a:	32 52       	rsub %d2
8000513c:	00 90       	ret 
8000513e:	82 f2       	mov %d2,-1
80005140:	06 f2       	sh %d2,-1
80005142:	ab 12 00 26 	cadd %d2,%d6,%d2,1
80005146:	00 90       	ret 
80005148:	19 a3 10 00 	ld.w %d3,[%sp]16
8000514c:	82 f2       	mov %d2,-1
8000514e:	06 f2       	sh %d2,-1
80005150:	ab 12 00 23 	cadd %d2,%d3,%d2,1
80005154:	00 90       	ret 

80005156 <__make_dp>:
80005156:	20 18       	sub.a %sp,24
80005158:	09 a2 d8 09 	ld.da %a2,[%sp]24
8000515c:	d9 a4 04 00 	lea %a4,[%sp]4
80005160:	59 a4 04 00 	st.w [%sp]4,%d4
80005164:	59 a5 08 00 	st.w [%sp]8,%d5
80005168:	59 a6 0c 00 	st.w [%sp]12,%d6
8000516c:	89 a2 d0 09 	st.da [%sp]16,%a2
80005170:	6d 00 47 00 	call 800051fe <__pack_d>
80005174:	00 90       	ret 

80005176 <__unpack_f>:
80005176:	54 42       	ld.w %d2,[%a4]
80005178:	8f 12 1e 50 	sh %d5,%d2,-31
8000517c:	37 02 e8 3b 	extr.u %d3,%d2,23,8
80005180:	b7 02 89 4b 	insert %d4,%d2,0,23,9
80005184:	59 55 04 00 	st.w [%a5]4,%d5
80005188:	df 03 16 80 	jne %d3,0,800051b4 <__unpack_f+0x3e>
8000518c:	df 04 25 00 	jeq %d4,0,800051d6 <__unpack_f+0x60>
80005190:	82 33       	mov %d3,3
80005192:	8f 74 00 20 	sh %d2,%d4,7
80005196:	7b 00 00 54 	movh %d5,16384
8000519a:	74 53       	st.w [%a5],%d3
8000519c:	3b 10 f8 3f 	mov %d3,-127
800051a0:	06 12       	sh %d2,1
800051a2:	02 34       	mov %d4,%d3
800051a4:	c2 f3       	add %d3,-1
800051a6:	3f 52 fd ff 	jlt.u %d2,%d5,800051a0 <__unpack_f+0x2a>
800051aa:	59 54 08 00 	st.w [%a5]8,%d4
800051ae:	59 52 0c 00 	st.w [%a5]12,%d2
800051b2:	00 90       	ret 
800051b4:	8b f3 2f 52 	ne %d5,%d3,255
800051b8:	df 05 12 00 	jeq %d5,0,800051dc <__unpack_f+0x66>
800051bc:	82 32       	mov %d2,3
800051be:	1b 13 f8 3f 	addi %d3,%d3,-127
800051c2:	74 52       	st.w [%a5],%d2
800051c4:	8f 74 00 20 	sh %d2,%d4,7
800051c8:	b7 f2 01 2f 	insert %d2,%d2,15,30,1
800051cc:	59 53 08 00 	st.w [%a5]8,%d3
800051d0:	59 52 0c 00 	st.w [%a5]12,%d2
800051d4:	00 90       	ret 
800051d6:	82 22       	mov %d2,2
800051d8:	74 52       	st.w [%a5],%d2
800051da:	00 90       	ret 
800051dc:	df 04 05 80 	jne %d4,0,800051e6 <__unpack_f+0x70>
800051e0:	82 42       	mov %d2,4
800051e2:	74 52       	st.w [%a5],%d2
800051e4:	00 90       	ret 
800051e6:	37 02 61 3b 	extr.u %d3,%d2,22,1
800051ea:	06 72       	sh %d2,7
800051ec:	74 53       	st.w [%a5],%d3
800051ee:	7b 00 00 32 	movh %d3,8192
800051f2:	1b 03 f8 3f 	addi %d3,%d3,-128
800051f6:	26 32       	and %d2,%d3
800051f8:	59 52 0c 00 	st.w [%a5]12,%d2
800051fc:	00 90       	ret 

800051fe <__pack_d>:
800051fe:	54 44       	ld.w %d4,[%a4]
80005200:	19 43 0c 00 	ld.w %d3,[%a4]12
80005204:	19 42 10 00 	ld.w %d2,[%a4]16
80005208:	19 41 04 00 	ld.w %d1,[%a4]4
8000520c:	bf 24 56 80 	jlt.u %d4,2,800052b8 <__pack_d+0xba>
80005210:	7b 00 ff 57 	movh %d5,32752
80005214:	d2 06       	mov %e6,0
80005216:	df 44 0b 00 	jeq %d4,4,8000522c <__pack_d+0x2e>
8000521a:	0f 23 a0 50 	or %d5,%d3,%d2
8000521e:	8b 05 00 02 	eq %d0,%d5,0
80005222:	8b 24 e0 04 	or.eq %d0,%d4,2
80005226:	82 05       	mov %d5,0
80005228:	df 00 0c 00 	jeq %d0,0,80005240 <__pack_d+0x42>
8000522c:	0b 10 00 28 	mov %e2,%d1
80005230:	a6 75       	or %d5,%d7
80005232:	8f f2 01 20 	sh %d2,%d2,31
80005236:	0f 25 a0 40 	or %d4,%d5,%d2
8000523a:	02 43       	mov %d3,%d4
8000523c:	02 62       	mov %d2,%d6
8000523e:	00 90       	ret 
80005240:	19 44 08 00 	ld.w %d4,[%a4]8
80005244:	3b 20 c0 0f 	mov %d0,-1022
80005248:	3f 04 41 00 	jlt %d4,%d0,800052ca <__pack_d+0xcc>
8000524c:	3b 00 40 00 	mov %d0,1024
80005250:	7b 00 ff 57 	movh %d5,32752
80005254:	7f 04 ec 7f 	jge %d4,%d0,8000522c <__pack_d+0x2e>
80005258:	8f f3 0f 51 	and %d5,%d3,255
8000525c:	8b 05 28 52 	ne %d5,%d5,128
80005260:	df 05 1b 00 	jeq %d5,0,80005296 <__pack_d+0x98>
80005264:	8b f3 87 30 	addx %d3,%d3,127
80005268:	8b 02 a0 20 	addc %d2,%d2,0
8000526c:	7b 00 00 52 	movh %d5,8192
80005270:	0b 25 30 61 	lt.u %d6,%d5,%d2
80005274:	0b 25 70 62 	or.eq %d6,%d5,%d2
80005278:	df 06 19 80 	jne %d6,0,800052aa <__pack_d+0xac>
8000527c:	1b f4 3f 40 	addi %d4,%d4,1023
80005280:	0b 40 00 48 	mov %e4,%d4
80005284:	77 32 00 6c 	dextr %d6,%d2,%d3,24
80005288:	06 82       	sh %d2,-8
8000528a:	b7 02 0c 7a 	insert %d7,%d2,0,20,12
8000528e:	8f 44 01 50 	sh %d5,%d4,20
80005292:	1d ff cd ff 	j 8000522c <__pack_d+0x2e>
80005296:	8f 03 10 51 	and %d5,%d3,256
8000529a:	df 05 e9 7f 	jeq %d5,0,8000526c <__pack_d+0x6e>
8000529e:	8b 03 88 30 	addx %d3,%d3,128
800052a2:	8b 02 a0 20 	addc %d2,%d2,0
800052a6:	1d ff e3 ff 	j 8000526c <__pack_d+0x6e>
800052aa:	77 32 80 3f 	dextr %d3,%d2,%d3,31
800052ae:	1b 04 40 40 	addi %d4,%d4,1024
800052b2:	06 f2       	sh %d2,-1
800052b4:	1d ff e6 ff 	j 80005280 <__pack_d+0x82>
800052b8:	77 32 00 6c 	dextr %d6,%d2,%d3,24
800052bc:	06 82       	sh %d2,-8
800052be:	b7 12 8d 79 	insert %d7,%d2,1,19,13
800052c2:	7b 00 ff 57 	movh %d5,32752
800052c6:	1d ff b3 ff 	j 8000522c <__pack_d+0x2e>
800052ca:	0b 40 80 40 	sub %d4,%d0,%d4
800052ce:	8b 94 83 02 	ge %d0,%d4,57
800052d2:	df 00 ad ff 	jne %d0,0,8000522c <__pack_d+0x2e>
800052d6:	8b 04 82 52 	ge %d5,%d4,32
800052da:	2b 23 50 05 	seln %d0,%d5,%d3,%d2
800052de:	ab 02 a0 75 	seln %d7,%d5,%d2,0
800052e2:	8f f4 01 51 	and %d5,%d4,31
800052e6:	8b 05 02 61 	rsub %d6,%d5,32
800052ea:	17 07 80 66 	dextr %d6,%d7,%d0,%d6
800052ee:	2b 06 40 65 	sel %d6,%d5,%d6,%d0
800052f2:	8b 04 82 82 	ge %d8,%d4,32
800052f6:	32 55       	rsub %d5
800052f8:	02 60       	mov %d0,%d6
800052fa:	8f f4 01 41 	and %d4,%d4,31
800052fe:	82 f6       	mov %d6,-1
80005300:	0f 57 00 70 	sh %d7,%d7,%d5
80005304:	17 66 80 54 	dextr %d5,%d6,%d6,%d4
80005308:	0f 46 00 40 	sh %d4,%d6,%d4
8000530c:	2b 45 50 58 	seln %d5,%d8,%d5,%d4
80005310:	ab 04 a0 48 	seln %d4,%d8,%d4,0
80005314:	0f 43 e0 30 	andn %d3,%d3,%d4
80005318:	0f 52 e0 20 	andn %d2,%d2,%d5
8000531c:	a6 32       	or %d2,%d3
8000531e:	02 03       	mov %d3,%d0
80005320:	8b 02 00 35 	or.ne %d3,%d2,0
80005324:	8f f3 0f 51 	and %d5,%d3,255
80005328:	82 12       	mov %d2,1
8000532a:	8b 05 08 24 	and.eq %d2,%d5,128
8000532e:	02 74       	mov %d4,%d7
80005330:	df 02 14 80 	jne %d2,0,80005358 <__pack_d+0x15a>
80005334:	8b f3 87 30 	addx %d3,%d3,127
80005338:	8b 07 a0 20 	addc %d2,%d7,0
8000533c:	77 32 00 6c 	dextr %d6,%d2,%d3,24
80005340:	7b 00 00 31 	movh %d3,4096
80005344:	8f 82 1f 70 	sh %d7,%d2,-8
80005348:	0b 32 50 21 	ge.u %d2,%d2,%d3
8000534c:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
80005350:	8f 42 01 50 	sh %d5,%d2,20
80005354:	1d ff 6c ff 	j 8000522c <__pack_d+0x2e>
80005358:	8b 03 88 60 	addx %d6,%d3,128
8000535c:	8b 07 a0 20 	addc %d2,%d7,0
80005360:	7b 00 00 a1 	movh %d10,4096
80005364:	8f 82 1f 70 	sh %d7,%d2,-8
80005368:	77 62 00 6c 	dextr %d6,%d2,%d6,24
8000536c:	0b a2 50 21 	ge.u %d2,%d2,%d10
80005370:	53 12 40 80 	mul.u %e8,%d2,1
80005374:	8f 03 10 01 	and %d0,%d3,256
80005378:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
8000537c:	8f 48 01 50 	sh %d5,%d8,20
80005380:	df 00 56 ff 	jne %d0,0,8000522c <__pack_d+0x2e>
80005384:	8f 84 1f 70 	sh %d7,%d4,-8
80005388:	0b a4 50 21 	ge.u %d2,%d4,%d10
8000538c:	77 34 00 6c 	dextr %d6,%d4,%d3,24
80005390:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
80005394:	8f 42 01 50 	sh %d5,%d2,20
80005398:	1d ff 4a ff 	j 8000522c <__pack_d+0x2e>

8000539c <__unpack_d>:
8000539c:	09 48 40 09 	ld.d %e8,[%a4]
800053a0:	3b f0 7f 00 	mov %d0,2047
800053a4:	8f 19 1e 70 	sh %d7,%d9,-31
800053a8:	37 09 6b 5a 	extr.u %d5,%d9,20,11
800053ac:	b7 09 0c 6a 	insert %d6,%d9,0,20,12
800053b0:	59 57 04 00 	st.w [%a5]4,%d7
800053b4:	df 05 26 80 	jne %d5,0,80005400 <__unpack_d+0x64>
800053b8:	8b 08 20 22 	ne %d2,%d8,0
800053bc:	8b 06 00 25 	or.ne %d2,%d6,0
800053c0:	df 02 33 00 	jeq %d2,0,80005426 <__unpack_d+0x8a>
800053c4:	82 32       	mov %d2,3
800053c6:	77 86 00 34 	dextr %d3,%d6,%d8,8
800053ca:	8f 88 00 40 	sh %d4,%d8,8
800053ce:	74 52       	st.w [%a5],%d2
800053d0:	3b 10 c0 5f 	mov %d5,-1023
800053d4:	7b 00 00 61 	movh %d6,4096
800053d8:	77 43 80 30 	dextr %d3,%d3,%d4,1
800053dc:	02 57       	mov %d7,%d5
800053de:	0b 63 00 21 	eq %d2,%d3,%d6
800053e2:	b7 02 01 20 	insert %d2,%d2,0,0,1
800053e6:	06 14       	sh %d4,1
800053e8:	0b 63 a0 22 	or.lt.u %d2,%d3,%d6
800053ec:	c2 f5       	add %d5,-1
800053ee:	df 02 f5 ff 	jne %d2,0,800053d8 <__unpack_d+0x3c>
800053f2:	59 57 08 00 	st.w [%a5]8,%d7
800053f6:	59 54 0c 00 	st.w [%a5]12,%d4
800053fa:	59 53 10 00 	st.w [%a5]16,%d3
800053fe:	00 90       	ret 
80005400:	5f 05 16 00 	jeq %d5,%d0,8000542c <__unpack_d+0x90>
80005404:	82 32       	mov %d2,3
80005406:	1b 15 c0 5f 	addi %d5,%d5,-1023
8000540a:	8f 88 00 40 	sh %d4,%d8,8
8000540e:	74 52       	st.w [%a5],%d2
80005410:	77 86 00 24 	dextr %d2,%d6,%d8,8
80005414:	59 55 08 00 	st.w [%a5]8,%d5
80005418:	b7 f2 01 2e 	insert %d2,%d2,15,28,1
8000541c:	59 54 0c 00 	st.w [%a5]12,%d4
80005420:	59 52 10 00 	st.w [%a5]16,%d2
80005424:	00 90       	ret 
80005426:	82 22       	mov %d2,2
80005428:	74 52       	st.w [%a5],%d2
8000542a:	00 90       	ret 
8000542c:	8b 08 20 52 	ne %d5,%d8,0
80005430:	8b 06 00 55 	or.ne %d5,%d6,0
80005434:	df 05 05 80 	jne %d5,0,8000543e <__unpack_d+0xa2>
80005438:	82 42       	mov %d2,4
8000543a:	74 52       	st.w [%a5],%d2
8000543c:	00 90       	ret 
8000543e:	77 89 00 34 	dextr %d3,%d9,%d8,8
80005442:	37 09 e1 49 	extr.u %d4,%d9,19,1
80005446:	b7 03 85 3d 	insert %d3,%d3,0,27,5
8000544a:	8f 88 00 20 	sh %d2,%d8,8
8000544e:	74 54       	st.w [%a5],%d4
80005450:	59 52 0c 00 	st.w [%a5]12,%d2
80005454:	59 53 10 00 	st.w [%a5]16,%d3
80005458:	00 90       	ret 

8000545a <__fpcmp_parts_d>:
8000545a:	54 43       	ld.w %d3,[%a4]
8000545c:	82 12       	mov %d2,1
8000545e:	bf 23 45 80 	jlt.u %d3,2,800054e8 <__fpcmp_parts_d+0x8e>
80005462:	54 54       	ld.w %d4,[%a5]
80005464:	bf 24 42 80 	jlt.u %d4,2,800054e8 <__fpcmp_parts_d+0x8e>
80005468:	8b 44 00 52 	eq %d5,%d4,4
8000546c:	8b 43 00 54 	and.eq %d5,%d3,4
80005470:	df 05 50 80 	jne %d5,0,80005510 <__fpcmp_parts_d+0xb6>
80005474:	df 43 45 00 	jeq %d3,4,800054fe <__fpcmp_parts_d+0xa4>
80005478:	df 44 3d 00 	jeq %d4,4,800054f2 <__fpcmp_parts_d+0x98>
8000547c:	8b 24 00 52 	eq %d5,%d4,2
80005480:	8b 23 00 54 	and.eq %d5,%d3,2
80005484:	82 02       	mov %d2,0
80005486:	df 05 31 80 	jne %d5,0,800054e8 <__fpcmp_parts_d+0x8e>
8000548a:	df 23 34 00 	jeq %d3,2,800054f2 <__fpcmp_parts_d+0x98>
8000548e:	19 42 04 00 	ld.w %d2,[%a4]4
80005492:	df 24 2c 00 	jeq %d4,2,800054ea <__fpcmp_parts_d+0x90>
80005496:	19 53 04 00 	ld.w %d3,[%a5]4
8000549a:	5f 23 28 80 	jne %d3,%d2,800054ea <__fpcmp_parts_d+0x90>
8000549e:	19 44 08 00 	ld.w %d4,[%a4]8
800054a2:	19 53 08 00 	ld.w %d3,[%a5]8
800054a6:	3f 43 22 00 	jlt %d3,%d4,800054ea <__fpcmp_parts_d+0x90>
800054aa:	3f 34 2f 00 	jlt %d4,%d3,80005508 <__fpcmp_parts_d+0xae>
800054ae:	19 45 10 00 	ld.w %d5,[%a4]16
800054b2:	19 56 10 00 	ld.w %d6,[%a5]16
800054b6:	19 40 0c 00 	ld.w %d0,[%a4]12
800054ba:	0b 65 00 41 	eq %d4,%d5,%d6
800054be:	19 57 0c 00 	ld.w %d7,[%a5]12
800054c2:	02 43       	mov %d3,%d4
800054c4:	0b 07 50 32 	and.ge.u %d3,%d7,%d0
800054c8:	0b 70 50 42 	and.ge.u %d4,%d0,%d7
800054cc:	0b 65 a0 32 	or.lt.u %d3,%d5,%d6
800054d0:	0b 56 a0 42 	or.lt.u %d4,%d6,%d5
800054d4:	82 f5       	mov %d5,-1
800054d6:	ab 15 a0 52 	seln %d5,%d2,%d5,1
800054da:	82 16       	mov %d6,1
800054dc:	ab f6 bf 22 	seln %d2,%d2,%d6,-1
800054e0:	ab 05 a0 44 	seln %d4,%d4,%d5,0
800054e4:	2b 24 40 23 	sel %d2,%d3,%d4,%d2
800054e8:	00 90       	ret 
800054ea:	82 13       	mov %d3,1
800054ec:	ab f3 bf 22 	seln %d2,%d2,%d3,-1
800054f0:	00 90       	ret 
800054f2:	19 53 04 00 	ld.w %d3,[%a5]4
800054f6:	82 f2       	mov %d2,-1
800054f8:	ab 12 a0 23 	seln %d2,%d3,%d2,1
800054fc:	00 90       	ret 
800054fe:	19 43 04 00 	ld.w %d3,[%a4]4
80005502:	ab f2 bf 23 	seln %d2,%d3,%d2,-1
80005506:	00 90       	ret 
80005508:	82 f3       	mov %d3,-1
8000550a:	ab 13 a0 22 	seln %d2,%d2,%d3,1
8000550e:	00 90       	ret 
80005510:	19 53 04 00 	ld.w %d3,[%a5]4
80005514:	19 42 04 00 	ld.w %d2,[%a4]4
80005518:	0b 23 80 20 	sub %d2,%d3,%d2
8000551c:	00 90       	ret 

8000551e <__do_global_ctors_aux>:
8000551e:	91 00 00 28 	movh.a %a2,32768
80005522:	d9 22 50 55 	lea %a2,[%a2]21840 <80005550 <__CTOR_END__>>
80005526:	19 22 fc ff 	ld.w %d2,[%a2]-4 <7ffffffc <__CSA0_END+0xffc43fc>>
8000552a:	d9 23 fc ff 	lea %a3,[%a2]-4 <7ffffffc <__CSA0_END+0xffc43fc>>
8000552e:	df f2 0a 00 	jeq %d2,-1,80005542 <__do_global_ctors_aux+0x24>
80005532:	40 3c       	mov.aa %a12,%a3
80005534:	60 22       	mov.a %a2,%d2
80005536:	b0 cc       	add.a %a12,-4
80005538:	2d 02 00 00 	calli %a2
8000553c:	54 c2       	ld.w %d2,[%a12]
8000553e:	df f2 fb ff 	jne %d2,-1,80005534 <__do_global_ctors_aux+0x16>
80005542:	00 90       	ret 
